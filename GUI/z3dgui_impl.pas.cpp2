




          
     
  


   class Tz3DGUIController;

   class Tz3DDesktop;

   class Tz3DDialog;

   class Tz3DControl;

   class Tz3DButton;

   class Tz3DLabel;

   class Tz3DCheckBox;

   class Tz3DRadioButton;

   class Tz3DComboBox;

   class Tz3DTrackBar;

   class Tz3DEdit;

   class Tz3DIMEEditBox;

   class Tz3DListBox;

   class Tz3DScrollBar;

   class Tz3DDisplay;


    class Tz3DBlendColor : public Tz3DBase,Iz3DBlendColor
{
public:

  private:
      Tz3DBlendColorStates FStates; 

      TD3DXColor FCurrent; 

  protected:
       
SetCurrent (const TD3DXColor Value 
);
 ;
      
Pz3DBlendColorStates GetStates ();
 ;
       
SetStates (const Pz3DBlendColorStates Value 
);
 ;
      
TD3DXColor GetCurrent ();
 ;
  public:
          $    
SetColors (TD3DColor defaultColor ,
TD3DColor disabledColor = C8808080 ,
TD3DColor hiddenColor = 0 
);
 ;
          .7
Blend (Tz3DControlState iState ,
Single fRate = 0 
);
 ;
  public:
         /** \sa GetCurrent For reading   \sa SetCurrent For writing */
TD3DXColor Current; 

         /** \sa GetStates For reading   \sa SetStates For writing */
Pz3DBlendColorStates States; 

 };


    class Tz3DGUIController : public Tz3DBase,Iz3DGUIController
{
public:

  private:
      Boolean FModalMode; 

      typedef array<Pz3DTextureNode> FTextureCache;
      typedef array<Pz3DFontNode> FFontCache;
      IDirect3DStateBlock9 FStateBlock; 

      ID3DXSprite FSprite; 

      IInterfaceList FDialogs; 

      Iz3DDesktop FDesktop; 

  protected:
      
Integer GetTextureNodeCount ();
 ;
      
Integer GetFontsCount ();
 ;
      
Boolean GetModalMode ();
 ;
       
SetModalMode (const Boolean Value 
);
 ;
      
Iz3DDesktop GetDesktop ();
 ;
        
Iz3DDialog GetDialogs (const Integer I 
);
 ;
      
Integer GetDialogCount ();
 ;
      
ID3DXSprite GetSprite ();
 ;
       
Pz3DFontNode GetFonts (Integer iIndex 
);
 ;
       
Pz3DTextureNode GetTextureNode (Integer iIndex 
);
 ;
       
HRESULT CreateFont (LongWord index 
);
 ;
       
CreateScenarioObjects (const Boolean AResetDevice 
);
 ;
       
DestroyScenarioObjects (const Boolean ALostDevice 
);
 ;
                                
Message (const HWND AWnd ,
const Cardinal AMsg ,
const Integer AwParam ,
const Integer AlParam ,
Boolean &ADefault ,
Integer &AResult 
);
 ;
       
BringToFront (const Iz3DDialog ADialog 
);
 ;
     
GUIRender ();
 ;
  public:
       
Tz3DGUIController (const Iz3DDesktop ADesktop 
);
 ;
     
~Tz3DGUIController ();
 ;
          
Integer AddFont (PWideChar strFaceName ,
Longint height ,
Longint weight 
);
 ;
       
HRESULT CreateTexture (LongWord iTexture 
);

       
Integer AddTexture (PWideChar strFilename 
);
 ; ;
         
Integer AddTexture (PWideChar strResourceName ,
HMODULE hResourceModule 
);
 ; ;
       
Boolean RegisterDialog (Iz3DDialog pDialog 
);
 ;
        
Integer IndexOf (const Iz3DDialog ADialog 
);
 ;
      
UnregisterDialog (Iz3DDialog pDialog 
);
 ;
     
EnableKeyboardInputForAllDialogs ();
 ;
      
IDirect3DStateBlock9 GetStateBlock ();
 ;
  public:
         /** \sa GetModalMode For reading   \sa SetModalMode For writing */
Boolean ModalMode; 

       /** \sa GetDesktop For reading*/
Iz3DDesktop Desktop; 

    /*[I: Integer]*/   /** \sa GetFonts For reading*/
Pz3DFontNode Fonts; 

       /** \sa GetFontsCount For reading*/
Integer FontsCount; 

    /*[i: Integer]*/   /** \sa GetTextureNode For reading*/
Pz3DTextureNode TextureNode; 

       /** \sa GetTextureNodeCount For reading*/
Integer TextureNodeCount; 

       /** \sa GetSprite For reading*/
ID3DXSprite Sprite; 

       /** \sa GetDialogCount For reading*/
Integer DialogCount; 

    /*[const I: Integer]*/   /** \sa GetDialogs For reading*/
Iz3DDialog Dialogs; 

 };


    class Tz3DGUIFont : public Tz3DBase,Iz3DGUIFont
{
public:

  private:
      Iz3DFloat4 FColor; 

      DWORD FFormat; 

     WideChar FName[255]; /*!< [0..255] */

      Boolean FShadow; 

      Integer FSize; 

  protected:
      
Iz3DFloat4 GetColor ();
 ;
      
DWORD GetFormat ();
 ;
      
PWideChar GetName ();
 ;
      
Boolean GetShadow ();
 ;
      
Integer GetSize ();
 ;
       
SetFormat (const DWORD Value 
);
 ;
       
SetShadow (const Boolean Value 
);
 ;
       
SetSize (const Integer Value 
);
 ;
  public:
         
Tz3DGUIFont (const Iz3DBase AOwner = nil 
);
 ;
  public:
       /** \sa GetName For reading*/
PWideChar Name; 

         /** \sa GetSize For reading   \sa SetSize For writing */
Integer Size; 

       /** \sa GetColor For reading*/
Iz3DFloat4 Color; 

         /** \sa GetShadow For reading   \sa SetShadow For writing */
Boolean Shadow; 

         /** \sa GetFormat For reading   \sa SetFormat For writing */
DWORD Format; 

 };


    class Tz3DDesktopThemeSettings : public Tz3DBase,Iz3DDesktopThemeSettings
{
public:

  private:
      Iz3DGUIFont FCheckBoxFont; 

      Iz3DGUIFont FDefaultFont; 

      Iz3DGUIFont FRadioButtonFont; 

      Iz3DFloat4 FDialogColorBL; 

      Iz3DFloat4 FDialogColorBR; 

      Iz3DFloat4 FDialogColorTL; 

      Iz3DFloat4 FDialogColorTR; 

      Integer FCaptionHeight; 

  protected:
      
Integer GetCaptionHeight ();
 ;
       
SetCaptionHeight (const Integer Value 
);
 ;
      
Iz3DGUIFont GetCheckBoxFont ();
 ;
      
Iz3DGUIFont GetDefaultFont ();
  ;
      
Iz3DFloat4 GetDialogColorBL ();
 ;
      
Iz3DFloat4 GetDialogColorBR ();
 ;
      
Iz3DFloat4 GetDialogColorTL ();
 ;
      
Iz3DFloat4 GetDialogColorTR ();
 ;
      
Iz3DGUIFont GetRadioButtonFont ();
 ;
  public:
         
Tz3DDesktopThemeSettings (const Iz3DBase AOwner = nil 
);
 ;
  public:
       /** \sa GetDialogColorTL For reading*/
Iz3DFloat4 DialogColorTL; 

       /** \sa GetDialogColorTR For reading*/
Iz3DFloat4 DialogColorTR; 

       /** \sa GetDialogColorBL For reading*/
Iz3DFloat4 DialogColorBL; 

       /** \sa GetDialogColorBR For reading*/
Iz3DFloat4 DialogColorBR; 

         /** \sa GetCaptionHeight For reading   \sa SetCaptionHeight For writing */
Integer CaptionHeight; 

       /** \sa GetDefaultFont For reading*/
Iz3DGUIFont DefaultFont; 

       /** \sa GetCheckBoxFont For reading*/
Iz3DGUIFont CheckBoxFont; 

       /** \sa GetRadioButtonFont For reading*/
Iz3DGUIFont RadioButtonFont; 

 };


    class Tz3DDesktop : public Tz3DLinked,Iz3DDesktop
{
public:

  private:
      Boolean FVisible; 

      Iz3DProgressDialog FProgress; 

      Iz3DMainMenuDialog FMainMenu; 

      Iz3DTexture FWallpaper; 

      Iz3DTexture FLogo; 

      Iz3DRenderTexture FBlurWallpaperTemp; 

      Iz3DRenderTexture FBlurWallpaperFinal; 

      Boolean FFirstRender; 

      Boolean FBlurWallpaper; 

      Iz3DGUIController FGUIController; 

      Iz3DDesktopThemeSettings FThemeSettings; 

  protected:
      
Boolean GetVisible ();
 ;
       
SetVisible (const Boolean Value 
);
 ;
      
Iz3DProgressDialog GetProgressDialog ();
 ;
      
Iz3DDesktopThemeSettings GetThemeSettings ();
 ;
      
Iz3DGUIController GetGUIController ();
 ;
     
RenderEngineLogo ();
 ;
      
Boolean GetBlurWallpaper ();
 ;
       
SetBlurWallpaper (const Boolean Value 
);
 ;
      
Iz3DTexture GetWallpaper ();
 ;
       
z3DCreateScenarioObjects (const Tz3DCreateObjectCaller ACaller 
);
 ; ;
       
z3DDestroyScenarioObjects (const Tz3DDestroyObjectCaller ACaller 
);
 ; ;
                                
z3DMessage (const HWND AWnd ,
const Cardinal AMsg ,
const Integer AwParam ,
const Integer AlParam ,
Boolean &ADefault ,
Integer &AResult 
);
 ; ;
     
z3DGUIRender ();
 ; ;
  public:
     
StartScenario ();
 ;

       
BringToFront (const Iz3DDialog ADialog 
);
 ;
         
         
Tz3DDialogModalResult ShowMessage (const PWideChar AMessage ,
const Tz3DMessageDialogKind AKind = z3dmdkInformation 
);
 ;

      
Iz3DDialog CreateDialog ();
 ;
      
Iz3DProgressDialog CreateProgressDialog ();
 ;
      
Iz3DMainMenuDialog CreateMainMenuDialog ();
 ;
      
Iz3DConsoleDialog CreateConsoleDialog ();
 ;

         
Tz3DDesktop (const Iz3DBase AOwner = nil 
);
 ;
  public:
         /** \sa GetVisible For reading   \sa SetVisible For writing */
Boolean Visible; 

       /** \sa GetProgressDialog For reading*/
Iz3DProgressDialog ProgressDialog; 

       /** \sa GetWallpaper For reading*/
Iz3DTexture Wallpaper; 

         /** \sa GetBlurWallpaper For reading   \sa SetBlurWallpaper For writing */
Boolean BlurWallpaper; 

       /** \sa GetGUIController For reading*/
Iz3DGUIController Controller; 

       /** \sa GetThemeSettings For reading*/
Iz3DDesktopThemeSettings ThemeSettings; 

 };


    class Tz3DTextHelper : public Tz3DBase,Iz3DTextHelper
{
public:

  private:
      ID3DXFont FFont; 

      ID3DXSprite FSprite; 

      TD3DXColor FClr; 

      TPoint FPt; 

      Integer FLineHeight; 

  public:
          
Tz3DTextHelper (ID3DXFont pFont ,
ID3DXSprite pSprite ,
Integer nLineHeight 
);

     
~Tz3DTextHelper ();
 ;
       
SetInsertionPos (Integer x ,
Integer y 
);
 ;
      
SetForegroundColor (TD3DXColor clr 
);
 ;
     
BeginRender ();
 ;
           
HRESULT DrawFormattedTextLine (const PWideChar strMsg ,
const *args 
);
 ; ;
    #ifndef  FPC

           
HRESULT DrawFormattedTextLine (const WideString strMsg ,
const *args 
);
 ; ;
    #endif

    #ifndef  FPC

        
HRESULT DrawTextLine (const PAnsiChar strMsg 
);
 ; ;
    #endif

        
HRESULT DrawTextLine (const PWideChar strMsg 
);
 ; ;
    #ifdef  BORLAND
#ifndef  COMPILER6_UP

        
HRESULT DrawTextLine (const String strMsg 
);
 ; ;
    #endif
#endif

                     
HRESULT DrawFormattedTextLine (const TRect rc ,
DWORD dwFlags ,
const PWideChar strMsg ,
const *args 
);
 ; ;
             
HRESULT DrawTextLine (const TRect rc ,
DWORD dwFlags ,
const PWideChar strMsg 
);
 ; ;
     
EndRender ();
 ;
 };


  // Display properties for subcontrols
    class Tz3DDisplay : public Tz3DBase,Iz3DDisplay
{
public:

  private:
      LongWord iTexture; 
      // Index of the texture for this Display
      LongWord iFont; 
         // Index of the font for this Display
      DWORD dwTextFormat; 
     // The format argument to DrawText
      TRect rcTexture; 
        // Bounding rect of this element on the composite texture
      Iz3DBlendColor FTextureColor; 

      Iz3DBlendColor FFontColor; 

  protected:
      
LongWord GetTexture ();
 ;
      
TRect GetTextureRect ();
 ;
      
Iz3DBlendColor GetFontColor ();
 ;
      
Iz3DBlendColor GetTextureColor ();
 ;
       
SetFontColor (const Iz3DBlendColor Value 
);
 ;
       
SetTextureColor (const Iz3DBlendColor Value 
);
 ;
       
SetTextFormat (const DWORD Value 
);
 ;
      
LongWord GetFont ();
 ;
       
SetFont (const LongWord Value 
);
 ;
      
DWORD GetTextFormat ();
 ;
      
AssignTo (Iz3DBase Dest 
);
 ;
      
Assign (Iz3DBase Source 
);
 ;
  public:
         
Tz3DDisplay (const Iz3DBase AOwner = nil 
);
 ;
     
~Tz3DDisplay ();
 ;
            $
SetTexture (LongWord iTexture ,
PRect prcTexture ,
TD3DColor defaultTextureColor = FFFFFFFF 
);
 ;
          $           
SetFontParams (LongWord iFont ,
TD3DColor defaultFontColor = FF000000 ,
DWORD dwTextFormat = DT_CENTER ,
 or ,
 DT_VCENTER 
);
 ;
     
Refresh ();
 ;
  public:
         /** \sa GetTextFormat For reading   \sa SetTextFormat For writing */
DWORD TextFormat; 

         /** \sa GetFont For reading   \sa SetFont For writing */
LongWord Font; 

         /** \sa GetFontColor For reading   \sa SetFontColor For writing */
Iz3DBlendColor FontColor; 

         /** \sa GetTextureColor For reading   \sa SetTextureColor For writing */
Iz3DBlendColor TextureColor; 

       /** \sa GetTextureRect For reading*/
TRect TextureRect; 

       /** \sa GetTexture For reading*/
LongWord Texture; 

 };


  // Dialog class
    class Tz3DDialog : public Tz3DLinked,Iz3DDialog
{
public:

  private:
      Tz3DDialogModalResult FModalResult; 

      Boolean FModalMode; 

      TPoint FMousePoint; 

      TPoint FMousePointO; 

      Boolean FVisible; 

      Boolean FCaption; 

      Boolean FDrag; 

     WideChar FCaptionStr[255]; /*!< [0..255] */

      Integer FLeft; 

      Integer FTop; 

      Integer FWidth; 

      Integer FHeight; 

      TD3DColor m_colorTopLeft; 

      TD3DColor m_colorTopRight; 

      TD3DColor m_colorBottomLeft; 

      TD3DColor m_colorBottomRight; 

      Iz3DGUIController FManager; 

      PCallbackz3DGUIEvent FCallbackEvent; 

      Pointer FCallbackEventUserContext; 

      typedef array<Integer> m_Textures;
      typedef array<Integer> m_Fonts;   
      IInterfacelist m_Controls; 

      typedef array<Pz3DDisplayHolder> m_DefaultDisplays;
      Iz3DDisplay m_CapDisplay; 

      Iz3DDialog FNextDialog; 

      Iz3DDialog FPrevDialog; 

      Boolean FNonUserEvents; 

      Boolean FKeyboardInput; 

      Boolean FMouseInput; 

      Integer FDefaultControlID; 

      Double m_fTimeLastRefresh; 

      Iz3DControl FControlMouseOver; 

      Boolean FEnableBackground; 

      Boolean FEnableBorder; 

      Boolean FDesktopOnly; 

  protected:
      
PWideChar GetCaption ();
 ;
      
Integer GetLeft ();
 ;
      
Integer GetTop ();
 ;
       
SetLeft (const Integer Value 
);
 ;
       
SetTop (const Integer Value 
);
 ;
      
Boolean GetDesktopOnly ();
 ;
       
SetDesktopOnly (const Boolean Value 
);
 ;
      
Boolean GetEnableBorder ();
 ;
       
SetEnableBorder (const Boolean Value 
);
 ;
      
Boolean GetEnableBackground ();
 ;
       
SetEnableBackground (const Boolean Value 
);
 ;
      
Tz3DDialogModalResult GetModalResult ();
 ;
       
SetModalResult (const Tz3DDialogModalResult Value 
);
 ;
      
Boolean GetModalMode ();
 ;
       
Iz3DControl GetControlIndex (Integer AIndex 
);
 ;
      
Boolean GetVisible ();
 ;
       
SetVisible (const Boolean Value 
);
 ;
      
Integer GetControlCount ();
 ;
      
Boolean GetEnableCaption ();
 ;
      
Integer GetHeight ();
 ;
      
Boolean GetKeyboardInput ();
 ;
      
Iz3DGUIController GetManager ();
 ;
      
Integer GetWidth ();
 ;
       
SetEnableCaption (const Boolean Value 
);
 ;
       
SetHeight (const Integer Value 
);
 ;
       
SetWidth (const Integer Value 
);
 ;
    // Initialize default Displays
     
InitDefaultDisplays ();
 ;
    // Windows message handlers
      
OnMouseMove (TPoint pt 
);
 ;
    
      
OnMouseUp (TPoint pt 
);
 ;
    
      
SetNextDialog (Iz3DDialog pNextDialog 
);
 ;
      
Iz3DDialog GetNextDialog ();
 ;
      
SetPrevDialog (Iz3DDialog pNextDialog 
);
 ;
      
Iz3DDialog GetPrevDialog ();
 ;
       
Boolean OnCycleFocus (Boolean bForward 
);
 ;
     
Render ();
 ; ;
                        
Message (const HWND AWnd ,
const Cardinal AMsg ,
const Integer AwParam ,
const Integer AlParam ,
Boolean &AHandled 
);
 ;
  public:
         
Tz3DDialog (const Iz3DBase AOwner = nil 
);
 ;
     
~Tz3DDialog ();
 ;
    // Need to call this now
          
InitDialog (Iz3DGUIController pManager ,
Boolean bRegisterDialog = True 
);
 ; ;
           
InitDialog (Iz3DGUIController pManager ,
Boolean bRegisterDialog ,
const PWideChar pszControlTextureFilename 
);
 ; ;
      
InitDefaultDialog (Iz3DGUIController pManager 
);
 ;
            
InitDialog (Iz3DGUIController pManager ,
Boolean bRegisterDialog ,
PWideChar szControlTextureResourceName ,
HMODULE hControlTextureResourceModule 
);
 ; ;
    // Control creation
                      
HRESULT AddLabel (Integer ID ,
PWideChar strText ,
Integer x ,
Integer y ,
Integer width ,
Integer height ,
Boolean bIsDefault = False ,
PIz3DLabel ppCreated = nil 
);
 ;
                          
HRESULT AddButton (Integer ID ,
PWideChar strText ,
Integer x ,
Integer y ,
Integer width ,
Integer height ,
LongWord nHotkey = 0 ,
Boolean bIsDefault = False ,
PIz3DButton ppCreated = nil 
);
 ;
                              
HRESULT AddCheckBox (Integer ID ,
PWideChar strText ,
Integer x ,
Integer y ,
Integer width ,
Integer height ,
Boolean bChecked = False ,
LongWord nHotkey = 0 ,
Boolean bIsDefault = False ,
PIz3DCheckBox ppCreated = nil 
);
 ;
                                
HRESULT AddRadioButton (Integer ID ,
LongWord nButtonGroup ,
PWideChar strText ,
Integer x ,
Integer y ,
Integer width ,
Integer height ,
Boolean bChecked = False ,
LongWord nHotkey = 0 ,
Boolean bIsDefault = False ,
PIz3DRadioButton ppCreated = nil 
);
 ;
                        
HRESULT AddComboBox (Integer ID ,
Integer x ,
Integer y ,
Integer width ,
Integer height ,
LongWord nHotKey = 0 ,
Boolean bIsDefault = False ,
PIz3DComboBox ppCreated = nil 
);
 ;
                                
HRESULT AddTrackBar (Integer ID ,
Integer x ,
Integer y ,
Integer width ,
Integer height ,
Integer min = 0 ,
Integer max = 100 ,
Integer value = 50 ,
Boolean bIsDefault = False ,
PIz3DTrackBar ppCreated = nil 
);
 ;
                      
HRESULT AddEditBox (Integer ID ,
PWideChar strText ,
Integer x ,
Integer y ,
Integer width ,
Integer height ,
Boolean bIsDefault = False ,
PIz3DEdit ppCreated = nil 
);
 ;
                      
HRESULT AddIMEEditBox (Integer ID ,
PWideChar strText ,
Integer x ,
Integer y ,
Integer width ,
Integer height ,
Boolean bIsDefault = False ,
PIz3DIMEEditBox ppCreated = nil 
);
 ;
                    
HRESULT AddListBox (Integer ID ,
Integer x ,
Integer y ,
Integer width ,
Integer height ,
Tz3DListBoxStyle dwStyle = z3dlbsNormal ,
PIz3DListBox ppCreated = nil 
);
 ;
        
HRESULT AddControl (const Iz3DControl pControl 
);
 ;
        
HRESULT InitControl (const Iz3DControl pControl 
);
 ;
    // Control retrieval
       
Iz3DLabel GetLabel (Integer ID 
);
#ifdef  SUPPORTS_INLINE
 #endif
 ;
       
Iz3DButton GetButton (Integer ID 
);
#ifdef  SUPPORTS_INLINE
 #endif
 ;
       
Iz3DCheckBox GetCheckBox (Integer ID 
);
#ifdef  SUPPORTS_INLINE
 #endif
 ;
       
Iz3DRadioButton GetRadioButton (Integer ID 
);
#ifdef  SUPPORTS_INLINE
 #endif
 ;
       
Iz3DComboBox GetComboBox (Integer ID 
);
#ifdef  SUPPORTS_INLINE
 #endif
 ;
       
Iz3DTrackBar GetTrackBar (Integer ID 
);
#ifdef  SUPPORTS_INLINE
 #endif
 ;
       
Iz3DEdit GetEditBox (Integer ID 
);
#ifdef  SUPPORTS_INLINE
 #endif
 ;
       
Iz3DIMEEditBox GetIMEEditBox (Integer ID 
);
#ifdef  SUPPORTS_INLINE
 #endif
 ;
       
Iz3DListBox GetListBox (Integer ID 
);
#ifdef  SUPPORTS_INLINE
 #endif
 ;
       
Iz3DControl GetControl (Integer ID 
);
 ; ;
       
Iz3DControl GetControlProp (Integer ID 
);
#ifdef  SUPPORTS_INLINE
 #endif
 ;
         
Iz3DControl GetControl (Integer ID ,
Tz3DControlType nControlType 
);
 ; ;
       
Iz3DControl GetControlAtPoint (TPoint pt 
);
 ;
       
Boolean GetControlEnabled (Integer ID 
);
 ;
        
SetControlEnabled (Integer ID ,
Boolean bEnabled 
);
 ;
      
ClearRadioButtonGroup (LongWord nGroup 
);
 ;
      
ClearComboBox (Integer ID 
);
 ;
    // Access the default display Displays used when adding new controls
            
HRESULT SetDefaultDisplay (Tz3DControlType nControlType ,
LongWord iDisplay ,
const Iz3DDisplay pDisplay 
);
 ;
         
Iz3DDisplay GetDefaultDisplay (Tz3DControlType nControlType ,
LongWord iDisplay 
);
 ;
    // Methods called by controls
           
SendEvent (const Tz3DControlEvent AEvent ,
Boolean bTriggeredByUser ,
Iz3DControl pControl 
);
 ;
      
RequestFocus (Iz3DControl pControl 
);
 ;
    // Render helpers
          
HRESULT DrawRect (const TRect pRect ,
TD3DColor color 
);
 ;
           
HRESULT DrawPolyLine (PPoint apPoints ,
LongWord nNumPoints ,
TD3DColor color 
);
 ;
          
HRESULT DrawSprite (Iz3DDisplay pDisplay ,
const TRect prcDest 
);
 ;
              - 
HRESULT CalcTextRect (PWideChar strText ,
Iz3DDisplay pDisplay ,
PRect prcDest ,
Integer nCount = 1 
);
 ;
                   - 
HRESULT DrawText (PWideChar strText ,
Iz3DDisplay pDisplay ,
const TRect rcDest ,
Boolean bShadow = False ,
Integer nCount = 1 
);
 ;
    // Attributes
      
SetBackgroundColors (TD3DColor colorAllCorners 
);
 ; ;
         
SetBackgroundColors (TD3DColor colorTopLeft ,
TD3DColor colorTopRight ,
TD3DColor colorBottomLeft ,
TD3DColor colorBottomRight 
);
 ; ;
       
SetCaption (const PWideChar pwszText 
);
 ;
       
GetLocation (/* out */ TPoint &Pt 
);
 ;
       
SetLocation (Integer x ,
Integer y 
);
 ;
       
SetSize (Integer width ,
Integer height 
);
 ;
      
SetRefreshTime (Single fTime 
);
 /* s_fTimeRefresh = fTime; */  ;
       
Iz3DControl GetNextControl (Iz3DControl pControl 
);
 ;
       
Iz3DControl GetPrevControl (Iz3DControl pControl 
);
 ;
     
ClearFocus ();
 ;
      
RemoveControl (Integer ID 
);
 ;
     
RemoveAllControls ();
 ;
    // Sets the callback used to notify the app of control events
          
SetCallback (PCallbackz3DguiEvent pCallback ,
Pointer pUserContext = nil 
);
 ;
      
EnableNonUserEvents (Boolean bEnable 
);
 ;
      
EnableKeyboardInput (Boolean bEnable 
);
 ;
      
EnableMouseInput (Boolean bEnable 
);
 ;
    // Device state notification
     
Refresh ();
 ;
    // Shared resource access. Indexed fonts and textures are shared among
    // all the controls.
            
HRESULT SetFont (LongWord index ,
PWideChar strFaceName ,
Longint height ,
Longint weight 
);
 ;
       
Pz3DFontNode GetFont (LongWord index 
);
 ;
         
HRESULT SetTexture (LongWord index ,
PWideChar strFilename 
);
 ; ;
           
HRESULT SetTexture (LongWord index ,
PWideChar strResourceName ,
HMODULE hResourceModule 
);
 ; ;
       
Pz3DTextureNode GetTexture (LongWord index 
);
 ;
      
Boolean HasFocus ();
 ;
     
SetFocus ();
 ;
     
FocusDefaultControl ();
 ;
     
ShowModal ();
 ;
     
Show ();
 ;
     
Hide ();
 ;
  public:
         /** \sa GetModalResult For reading   \sa SetModalResult For writing */
Tz3DDialogModalResult ModalResult; 

       /** \sa GetModalMode For reading*/
Boolean ModalMode; 

         /** \sa GetCaption For reading   \sa SetCaption For writing */
PWideChar Caption; 

       /** \sa GetManager For reading*/
Iz3DGUIController Manager; 

    /*[ID: Integer]*/   /** \sa GetLabel For reading*/
Iz3DLabel Labels; 

    /*[ID: Integer]*/   /** \sa GetButton For reading*/
Iz3DButton Buttons; 

    /*[ID: Integer]*/   /** \sa GetCheckBox For reading*/
Iz3DCheckBox CheckBoxes; 

    /*[ID: Integer]*/   /** \sa GetRadioButton For reading*/
Iz3DRadioButton RadioButtons; 

    /*[ID: Integer]*/   /** \sa GetComboBox For reading*/
Iz3DComboBox ComboBoxes; 

    /*[ID: Integer]*/   /** \sa GetTrackBar For reading*/
Iz3DTrackBar TrackBars; 

    /*[ID: Integer]*/   /** \sa GetEditBox For reading*/
Iz3DEdit Edits; 

    /*[ID: Integer]*/   /** \sa GetIMEEditBox For reading*/
Iz3DIMEEditBox IMEEdits; 

    /*[ID: Integer]*/   /** \sa GetListBox For reading*/
Iz3DListBox ListBoxes; 

    /*[ID: Integer]*/   /** \sa GetControlProp For reading*/
Iz3DControl Controls; 

    /*[AIndex: Integer]*/   /** \sa GetControlIndex For reading*/
Iz3DControl ControlIndex; 

       /** \sa GetControlCount For reading*/
Integer ControlCount; 

       /** \sa GetKeyboardInput For reading*/
Boolean IsKeyboardInputEnabled; 

         /** \sa GetEnableCaption For reading   \sa SetEnableCaption For writing */
Boolean EnableCaption; 

         /** \sa GetEnableBackground For reading   \sa SetEnableBackground For writing */
Boolean EnableBackground; 

         /** \sa GetEnableBorder For reading   \sa SetEnableBorder For writing */
Boolean EnableBorder; 

         /** \sa GetDesktopOnly For reading   \sa SetDesktopOnly For writing */
Boolean DesktopOnly; 

         /** \sa GetLeft For reading   \sa SetLeft For writing */
Integer Left; 

         /** \sa GetTop For reading   \sa SetTop For writing */
Integer Top; 

         /** \sa GetWidth For reading   \sa SetWidth For writing */
Integer Width; 

         /** \sa GetHeight For reading   \sa SetHeight For writing */
Integer Height; 

         /** \sa GetVisible For reading   \sa SetVisible For writing */
Boolean Visible; 

 };


  // Message dialog type

    class Tz3DMessageDialog : public Tz3DDialog,Iz3DMessageDialog
{
public:

  private:
      Iz3DLabel FMessageLabel; 

      Iz3DButton FButton1; 

      Iz3DButton FButton2; 

      Iz3DButton FButton3; 

      Tz3DMessageDialogKind FKind; 

  protected:
      
Tz3DMessageDialogKind GetKind ();
 ;
       
SetKind (const Tz3DMessageDialogKind Value 
);
 ;
                   
Tz3DDialogModalResult ShowMessage (const Iz3DDesktop ADesktop ,
const PWideChar AMessage ,
const Tz3DMessageDialogKind AKind 
);
 ;
  public:
         
Tz3DMessageDialog (const Iz3DBase AOwner = nil 
);
 ;
                      
Tz3DDialogModalResult New (const Iz3DDesktop ADesktop ,
const PWideChar AMessage ,
const Tz3DMessageDialogKind AKind = z3dmdkInformation 
);

  public:
         /** \sa GetKind For reading   \sa SetKind For writing */
Tz3DMessageDialogKind Kind; 

 };


    class Tz3DMainMenuDialog : public Tz3DDialog,Iz3DMainMenuDialog
{
public:

  private:
      Iz3DButton FStartButton; 

      Iz3DButton FSettingsButton; 

      Iz3DButton FQuitButton; 

  protected:
       
z3DCreateScenarioObjects (const Tz3DCreateObjectCaller ACaller 
);
 ; ;
       
z3DDestroyScenarioObjects (const Tz3DDestroyObjectCaller ACaller 
);
 ; ;
       
z3DStartScenario (const Tz3DStartScenarioStage AStage 
);
 ; ;
     
z3DStopScenario ();
 ; ;
  public:
         
Iz3DMainMenuDialog New (const Iz3DDesktop ADesktop 
);

         
Tz3DMainMenuDialog (const Iz3DBase AOwner = nil 
);
 ;
     
Render ();
 ;
  public:
 };


    class Tz3DProgressDialog : public Tz3DDialog,Iz3DProgressDialog
{
public:

  private:
      Iz3DProgressBar FProgress; 

      Iz3DLabel FLabel; 

      Iz3DButton FCancelButton; 

  public:
         
Iz3DProgressDialog New (const Iz3DDesktop ADesktop 
);

         
Tz3DProgressDialog (const Iz3DBase AOwner = nil 
);
 ;
  public:
      
PWideChar GetStatus ();
 ;
       
SetStatus (const PWideChar AStatus 
);
 ;
       
SetProgress (const Integer APosition 
);
 ;
  public:
         /** \sa GetStatus For reading   \sa SetStatus For writing */
PWideChar Status; 

 };


    class Tz3DConsoleDialog : public Tz3DDialog,Iz3DConsoleDialog
{
public:

  private:
  protected:
  public:
  public:
 };


    typedef Tz3DControl* Tz3DControlClass;


    class Tz3DControl : public Tz3DBase,Iz3DControl
{
public:

  private:
       Integer FLeft; 
 Integer FTop; 

       Integer FWidth; 
 Integer FHeight; 

      Iz3DDialog FDialog; 

      LongWord m_Index; 

       Integer m_ID; 

      Tz3DControlType m_Type; 

      LongWord FHotkey; 

      Pointer FUserData; 

      Boolean FEnabled; 

      Boolean FVisible; 

      TRect FBoundingBox; 

      Boolean FMouseOver; 

      Boolean FHasFocus; 

      Boolean FIsDefault; 

      typedef array<Iz3DDisplay> m_Displays;
  protected:
      
Integer GetHeight ();
 ;
      
Integer GetLeft ();
 ;
      
Integer GetTop ();
 ;
      
Integer GetWidth ();
 ;
       
SetHeight (const Integer Value 
);
 ;
       
SetLeft (const Integer Value 
);
 ;
       
SetTop (const Integer Value 
);
 ;
       
SetWidth (const Integer Value 
);
 ;
       
SetDialog (const Iz3DDialog Value 
);
 ; ;
      
Iz3DDialog GetDialog ();
 ;
      
LongWord GetIndex ();
 ;
       
SetIndex (const LongWord Value 
);
 ;
      
Pointer GetUserData ();
 ;
       
SetUserData (const Pointer Value 
);
 ;
      
LongWord GetHotkey ();
 ;
      
Integer GetID ();
 ;
      
Boolean GetIsDefault ();
 ;
      
Tz3DControlType GetType ();
 ;
      
Boolean GetVisible ();
 ;
       
SetHotkey (const LongWord Value 
);
 ;
       
SetID (const Integer Value 
);
 ;
       
SetIsDefault (const Boolean Value 
);
 ;
     
UpdateRects ();
 ; ;
      
SetEnabled (Boolean bEnabled 
);
 ; ;
      
Boolean GetEnabled ();
 ; ;
      
SetVisible (Boolean bVisible 
);
 ; ;
      
SetTextColor (TD3DColor Color 
);
 ; ;
       
Iz3DDisplay GetDisplay (LongWord iDisplay 
);
 ;
         
SetDisplay (LongWord iDisplay ,
const Iz3DDisplay pDisplay 
);
 ;
  public:
         
Tz3DControl (const Iz3DDialog pDialog = nil 
);
 ;
     
~Tz3DControl ();
 ;
      
HRESULT OnInit ();
 ; ;
     
Refresh ();
 ; ;
     
Render ();
 ;  ;
    // Windows message handler
           
Boolean MsgProc (LongWord uMsg ,
WPARAM wParam ,
LPARAM lParam 
);
 ; ;
           
Boolean HandleKeyboard (LongWord uMsg ,
WPARAM wParam ,
LPARAM lParam 
);
 ; ;
             
Boolean HandleMouse (LongWord uMsg ,
TPoint pt ,
WPARAM wParam ,
LPARAM lParam 
);
 ; ;
      
Boolean CanHaveFocus ();
 ; ;
     
OnFocusIn ();
 ; ;
     
OnFocusOut ();
 ; ;
     
OnMouseEnter ();
 ; ;
     
OnMouseLeave ();
 ; ;
     
OnHotkey ();
 ;  ;
       
LongBool ContainsPoint (TPoint pt 
);
 ; ;
       
SetLocation (Integer x ,
Integer y 
);
 ;
       
SetSize (Integer width ,
Integer height 
);
 ;
  public:
    /*[i: LongWord]*/     /** \sa GetDisplay For reading   \sa SetDisplay For writing */
Iz3DDisplay Display; 

         /** \sa GetUserData For reading   \sa SetUserData For writing */
Pointer UserData; 

         /** \sa GetLeft For reading   \sa SetLeft For writing */
Integer Left; 

         /** \sa GetTop For reading   \sa SetTop For writing */
Integer Top; 

         /** \sa GetWidth For reading   \sa SetWidth For writing */
Integer Width; 

         /** \sa GetHeight For reading   \sa SetHeight For writing */
Integer Height; 

         /** \sa GetDialog For reading   \sa SetDialog For writing */
Iz3DDialog Dialog; 

       /** \sa GetType For reading*/
Tz3DControlType ControlType; 

         /** \sa GetID For reading   \sa SetID For writing */
Integer ID; 

         /** \sa GetIndex For reading   \sa SetIndex For writing */
LongWord Index; 

         /** \sa GetEnabled For reading   \sa SetEnabled For writing */
Boolean Enabled; 

         /** \sa GetVisible For reading   \sa SetVisible For writing */
Boolean Visible; 

         /** \sa GetIsDefault For reading   \sa SetIsDefault For writing */
Boolean Default; 

         /** \sa GetHotkey For reading   \sa SetHotkey For writing */
LongWord Hotkey; 

       /** \sa SetTextColor For writing*/
TD3DColor TextColor; 

 };


  // Static label control
    class Tz3DLabel : public Tz3DControl,Iz3DLabel
{
public:

  private:
     WideChar m_strText[-1]; /*!< [0..999..-1] */

  protected:
      
PWideChar GetText ();
 ;
      
SetText (PWideChar strText 
);
 ;
  public:
         
Tz3DLabel (const Iz3DDialog pDialog = nil 
);
 ;
     
Render ();
 ;
       
LongBool ContainsPoint (TPoint pt 
);
 ; ;
         
HRESULT GetTextCopy (PWideChar strDest ,
LongWord bufferCount 
);
 ;
  public:
         /** \sa GetText For reading   \sa SetText For writing */
PWideChar Text; 

 };


    class Tz3DButton : public Tz3DLabel,Iz3DButton
{
public:

  private:
      Boolean FPressed; 

      Boolean FEnableBackground; 

  protected:
      
Boolean GetEnableBackground ();
 ;
       
SetEnableBackground (const Boolean Value 
);
 ;
      
Boolean GetPressed ();
 ;
  public:
         
Tz3DButton (const Iz3DDialog pDialog = nil 
);
 ;
           
Boolean HandleKeyboard (LongWord uMsg ,
WPARAM wParam ,
LPARAM lParam 
);
 ; ;
             
Boolean HandleMouse (LongWord uMsg ,
TPoint pt ,
WPARAM wParam ,
LPARAM lParam 
);
 ; ;
     
OnHotkey ();
 ; ;
       
LongBool ContainsPoint (TPoint pt 
);
 ; ;
      
Boolean CanHaveFocus ();
 ; ;
     
Render ();
 ; ;
  public:
       /** \sa GetPressed For reading*/
Boolean Pressed; 

         /** \sa GetEnableBackground For reading   \sa SetEnableBackground For writing */
Boolean EnableBackground; 

 };


    class Tz3DCheckBox : public Tz3DButton,Iz3DCheckBox
{
public:

  private:
      Boolean FChecked; 

      TRect FButton; 

      TRect FText; 

  protected:
      
Boolean GetChecked ();
 ; ;
      
SetChecked (Boolean bChecked 
);
 ; ;
       
SetCheckedInternal (Boolean bChecked ,
Boolean bFromInput 
);
 ; ;
  public:
         
Tz3DCheckBox (const Iz3DDialog pDialog = nil 
);
 ;
           
Boolean HandleKeyboard (LongWord uMsg ,
WPARAM wParam ,
LPARAM lParam 
);
 ; ;
             
Boolean HandleMouse (LongWord uMsg ,
TPoint pt ,
WPARAM wParam ,
LPARAM lParam 
);
 ; ;
     
OnHotkey ();
 ; ;
       
LongBool ContainsPoint (TPoint pt 
);
 ; ;
     
UpdateRects ();
 ; ;
     
Render ();
 ; ;
  public:
         /** \sa GetChecked For reading   \sa SetChecked For writing */
Boolean Checked; 

 };


  // RadioButton control
    class Tz3DRadioButton : public Tz3DCheckBox,Iz3DRadioButton
{
public:

  private:
      LongWord FButtonGroup; 

  protected:
      
SetChecked (Boolean bChecked 
);
 ; ; ;
      
LongWord GetButtonGroup ();
 ;
       
SetButtonGroup (const LongWord Value 
);
 ;
        
SetCheckedInternal (Boolean bChecked ,
Boolean bClearGroup ,
Boolean bFromInput 
);
 ; ; ;
  public:
         
Tz3DRadioButton (const Iz3DDialog pDialog = nil 
);
 ;
           
Boolean HandleKeyboard (LongWord uMsg ,
WPARAM wParam ,
LPARAM lParam 
);
 ; ;
             
Boolean HandleMouse (LongWord uMsg ,
TPoint pt ,
WPARAM wParam ,
LPARAM lParam 
);
 ; ;
     
OnHotkey ();
 ; ;
          
SetChecked (Boolean bChecked ,
Boolean bClearGroup = True 
);
 ; ; ;
  public:
         /** \sa GetButtonGroup For reading   \sa SetButtonGroup For writing */
LongWord ButtonGroup; 

 };


  // ARROWSTATE indicates the state of the arrow buttons.
  // CLEAR            No arrow is down.
  // CLICKED_UP       Up arrow is clicked.
  // CLICKED_DOWN     Down arrow is clicked.
  // HELD_UP          Up arrow is held down for sustained period.
  // HELD_DOWN        Down arrow is held down for sustained period.
   enum Tz3DScrollBar_ArrayState
{
CLEAR, 
CLICKED_UP, 
CLICKED_DOWN, 
HELD_UP, 
HELD_DOWN 
};


    class Tz3DScrollBar : public Tz3DControl,Iz3DScrollBar
{
public:

  private:
      Boolean FShowThumb; 

      Boolean FDrag; 

      TRect FUpButton; 

      TRect FDownButton; 

      TRect FTrack; 

      TRect FThumb; 

      Integer FPosition; 

      Integer FPageSize; 

      Integer FStart; 

      Integer FEnd; 

      TPoint m_LastMouse; 

      Tz3DScrollBar_ArrayState m_Arrow; 

      Double m_dArrowTS; 

  protected:
      
Integer GetPageSize ();
 ;
      
Integer GetPosition ();
 ;
     
UpdateThumbRect ();
 ;
     
Cap ();
 ;
      
SetTrackPos (Integer nPosition 
);
 ;
      
SetPageSize (Integer nPageSize 
);
 ;
  public:
         
Tz3DScrollBar (const Iz3DDialog pDialog = nil 
);
 ;
           
Boolean HandleKeyboard (LongWord uMsg ,
WPARAM wParam ,
LPARAM lParam 
);
 ; ;
             
Boolean HandleMouse (LongWord uMsg ,
TPoint pt ,
WPARAM wParam ,
LPARAM lParam 
);
 ; ;
           
Boolean MsgProc (LongWord uMsg ,
WPARAM wParam ,
LPARAM lParam 
);
 ; ;
     
Render ();
 ; ;
     
UpdateRects ();
 ; ;
       
SetTrackRange (Integer nStart ,
Integer nEnd 
);
 ;
      
Scroll (Integer nDelta 
);
 ;
      
ShowItem (Integer nIndex 
);
 ;
  public:
         /** \sa GetPosition For reading   \sa SetTrackPos For writing */
Integer TrackPos; 

         /** \sa GetPageSize For reading   \sa SetPageSize For writing */
Integer PageSize; 

 };


  // ListBox control
    class Tz3DListBox : public Tz3DControl,Iz3DListBox
{
public:

  private:
      TRect FText; 

      TRect FSelection; 

      Iz3DScrollBar m_ScrollBar; 

      Integer FSBWidth; 

      Integer FBorder; 

      Integer FMargin; 

      Integer FTextHeight; 

      Tz3DListBoxStyle FStyle; 

      Integer FSelected; 

      Integer FSelStart; 

      Boolean FDrag; 

      TList m_Items; 

  protected:
      
Integer GetSBWidth ();
 ;
      
Integer GetSelected ();
 ;
      
Tz3DListBoxStyle GetStyle ();
 ;
      
Integer GetSize ();
 ;
      
SetStyle (Tz3DListBoxStyle dwStyle 
);
 ;
      
SetScrollBarWidth (Integer nWidth 
);
 ;
       
SetDialog (const Iz3DDialog Value 
);
 ; ;
  public:
         
Tz3DListBox (const Iz3DDialog pDialog = nil 
);
 ;
     
~Tz3DListBox ();
 ;
      
HRESULT OnInit ();
 ; ;
      
Boolean CanHaveFocus ();
 ; ;
           
Boolean HandleKeyboard (LongWord uMsg ,
WPARAM wParam ,
LPARAM lParam 
);
 ; ;
             
Boolean HandleMouse (LongWord uMsg ,
TPoint pt ,
WPARAM wParam ,
LPARAM lParam 
);
 ; ;
           
Boolean MsgProc (LongWord uMsg ,
WPARAM wParam ,
LPARAM lParam 
);
 ; ;
     
Render ();
 ; ;
     
UpdateRects ();
 ; ;
       
SetBorder (Integer nBorder ,
Integer nMargin 
);
 ;
          
HRESULT AddItem (const PWideChar wszText ,
Pointer pData 
);
 ;
            
HRESULT InsertItem (Integer nIndex ,
const PWideChar wszText ,
Pointer pData 
);
 ;
      
RemoveItem (Integer nIndex 
);
 ;
      
RemoveItemByText (PWideChar wszText 
);
 ;
      
RemoveItemByData (Pointer pData 
);
 ;
     
RemoveAllItems ();
 ;
       
Pz3DListBoxItem GetItem (Integer nIndex 
);
 ;
        - 
Integer GetSelectedIndex (Integer nPreviousSelected = 1 
);
 ;
        - 
Pz3DListBoxItem GetSelectedItem (Integer nPreviousSelected = 1 
);
 ;
      
SelectItem (Integer nNewIndex 
);
 ;
  public:
    /*[Index: Integer]*/   /** \sa GetItem For reading*/
Pz3DListBoxItem Items; 

         /** \sa GetSelected For reading   \sa SelectItem For writing */
Integer ItemIndex; 

         /** \sa GetSelected For reading   \sa SelectItem For writing */
Integer SelectedIndex; 

         /** \sa GetSBWidth For reading   \sa SetScrollBarWidth For writing */
Integer ScrollBarWidth; 

         /** \sa GetStyle For reading   \sa SetStyle For writing */
Tz3DListBoxStyle Style; 

       /** \sa GetSize For reading*/
Integer Size; 

 };


  // ComboBox control
    class Tz3DComboBox : public Tz3DButton,Iz3DComboBox
{
public:

  private:
      Integer m_iSelected; 

      Integer m_iFocused; 

      Integer FDropHeight; 

      Iz3DScrollBar m_ScrollBar; 

      Integer FSBWidth; 

      Boolean FOpened; 

      TRect FText; 

      TRect FButton; 

      TRect FDropdown; 

      TRect FDropdownText; 

      typedef array<Pz3DComboBoxItem> m_Items;
  protected:
      
SetTextColor (TD3DColor Color 
);
 ; ;
      
Integer GetSBWidth ();
 ;
      
LongWord GetNumItems ();
 ;
       
Pz3DComboBoxItem GetItem (LongWord index 
);
 ;
  public:
         
Tz3DComboBox (const Iz3DDialog pDialog = nil 
);
 ; 
     
~Tz3DComboBox ();
 ; 
      
HRESULT OnInit ();
 ; ;
           
Boolean HandleKeyboard (LongWord uMsg ,
WPARAM wParam ,
LPARAM lParam 
);
 ; ;
             
Boolean HandleMouse (LongWord uMsg ,
TPoint pt ,
WPARAM wParam ,
LPARAM lParam 
);
 ; ;
     
OnHotkey ();
 ; ;
      
Boolean CanHaveFocus ();
 ; ;
     
OnFocusOut ();
 ; ;
     
Render ();
 ; ;
     
UpdateRects ();
 ; ;
          
HRESULT AddItem (const PWideChar strText ,
Pointer pData 
);
 ;
     
RemoveAllItems ();
 ;
      
RemoveItem (LongWord index 
);
 ;
            
Boolean ContainsItem (const PWideChar strText ,
LongWord iStart = 0 
);
 ;
            
Integer FindItem (const PWideChar strText ,
LongWord iStart = 0 
);
 ;
        
Pointer GetItemData (const PWideChar strText 
);
 ; ;
       
Pointer GetItemData (Integer nIndex 
);
 ; ;
      
SetDropHeight (LongWord nHeight 
);
 ;
      
SetScrollBarWidth (Integer nWidth 
);
 ;
      
Pointer GetSelectedData ();
 ;
      
Pz3DComboBoxItem GetSelectedItem ();
 ;
       
HRESULT SetSelectedByIndex (LongWord index 
);
 ;
        
HRESULT SetSelectedByText (const PWideChar strText 
);
 ;
       
HRESULT SetSelectedByData (Pointer pData 
);
 ;
       
SetDialog (const Iz3DDialog Value 
);
 ; ;
  public:
    /*[index: LongWord]*/   /** \sa GetItem For reading*/
Pz3DComboBoxItem Item; 

       /** \sa GetNumItems For reading*/
LongWord NumItems; 

         /** \sa GetSBWidth For reading   \sa SetScrollBarWidth For writing */
Integer ScrollBarWidth; 

 };


    class Tz3DTrackBar : public Tz3DControl,Iz3DTrackBar
{
public:

  private:
      Integer FValue; 

      Integer FMin; 

      Integer FMax; 

      Integer FDragX; 

      Integer FDragOffset; 

      Integer FButtonX; 

      Boolean FPressed; 

      TRect FButton; 

  protected:
      
Integer GetValue ();
 ;
        
SetValueInternal (Integer nValue ,
Boolean bFromInput 
);
 ;
       
Integer ValueFromPos (Integer x 
);
 ;
      
SetValue (Integer nValue 
);
 ;
  public:
         
Tz3DTrackBar (const Iz3DDialog pDialog = nil 
);
 ;
       
LongBool ContainsPoint (TPoint pt 
);
 ; ;
      
Boolean CanHaveFocus ();
 ; ;
           
Boolean HandleKeyboard (LongWord uMsg ,
WPARAM wParam ,
LPARAM lParam 
);
 ; ;
             
Boolean HandleMouse (LongWord uMsg ,
TPoint pt ,
WPARAM wParam ,
LPARAM lParam 
);
 ; ;
     
UpdateRects ();
 ; ;
     
Render ();
 ; ;
        
GetRange (/* out */ Integer &nMin ,
/* out */ Integer &nMax 
);
 ;
       
SetRange (Integer nMin ,
Integer nMax 
);
 ;
  public:
         /** \sa GetValue For reading   \sa SetValue For writing */
Integer Value; 

 };


    class Tz3DProgressBar : public Tz3DControl,Iz3DProgressBar
{
public:

  private:
      Integer FValue; 

      Integer FMin; 

      Integer FMax; 

      TRect FProgress; 

  protected:
      
Integer GetValue ();
 ;
        
SetValueInternal (Integer nValue ,
Boolean bFromInput 
);
 ;
       
Integer ValueFromPos (Integer x 
);
 ;
      
SetValue (Integer nValue 
);
 ;
  public:
         
Tz3DProgressBar (const Iz3DDialog pDialog = nil 
);
 ;
       
LongBool ContainsPoint (TPoint pt 
);
 ; ;
      
Boolean CanHaveFocus ();
 ; ;
           
Boolean HandleKeyboard (LongWord uMsg ,
WPARAM wParam ,
LPARAM lParam 
);
 ; ;
             
Boolean HandleMouse (LongWord uMsg ,
TPoint pt ,
WPARAM wParam ,
LPARAM lParam 
);
 ; ;
     
UpdateRects ();
 ; ;
     
Render ();
 ; ;
        
GetRange (/* out */ Integer &nMin ,
/* out */ Integer &nMax 
);
 ;
       
SetRange (Integer nMin ,
Integer nMax 
);
 ;
  public:
         /** \sa GetValue For reading   \sa SetValue For writing */
Integer Value; 

 };


    class Tz3DUniBuffer : public Tz3DBase,Iz3DUniBuffer
{
public:

  private:
       PWideChar FwszBuffer; 

      Integer FBufferSize; 

      Pz3DFontNode FFontNode; 

      Boolean FAnalyseRequired; 

      TScriptStringAnalysis m_Analysis; 

  public:
      
Integer GetBufferSize ();
 ;
      
Pz3DFontNode GetFontNode ();
 ;
      
PWideChar GetwszBuffer ();
 ;
       
SetFontNode (const Pz3DFontNode Value 
);
 ;
      
HRESULT Analyse ();
 ;
        
Tz3DUniBuffer (Integer nInitialSize = 1 
);
 
     
~Tz3DUniBuffer ();
 ; 
      
Initialize ();

      
Uninitialize ();

       
Boolean SetBufferSize (Integer nNewSize 
);
 ;
      
Integer GetTextSize ();
 ;
       
WideChar GetChar (Integer i 
);
 ;
        
SetChar (Integer i ,
WideChar ch 
);
 ;
     
Clear ();
 ;
         
Boolean InsertChar (Integer nIndex ,
WideChar wChar 
);
 ;
       
Boolean RemoveChar (Integer nIndex 
);
 ;
             - 
Boolean InsertString (Integer nIndex ,
const PWideChar pStr ,
Integer nCount = 1 
);
 ;
      
SetText (PWideChar wszText 
);
 ;
            
HRESULT CPtoX (Integer nCP ,
BOOL bTrail ,
/* out */ Integer &pX 
);
 ;
             
HRESULT XtoCP (Integer nX ,
/* out */ Integer &pCP ,
/* out */ LongBool &pnTrail 
);
 ;
         
GetPriorItemPos (Integer nCP ,
/* out */ Integer &pPrior 
);
 ;
         
GetNextItemPos (Integer nCP ,
/* out */ Integer &pPrior 
);
 ;
  public:
       /** \sa GetBufferSize For reading*/
Integer BufferSize; 

       /** \sa GetwszBuffer For reading*/
PWideChar Buffer; 

    /*[i: Integer]*/     /** \sa GetChar For reading   \sa SetChar For writing */
WideChar Chars; 
 
         /** \sa GetFontNode For reading   \sa SetFontNode For writing */
Pz3DFontNode FontNode; 

       /** \sa GetTextSize For reading*/
Integer TextSize; 

 };


    class Tz3DEdit : public Tz3DControl,Iz3DEdit
{
public:

  private:
      Tz3DUniBuffer m_Buffer; 

      Integer FBorder; 

      Integer FSpacing; 

      TRect FText; 

     TRect FRender[8]; /*!< [0..8] */

     Double m_dfBlink; 

      Double m_dfLastBlink; 

      Boolean FCaretOn; 

      Integer FCaret; 

      Boolean FInsertMode; 

      Integer FSelStart; 

      Integer FFirstVisible; 

      TD3DColor m_TextColor; 

      TD3DColor m_SelTextColor; 

      TD3DColor m_SelBkColor; 

      TD3DColor m_CaretColor; 

      Boolean FMouseDrag; 

  protected:
       
SetCaretColor (const TD3DColor Value 
);
 ;
      
Integer GetBorder ();
 ;
      
TD3DColor GetCaretColor ();
 ;
      
TD3DColor GetSelBkColor ();
 ;
      
TD3DColor GetSelTextColor ();
 ;
      
Integer GetSpacing ();
 ;
      
TD3DColor GetTextColor ();
 ;
       
SetSelBkColor (const TD3DColor Value 
);
 ;
       
SetSelTextColor (const TD3DColor Value 
);
 ;
      
PlaceCaret (Integer nCP 
);
 ;
     
DeleteSelectionText ();
 ;
     
ResetCaretBlink ();
 ;
     
CopyToClipboard ();
 ;
     
PasteFromClipboard ();
 ;
      
SetTextColor (TD3DColor Color 
);
 ; ;
      
PWideChar GetText ();
 ;
      
SetText_p (PWideChar wszText 
);
#ifdef  SUPPORTS_INLINE
 #endif
 ;
      
Integer GetTextLength ();
 ;
      
SetBorderWidth (Integer nBorder 
);
 ;
      
SetSpacing (Integer nSpacing 
);
 ;
  public:
         
Tz3DEdit (const Iz3DDialog pDialog = nil 
);
 ;
     
~Tz3DEdit ();
 ;
           
Boolean HandleKeyboard (LongWord uMsg ,
WPARAM wParam ,
LPARAM lParam 
);
 ; ;
             
Boolean HandleMouse (LongWord uMsg ,
TPoint pt ,
WPARAM wParam ,
LPARAM lParam 
);
 ; ;
           
Boolean MsgProc (LongWord uMsg ,
WPARAM wParam ,
LPARAM lParam 
);
 ; ;
     
UpdateRects ();
 ; ;
      
Boolean CanHaveFocus ();
 ; ;
     
Render ();
 ; ;
     
OnFocusIn ();
 ; ;
          
SetText (PWideChar wszText ,
Boolean bSelected = False 
);
 ;
         
HRESULT GetTextCopy (PWideChar strDest ,
LongWord bufferCount 
);
 ;
     
ClearText ();
 ;
        
ParseFloatArray (PSingle pNumbers ,
Integer nCount 
);
 ;
        
SetTextFloatArray (PSingle pNumbers ,
Integer nCount 
);
 ;
  public:
         /** \sa GetText For reading   \sa SetText_p For writing */
PWideChar Text; 

         /** \sa GetTextColor For reading   \sa SetTextColor For writing */
TD3DColor TextColor; 

       /** \sa GetTextLength For reading*/
Integer TextLength; 

         /** \sa GetSelTextColor For reading   \sa SetSelTextColor For writing */
TD3DColor SelectedTextColor; 

         /** \sa GetSelBkColor For reading   \sa SetSelBkColor For writing */
TD3DColor SelectedBackColor; 

         /** \sa GetCaretColor For reading   \sa SetCaretColor For writing */
TD3DColor CaretColor; 

         /** \sa GetBorder For reading   \sa SetBorderWidth For writing */
Integer BorderWidth; 

         /** \sa GetSpacing For reading   \sa SetSpacing For writing */
Integer Spacing; 

 };



  //-----------------------------------------------------------------------------
  // IME-enabled EditBox control
  //-----------------------------------------------------------------------------
    class Tz3DIMEEditBox : public Tz3DEdit,Iz3DIMEEditBox
{
public:

  private:
             TD3DColor m_ReadingColor; 

          TD3DColor m_ReadingWinColor; 

          TD3DColor m_ReadingSelColor; 

        TD3DColor m_ReadingSelBkColor; 

           TD3DColor m_CandidateColor; 

        TD3DColor m_CandidateWinColor; 

        TD3DColor m_CandidateSelColor; 

      TD3DColor m_CandidateSelBkColor; 

                TD3DColor m_CompColor; 

             TD3DColor m_CompWinColor; 

           TD3DColor m_CompCaretColor; 

          TD3DColor m_CompTargetColor; 

        TD3DColor m_CompTargetBkColor; 

       TD3DColor m_CompTargetNonColor; 

     TD3DColor m_CompTargetNonBkColor; 

        TD3DColor m_IndicatorImeColor; 

        TD3DColor m_IndicatorEngColor; 

         TD3DColor m_IndicatorBkColor; 

            Integer FIndicatorWidth; 

                 TRect FIndicator; 

  protected:
       
Word GetLanguage ();

       
Word GetPrimaryLanguage ();

       
Word GetSubLanguage ();

       
SendKey (Byte nVirtKey 
);

          
DWORD GetImeId (LongWord uIndex = 0 
);

      
CheckInputLocale ();

      
CheckToggleState ();

      
SetupImeApi ();

      
ResetCompositionString ();

            
TruncateCompString (Boolean bUseBackSpace = True ,
Integer iNewStrLen = 0 
);
 ;
      
FinalizeString (Boolean bSend 
);
 ;
       
GetReadingWindowOrientation (DWORD dwId 
);

      
GetPrivateReadingString ();

     
SendCompString ();
 ;
  public:
         
Tz3DIMEEditBox (const Iz3DDialog pDialog = nil 
);
 ;
     
~Tz3DIMEEditBox ();
 ;
      
Initialize ();

      
Uninitialize ();

       
HRESULT StaticOnCreateDevice ();

            
BOOL StaticMsgProc (LongWord uMsg ,
WPARAM wParam ,
LPARAM lParam 
);

       
EnableImeSystem (Boolean bEnable 
);

     
Render ();
 ; ;
           
Boolean MsgProc (LongWord uMsg ,
WPARAM wParam ,
LPARAM lParam 
);
 ; ;
             
Boolean HandleMouse (LongWord uMsg ,
TPoint pt ,
WPARAM wParam ,
LPARAM lParam 
);
 ; ;
     
UpdateRects ();
 ; ;
     
OnFocusIn ();
 ; ;
     
OnFocusOut ();
 ; ;
     
PumpMessage ();
 ;
      
RenderCandidateReadingWindow (Boolean bReading 
);
 ; ;
     
RenderComposition ();
 ; ;
     
RenderIndicator ();
 ; ;
 };



   const  MAX_CONTROL_STATES =  Ord(High(Tz3DControlState))+1;


     const  WM_XBUTTONDOWN =  $020B; // (not always defined)
       const  WM_XBUTTONUP =  $020C; // (not always defined)
   const  WM_XBUTTONDBLCLK =  $020D;
      const  WM_MOUSEWHEEL =  $020A; // (not always defined)
        const  WHEEL_DELTA =  120;   // (not always defined)

           const  MK_XBUTTON1 =  $0020;
           const  MK_XBUTTON2 =  $0040;

    
Cardinal GetAPIFormat (const Tz3DFontFormats AFormats 
);
 ; 

  
Iz3DDesktop z3DCreateDesktop ();
 ;
  
Iz3DDesktop z3DDesktop ();
 ;
   
z3DSetCustomDesktop (const Iz3DDesktop ADesktop 
);
 ;

           
Iz3DTextHelper z3DCreateTextHelper (const ID3DXFont AFont ,
const ID3DXSprite ASprite ,
const Integer ALineHeight 
);
 ;




     
      
  

/*
//const

  UnitName = 'z3DGUI.pas';

const
  // Minimum scroll bar thumb size
  SCROLLBAR_MINTHUMBSIZE = 8;

  // Delay and repeat period when clicking on the scroll bar arrows
  SCROLLBAR_ARROWCLICK_DELAY  = 0.33;
  SCROLLBAR_ARROWCLICK_REPEAT = 0.05;

  UNISCRIBE_DLLNAME = '\usp10.dll';


  // z3D_MAX_EDITBOXLENGTH is the maximum string length allowed in edit boxes,
  // including the NULL terminator.
  //
  // Uniscribe does not support strings having bigger-than-16-bits length.
  // This means that the string must be less than 65536 characters long,
  // including the NULL terminator.
  z3D_MAX_EDITBOXLENGTH = $FFFF;


var
  s_fTimeRefresh: Double = 0.0;            // static Tz3DDialog::s_fTimeRefresh
  s_pControlFocus: Iz3DControl     = nil; // static Tz3DDialog::s_pControlFocus // The control which has focus
  s_pControlPressed: Iz3DControl   = nil; // static Tz3DDialog::s_pControlPressed // The control currently pressed

  GDesktop: Iz3DDesktop;

type
  Tz3DScreenVertex = record
    x, y, z, h: Single;
    color: TD3DColor;
    tu, tv: Single;
  end;
const
  Tz3DScreenVertex_FVF = D3DFVF_XYZRHW or D3DFVF_DIFFUSE or D3DFVF_TEX1;


*/
  
Iz3DDesktop z3DCreateDesktop ()
 ;{
#ifndef DOXYGEN_SKIP
  GDesktop:= Tz3DDesktop.Create;
  Result:= GDesktop;
#endif /* DOXYGEN_SKIP */
};

  
Iz3DDesktop z3DDesktop ()
 ;{
#ifndef DOXYGEN_SKIP
  Result:= GDesktop;
#endif /* DOXYGEN_SKIP */
};

   
z3DSetCustomDesktop (const Iz3DDesktop ADesktop 
)
 ;{
#ifndef DOXYGEN_SKIP
  GDesktop:= ADesktop;
#endif /* DOXYGEN_SKIP */
};

           
Iz3DTextHelper z3DCreateTextHelper (const ID3DXFont AFont ,
const ID3DXSprite ASprite ,
const Integer ALineHeight 
)
 ;{
#ifndef DOXYGEN_SKIP
  Result:= Tz3DTextHelper.Create(AFont, ASprite, ALineHeight);
#endif /* DOXYGEN_SKIP */
};

           
Tz3DScreenVertex z3DScreenVertex (Single x ,
Single y ,
Single z ,
Single h ,
TD3DColor color ,
Single tu ,
Single tv 
)
{
#ifndef DOXYGEN_SKIP
  Result.x:= x; Result.y:= y; Result.z:= z; Result.h:= h;
  Result.color:= color;
  Result.tu:= tu; Result.tv:= tv;
#endif /* DOXYGEN_SKIP */
};
#ifdef INCLUDE_TYPE_SECTION

   struct Tz3DScreenVertexUntex
{

         Single x; 
 Single y; 
 Single z; 
 Single h; 

      TD3DColor color; 

 };


   const  Tz3DScreenVertexUntex_FVF =  D3DFVF_XYZRHW or D3DFVF_DIFFUSE;

        
Tz3DScreenVertexUntex z3DScreenVertexUntex (Single x ,
Single y ,
Single z ,
Single h ,
TD3DColor color 
)
{
#ifndef DOXYGEN_SKIP
  Result.x:= x; Result.y:= y; Result.z:= z; Result.h:= h;
  Result.color:= color;
#endif /* DOXYGEN_SKIP */
};

    
Cardinal GetAPIFormat (const Tz3DFontFormats AFormats 
)
{
#ifndef DOXYGEN_SKIP
  Result:= 0;
  if z3dffBottom in AFormats then Result:= Result or DT_BOTTOM;
  if z3dffCenter in AFormats then Result:= Result or DT_CENTER;
  if z3dffEndEllipsis in AFormats then Result:= Result or DT_END_ELLIPSIS;
  if z3dffPathEllipsis in AFormats then Result:= Result or DT_PATH_ELLIPSIS;
  if z3dffExpandTabs in AFormats then Result:= Result or DT_EXPANDTABS;
  if z3dffLeading in AFormats then Result:= Result or DT_EXTERNALLEADING;
  if z3dffLeft in AFormats then Result:= Result or DT_LEFT;
  if z3dffModifyString in AFormats then Result:= Result or DT_MODIFYSTRING;
  if z3dffNoClip in AFormats then Result:= Result or DT_NOCLIP;
  if z3dffNoPrefix in AFormats then Result:= Result or DT_NOPREFIX;
  if z3dffRight in AFormats then Result:= Result or DT_RIGHT;
  if z3dffRTLReading in AFormats then Result:= Result or DT_RTLREADING;
  if z3dffSingleLine in AFormats then Result:= Result or DT_SINGLELINE;
  if z3dffTabStop in AFormats then Result:= Result or DT_TABSTOP;
  if z3dffTop in AFormats then Result:= Result or DT_TOP;
  if z3dffVerticalCenter in AFormats then Result:= Result or DT_VCENTER;
  if z3dffWordBreak in AFormats then Result:= Result or DT_WORDBREAK;
#endif /* DOXYGEN_SKIP */
};

    
Integer RectWidth (const TRect prc 
)
 #ifdef  SUPPORTS_INLINE
inline;#endif
{
#ifndef DOXYGEN_SKIP
Result:= prc.right - prc.left;
#endif /* DOXYGEN_SKIP */
};
    
Integer RectHeight (const TRect prc 
)
#ifdef  SUPPORTS_INLINE
inline;#endif
{
#ifndef DOXYGEN_SKIP
Result:= prc.bottom - prc.top;
#endif /* DOXYGEN_SKIP */
};

      $    
Tz3DBlendColor::SetColors (TD3DColor defaultColor ,
TD3DColor disabledColor = C8808080 ,
TD3DColor hiddenColor = 0 
)

/*
var

  i: Tz3DControlState;
*/
{
#ifndef DOXYGEN_SKIP

  for i:= Low(Tz3DControlState) to High(Tz3DControlState) do States[i]:= defaultColor;
  States[z3dcsDisabled] := disabledColor;
  States[z3dcsHidden] := hiddenColor;
  Current:= D3DXColorFromDWord(hiddenColor);
#endif /* DOXYGEN_SKIP */
};

      .7
Tz3DBlendColor::Blend (Tz3DControlState iState ,
Single fRate = 0 
)

/*
var

  destColor: TD3DXColor;
*/
{
#ifndef DOXYGEN_SKIP

  destColor:= D3DXColorFromDWord(States[iState]);
  if fRate = -1 then FCurrent:= destColor else
  D3DXColorLerp(FCurrent, FCurrent, destColor, 1.0 - Power(fRate, 30 * z3DCore_GetElapsedTime));
#endif /* DOXYGEN_SKIP */
};

#ifdef  DEBUG

/*
var

  Tz3DTextHelper_InstanceCount: Integer = 0;

#endif

constructor Tz3DTextHelper.Create(pFont: ID3DXFont; pSprite: ID3DXSprite; nLineHeight: Integer);
begin
  FFont := pFont;
  FSprite := pSprite;
  FClr := D3DXColor(1,1,1,1);
  FPt.x := 0;
  FPt.y := 0;
  FLineHeight := nLineHeight;
end;

destructor Tz3DTextHelper.Destroy;
begin
  inherited;
end;

procedure Tz3DTextHelper.SetInsertionPos(x, y: Integer);
begin
  FPt.x := x;
  FPt.y := y;
end;

procedure Tz3DTextHelper.SetForegroundColor(clr: TD3DXColor);
begin
  FClr := clr;
end;

function Tz3DTextHelper.DrawFormattedTextLine(const strMsg: PWideChar; args: array of const): HRESULT;
var
  strBuffer: array[0..511] of WideChar;
begin
  // WideFormatBuf(strBuffer, 512, strMsg, Length(strMsg), args);
  StringCchFormat(strBuffer, 512, strMsg, args);
  strBuffer[511] := #0;
  Result:= DrawTextLine(strBuffer);
end;

{$IFNDEF FPC}

function Tz3DTextHelper.DrawFormattedTextLine(const strMsg: WideString; args: array of const): HRESULT;
begin
  Result := DrawFormattedTextLine(PWideChar(strMsg), args);
end;

{$ENDIF}

function Tz3DTextHelper.DrawTextLine(const strMsg: PWideChar): HRESULT;
var
  rc: TRect;
begin
  if (nil = FFont) then
  begin
    Result:= z3DError('DrawTextLine', E_INVALIDARG);
    Exit;
  end;
  SetRect(rc, FPt.x, FPt.y, 0, 0 );
  Result := FFont.DrawTextW(FSprite, strMsg, -1, @rc, DT_NOCLIP, D3DXColorToDWord(FClr));
  if FAILED(Result) then
  begin
    Result:= DXTRACE_ERR_MSGBOX('DrawText', Result);
    Exit;
  end;
  Inc(FPt.y, FLineHeight);
  Result:= S_OK;
end;

{$IFNDEF FPC}

function Tz3DTextHelper.DrawTextLine(const strMsg: PAnsiChar): HRESULT;
var
  rc: TRect;
begin
  if (nil = FFont) then
  begin
    Result:= z3DError('DrawTextLine', E_INVALIDARG);
    Exit;
  end;

  SetRect(rc, FPt.x, Fpt.y, 0, 0 );
  Result := FFont.DrawTextA(FSprite, strMsg, -1, @rc, DT_NOCLIP, D3DXColorToDWord(FClr));
  if FAILED(Result) then
  begin
    Result:= DXTRACE_ERR_MSGBOX('DrawText', Result);
    Exit;
  end;
  Inc(FPt.y, FLineHeight);
  Result:= S_OK;
end;
{$ENDIF}

#ifdef  BORLAND
#ifndef  COMPILER6_UP

function Tz3DTextHelper.DrawTextLine(const strMsg: String): HRESULT;
begin
  Result:= DrawTextLine(PAnsiChar(strMsg));
end;

{$ENDIF}#endif


function Tz3DTextHelper.DrawFormattedTextLine(const rc: TRect; dwFlags: DWORD; const strMsg: PWideChar; args: array of const): HRESULT;
var
  strBuffer: array[0..511] of WideChar;
begin
  StringCchFormat(strBuffer, 512, strMsg, args);
  Result:= DrawTextLine(rc, dwFlags, strBuffer);
end;


function Tz3DTextHelper.DrawTextLine(const rc: TRect; dwFlags: DWORD; const strMsg: PWideChar): HRESULT;
begin
  if (nil = FFont) then
  begin
    Result:= z3DError('DrawTextLine', E_INVALIDARG);
    Exit;
  end;
  Result := FFont.DrawTextW(FSprite, strMsg, -1, @rc, dwFlags, D3DXColorToDWord(FClr));
  if FAILED(Result) then
  begin
    Result:= DXTRACE_ERR_MSGBOX('DrawText', Result);
    Exit;
  end;
  Inc(FPt.y, FLineHeight);
  Result:= S_OK;
end;

procedure Tz3DTextHelper.BeginRender;
begin
  if (FSprite <> nil) then FSprite._Begin(D3DXSPRITE_ALPHABLEND or D3DXSPRITE_SORT_TEXTURE);
end;

procedure Tz3DTextHelper.EndRender;
begin
  if (FSprite <> nil) then FSprite._End;
end;

{ Tz3DBlendColor }

function Tz3DBlendColor.GetCurrent: TD3DXColor;
begin
  Result:= FCurrent;
end;

function Tz3DBlendColor.GetStates: Pz3DBlendColorStates;
begin
  Result:= @FStates;
end;

procedure Tz3DBlendColor.SetStates(const Value: Pz3DBlendColorStates);
begin
  FStates:= Value^;
end;

procedure Tz3DBlendColor.SetCurrent(const Value: TD3DXColor);
begin
  FCurrent:= Value;
end;

{ Tz3DDisplay }

constructor Tz3DDisplay.Create;
begin
  FTextureColor:= Tz3DBlendColor.Create;
  FFontColor:= Tz3DBlendColor.Create;
end;

destructor Tz3DDisplay.Destroy;
begin
  inherited;
end;

function Tz3DDisplay.GetTextFormat: DWORD;
begin
  Result:= dwTextFormat;
end;

procedure Tz3DDisplay.SetTextFormat(const Value: DWORD);
begin
  dwTextFormat:= Value;
end;

function Tz3DDisplay.GetFont: LongWord;
begin
  Result:= iFont;
end;

procedure Tz3DDisplay.SetFont(const Value: LongWord);
begin
  iFont:= value;
end;

function Tz3DDisplay.GetFontColor: Iz3DBlendColor;
begin
  Result:= FFontColor;
end;

function Tz3DDisplay.GetTextureColor: Iz3DBlendColor;
begin
  Result:= FTextureColor;
end;

procedure Tz3DDisplay.SetFontColor(const Value: Iz3DBlendColor);
begin
  FFontColor:= Value;
end;

procedure Tz3DDisplay.SetTextureColor(const Value: Iz3DBlendColor);
begin
  FTextureColor:= Value;
end;

function Tz3DDisplay.GetTextureRect: TRect;
begin
  Result:= rcTexture;
end;

function Tz3DDisplay.GetTexture: LongWord;
begin
  Result:= iTexture;
end;

procedure Tz3DDisplay.AssignTo(Dest: Iz3DBase);
begin
  if z3DSupports(Dest, Iz3DDisplay) then
  begin
    with Dest as Iz3DDisplay do
    begin
      iTexture:= Self.iTexture;
      iFont:= Self.iFont;
      dwTextFormat:= Self.dwTextFormat;
      rcTexture:= Self.rcTexture;
      TextureColor.Current:= Self.TextureColor.Current;
      TextureColor.States:= Self.TextureColor.States;
      FontColor.Current:= Self.FontColor.Current;
      FontColor.States:= Self.FontColor.States;
    end;
  end;
end;

procedure Tz3DDisplay.Assign(Source: Iz3DBase);
begin
  if z3DSupports(Source, Iz3DDisplay) then
  begin
    with Source as Iz3DDisplay do
    begin
      Self.iTexture:= Texture;
      Self.iFont:= Font;
      Self.dwTextFormat:= TextFormat;
      Self.rcTexture:= TextureRect;
      Self.TextureColor.Current:= TextureColor.Current;
      Self.TextureColor.States:= TextureColor.States;
      Self.FontColor.Current:= FontColor.Current;
      Self.FontColor.States:= FontColor.States;
    end;
  end;
end;

procedure Tz3DDisplay.SetTexture(iTexture: LongWord; prcTexture: PRect; defaultTextureColor: TD3DColor = $FFFFFFFF);
begin
  Self.iTexture := iTexture;
  if (prcTexture <> nil)
  then rcTexture := prcTexture^
  else SetRectEmpty(rcTexture);
  TextureColor.SetColors(defaultTextureColor);
end;

procedure Tz3DDisplay.SetFontParams(iFont: LongWord; defaultFontColor: TD3DColor = $FF000000; dwTextFormat: DWORD = DT_CENTER or DT_VCENTER);
begin
  Self.iFont := iFont;
  Self.dwTextFormat := dwTextFormat;
  FontColor.SetColors(defaultFontColor);
end;

procedure Tz3DDisplay.Refresh;
begin
  TextureColor.Current := D3DXColorFromDWord(TextureColor.States[z3dcsHidden]);
  FontColor.Current := D3DXColorFromDWord(FontColor.States[z3dcsHidden]);
end;

{ Tz3DDialog }

constructor Tz3DDialog.Create;
begin
  inherited;
  ScenarioLevel:= False;
  FDesktopOnly:= True;
  FEnableBorder:= True;
  FEnableBackground:= True;
  FModalResult:= z3dmdkNone;
  m_Controls:= TInterfaceList.Create;
  FLeft := 100;
  FTop := 100;
  FWidth := 100;
  FHeight := 100;
  FVisible := True;
  FCaption := True;
  FDrag := False;
  FCaptionStr[0] := #0;
  m_colorTopLeft := 0;
  m_colorTopRight := 0;
  m_colorBottomLeft := 0;
  m_colorBottomRight := 0;
  m_fTimeLastRefresh := 0;
  FNextDialog := Self;
  FPrevDialog := Self;
  FDefaultControlID := $ffff;
  FNonUserEvents := False;
  FKeyboardInput := False;
  FMouseInput := True;
  m_CapDisplay:= Tz3DDisplay.Create;
end;

destructor Tz3DDialog.Destroy;
begin
  RemoveAllControls;
  FreeAndNil(m_CapDisplay);
  inherited;
end;

{$IFDEF FPC}
type
  MakeIntResourceW = PWideChar;
#endif



function Tz3DDialog.GetModalResult: Tz3DDialogModalResult;
begin
  Result:= FModalResult;
end;

procedure Tz3DDialog.SetModalResult(const Value: Tz3DDialogModalResult);
begin
  FModalResult:= Value;
end;

procedure Tz3DDialog.InitDialog(pManager: Iz3DGUIController; bRegisterDialog: Boolean = True);
begin
  FManager := pManager;
  if bRegisterDialog then pManager.RegisterDialog(Self);
  SetTexture(0, MakeIntResourceW($FFFF), HMODULE($FFFF));
  InitDefaultDisplays;
end;

procedure Tz3DDialog.InitDialog(pManager: Iz3DGUIController; bRegisterDialog: Boolean; const pszControlTextureFilename: PWideChar);
begin
  FManager := pManager;
  if bRegisterDialog then pManager.RegisterDialog(Self);
  SetTexture(0, pszControlTextureFilename);
  InitDefaultDisplays;
end;

procedure Tz3DDialog.InitDefaultDialog(pManager: Iz3DGUIController);
var strFileName: PWideChar;
begin
  FManager := pManager;
  pManager.RegisterDialog(Self);
  z3DFileSystemController.DecryptF(fsEngineCoreResFile, fsCoreResFile_z3DGUI);
  GetMem(strFileName, 255);
  try
    StringToWideChar(WideCharToString(z3DFileSystemController.GetFullPath(fsBufferPath)) + fsPathDiv + fsCoreResFile_z3DGUI, strFileName, 255);
    SetTexture(0, strFileName);
  finally
    FreeMem(strFileName);
  end;
  InitDefaultDisplays;
end;

procedure Tz3DDialog.InitDialog(pManager: Iz3DGUIController; bRegisterDialog: Boolean; szControlTextureResourceName: PWideChar; hControlTextureResourceModule: HMODULE);
begin
  FManager := pManager;
  if bRegisterDialog then pManager.RegisterDialog(Self);
  SetTexture(0, szControlTextureResourceName, hControlTextureResourceModule);
  InitDefaultDisplays;
end;

function Tz3DDialog.GetControlCount: Integer;
begin
  Result:= m_Controls.Count;
end;

function Tz3DDialog.GetNextDialog: Iz3DDialog;
begin
  Result:= FNextDialog;
end;

function Tz3DDialog.GetPrevDialog: Iz3DDialog;
begin
  Result:= FPrevDialog;
end;

procedure Tz3DDialog.SetPrevDialog(pNextDialog: Iz3DDialog);
begin
  FPrevDialog:= pNextDialog;
end;

function Tz3DDialog.GetEnableCaption: Boolean;
begin
  Result:= FCaption;
end;

function Tz3DDialog.GetHeight: Integer;
begin
  Result:= FHeight;
end;

function Tz3DDialog.GetKeyboardInput: Boolean;
begin
  Result:= FKeyboardInput;
end;

function Tz3DDialog.GetManager: Iz3DGUIController;
begin
  Result:= FManager;
end;

function Tz3DDialog.GetWidth: Integer;
begin
  Result:= FWidth;
end;

procedure Tz3DDialog.SetEnableCaption(const Value: Boolean);
begin
  FCaption:= Value;
end;

procedure Tz3DDialog.SetHeight(const Value: Integer);
begin
  FHeight:= Value;
end;

procedure Tz3DDialog.SetWidth(const Value: Integer);
begin
  FWidth:= Value;
end;

procedure Tz3DDialog.Render;
var
  pd3dDevice: IDirect3DDevice9;
  pTextureNode: Pz3DTextureNode;
  rc: TRect;
  wszOutput: array[0..255] of WideChar;
  pControl: Iz3DControl;
  i: Integer;
  bBackgroundIsVisible: Boolean;
  vertices: array[0..3] of Tz3DScreenVertexUntex;
begin
  if FDesktopOnly and not Manager.Desktop.Visible then Exit;
  inherited;
  if (m_fTimeLastRefresh < s_fTimeRefresh) then
  begin
    m_fTimeLastRefresh := z3DCore_GetTime;
    Refresh;
  end;
  if not FVisible then Exit;
  pd3dDevice := z3DCore_GetD3DDevice;
  bBackgroundIsVisible := FEnableBackground and (((m_colorTopLeft or m_colorTopRight or m_colorBottomRight or m_colorBottomLeft) and $FF000000) <> 0);
  if bBackgroundIsVisible then
  begin
    // Draw window
    vertices[0]:= z3DScreenVertexUntex(FLeft,          FTop,           0.5, 1.0, m_colorTopLeft);
    vertices[1]:= z3DScreenVertexUntex(FLeft + FWidth, FTop,           0.5, 1.0, m_colorTopRight);
    vertices[2]:= z3DScreenVertexUntex(FLeft + FWidth, FTop + FHeight, 0.5, 1.0, m_colorBottomRight);
    vertices[3]:= z3DScreenVertexUntex(FLeft,          FTop + FHeight, 0.5, 1.0, m_colorBottomLeft);
    pd3dDevice.SetRenderState(D3DRS_ZENABLE, iFalse);
    pd3dDevice.SetFVF(Tz3DScreenVertexUntex_FVF);
    pd3dDevice.DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, vertices, SizeOf(Tz3DScreenVertexUntex));
    if FCaption then
    begin
      // Draw title bar
      vertices[0]:= z3DScreenVertexUntex(FLeft+4, FTop+4,                           0.45, 1.0, D3DCOLOR_ARGB(255, 140, 180, 225));
      vertices[1]:= z3DScreenVertexUntex(FLeft-4 + FWidth, FTop+4,                  0.45, 1.0, D3DCOLOR_ARGB(255, 100, 130, 180));
      vertices[2]:= z3DScreenVertexUntex(FLeft-4 + FWidth, FTop+4 + Manager.Desktop.ThemeSettings.CaptionHeight, 0.45, 1.0, D3DCOLOR_ARGB(255, 30, 50, 100));
      vertices[3]:= z3DScreenVertexUntex(FLeft+4, FTop+4 + Manager.Desktop.ThemeSettings.CaptionHeight,          0.45, 1.0, D3DCOLOR_ARGB(255, 40, 60, 120));
      pd3dDevice.SetFVF(Tz3DScreenVertexUntex_FVF);
      pd3dDevice.DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, vertices, SizeOf(Tz3DScreenVertexUntex));
    end;
    if FEnableBorder then
    begin
      // Draw edge 1
      vertices[0]:= z3DScreenVertexUntex(FLeft, FTop,            0.4, 1.0, D3DCOLOR_ARGB(255, 255, 255, 255));
      vertices[1]:= z3DScreenVertexUntex(FLeft+2, FTop,          0.4, 1.0, D3DCOLOR_ARGB(255, 255, 255, 255));
      vertices[2]:= z3DScreenVertexUntex(FLeft+2, FTop+FHeight, 0.4, 1.0, D3DCOLOR_ARGB(255, 255, 255, 255));
      vertices[3]:= z3DScreenVertexUntex(FLeft, FTop+FHeight,   0.4, 1.0, D3DCOLOR_ARGB(255, 255, 255, 255));
      pd3dDevice.SetFVF(Tz3DScreenVertexUntex_FVF);
      pd3dDevice.DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, vertices, SizeOf(Tz3DScreenVertexUntex));
      // Draw edge 2
      vertices[0]:= z3DScreenVertexUntex(FLeft, FTop,           0.4, 1.0, D3DCOLOR_ARGB(255, 255, 255, 255));
      vertices[1]:= z3DScreenVertexUntex(FLeft+FWidth, FTop,   0.4, 1.0, D3DCOLOR_ARGB(255, 255, 255, 255));
      vertices[2]:= z3DScreenVertexUntex(FLeft+FWidth, FTop+2, 0.4, 1.0, D3DCOLOR_ARGB(255, 255, 255, 255));
      vertices[3]:= z3DScreenVertexUntex(FLeft, FTop+2,         0.4, 1.0, D3DCOLOR_ARGB(255, 255, 255, 255));
      pd3dDevice.SetFVF(Tz3DScreenVertexUntex_FVF);
      pd3dDevice.DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, vertices, SizeOf(Tz3DScreenVertexUntex));
      // Draw edge 3
      vertices[0]:= z3DScreenVertexUntex(FLeft+FWidth-2, FTop,          0.4, 1.0, D3DCOLOR_ARGB(255, 0, 0, 0));
      vertices[1]:= z3DScreenVertexUntex(FLeft+FWidth, FTop,            0.4, 1.0, D3DCOLOR_ARGB(255, 0, 0, 0));
      vertices[2]:= z3DScreenVertexUntex(FLeft+FWidth, FTop+FHeight,   0.4, 1.0, D3DCOLOR_ARGB(255, 0, 0, 0));
      vertices[3]:= z3DScreenVertexUntex(FLeft+FWidth-2, FTop+FHeight, 0.4, 1.0, D3DCOLOR_ARGB(255, 0, 0, 0));
      pd3dDevice.SetFVF(Tz3DScreenVertexUntex_FVF);
      pd3dDevice.DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, vertices, SizeOf(Tz3DScreenVertexUntex));
      // Draw edge 4
      vertices[0]:= z3DScreenVertexUntex(FLeft, FTop+FHeight-2,         0.4, 1.0, D3DCOLOR_ARGB(255, 0, 0, 0));
      vertices[1]:= z3DScreenVertexUntex(FLeft+FWidth, FTop+FHeight-2, 0.4, 1.0, D3DCOLOR_ARGB(255, 0, 0, 0));
      vertices[2]:= z3DScreenVertexUntex(FLeft+FWidth, FTop+FHeight,   0.4, 1.0, D3DCOLOR_ARGB(255, 0, 0, 0));
      vertices[3]:= z3DScreenVertexUntex(FLeft, FTop+FHeight,           0.4, 1.0, D3DCOLOR_ARGB(255, 0, 0, 0));
      pd3dDevice.SetFVF(Tz3DScreenVertexUntex_FVF);
      pd3dDevice.DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, vertices, SizeOf(Tz3DScreenVertexUntex));
    end;
  end;
  pd3dDevice.SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
  pd3dDevice.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
  pd3dDevice.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
  pd3dDevice.SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
  pd3dDevice.SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
  pd3dDevice.SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
  pd3dDevice.SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
  pd3dDevice.SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
  pTextureNode := GetTexture(0);
  pd3dDevice.SetTexture(0, pTextureNode.Texture);
  Manager.Sprite._Begin(D3DXSPRITE_DONOTSAVESTATE);
  if FCaption then
  begin
    rc := Rect(10, {-Manager.Desktop.ThemeSettings.CaptionHeight}+5, FWidth-10, Manager.Desktop.ThemeSettings.CaptionHeight);
    StringCchCopy(wszOutput, 256, FCaptionStr);
    DrawText(wszOutput, m_CapDisplay, rc, True);
  end;
  for i:= 0 to ControlCount - 1 do
  begin
    pControl := m_Controls[i] as Iz3DControl;
    if (pControl = s_pControlFocus) then Continue;
    pControl.Render;
  end;
  if (s_pControlFocus <> nil) and (s_pControlFocus.Dialog = Self as Iz3DDialog)
  then s_pControlFocus.Render;
  Manager.Sprite._End;
  pd3dDevice.SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG2);
  pd3dDevice.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
  pd3dDevice.SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
  pd3dDevice.SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);
  pd3dDevice.SetTextureStageState(0, D3DTSS_RESULTARG, D3DTA_CURRENT);
  pd3dDevice.SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);
  pd3dDevice.SetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
end;

procedure Tz3DDialog.Message(const AWnd: HWND; const AMsg: Cardinal;
  const AwParam, AlParam: Integer; var AHandled: Boolean);
var
  i: Integer;
  pControl: Iz3DControl;
  bShiftDown: Boolean;
begin
  if FDesktopOnly and not z3DGlobalEngine.Desktop.Visible then Exit;
  inherited;
  AHandled:= False;
  // For invisible dialog, do not handle anything.
  if not FVisible then Exit;

  // If automation command-line switch is on, enable this dialog's keyboard input
  // upon any key press or mouse click.
  if z3DCore_GetAutomation and
    ((WM_LBUTTONDOWN = AMsg) or (WM_LBUTTONDBLCLK = AMsg) or (WM_KEYDOWN = AMsg)) then
    FManager.EnableKeyboardInputForAllDialogs;

  if (AMsg = WM_LBUTTONDOWN) or (AMsg = WM_LBUTTONDBLCLK) then
  begin
    FMousePoint := Point(short(LOWORD(DWORD(AlParam))), short(HIWORD(DWORD(AlParam))));

    if (FMousePoint.x >= FLeft) and (FMousePoint.x < FLeft + FWidth) and
       (FMousePoint.y >= FTop) and (FMousePoint.y < FTop + FHeight) then
    begin
      AHandled:= True;
      if FCaption and (FMousePoint.y < FTop + Manager.Desktop.ThemeSettings.CaptionHeight) then
      begin
        FDrag := True;
        FMousePointO := Point(short(LOWORD(DWORD(AlParam))), short(HIWORD(DWORD(AlParam))));
        Dec(FMousePointO.x, FLeft);
        Dec(FMousePointO.y, FTop);
        SetCapture(z3DCore_GetHWND);
      end;
      if not FManager.ModalMode and not z3DSupports(Self, Iz3DMainMenuDialog) then SetFocus;
    end;
  end else
  if (AMsg = WM_LBUTTONUP) and FDrag then
  begin
    FMousePoint := Point(short(LOWORD(DWORD(AlParam))), short(HIWORD(DWORD(AlParam))));

    if (FMousePoint.x >= FLeft) and (FMousePoint.x < FLeft + FWidth) and
       (FMousePoint.y >= FTop) and (FMousePoint.y < FTop + Manager.Desktop.ThemeSettings.CaptionHeight) then
    begin
      ReleaseCapture;
      FDrag := False;
      AHandled:= True;
      Exit;
    end;
  end;

  // If a control is in focus, it belongs to this dialog, and it's enabled, then give
  // it the first chance at handling the message.
  if (s_pControlFocus <> nil) and
     (s_pControlFocus.Dialog = Self as Iz3DDialog) and
     (s_pControlFocus.Enabled) then
  begin
    // If the control MsgProc handles it, then we don't.
    if (s_pControlFocus.MsgProc(AMsg, AwParam, AlParam)) then
    begin
      AHandled:= True;
      Exit;
    end;
  end;

  case AMsg of
    WM_SIZE,
    WM_MOVE:
    begin
      // Handle sizing and moving messages so that in case the mouse cursor is moved out
      // of an UI control because of the window adjustment, we can properly
      // unhighlight the highlighted control.
      if HasFocus then OnMouseMove(Point(-1, -1));
    end;

    WM_ACTIVATEAPP:
    begin
      // Call OnFocusIn()/OnFocusOut() of the control that currently has the focus
      // as the application is activated/deactivated.  This matches the Windows
      // behavior.
      if (s_pControlFocus <> nil) and
         (s_pControlFocus.Dialog = Self as Iz3DDialog) and
         (s_pControlFocus.GetEnabled) then
      begin
        if (AwParam <> 0)
        then s_pControlFocus.OnFocusIn
        else s_pControlFocus.OnFocusOut;
      end;
    end;

    // Keyboard messages
    WM_KEYDOWN,
    WM_SYSKEYDOWN,
    WM_KEYUP,
    WM_SYSKEYUP:
    begin
      // If a control is in focus, it belongs to this dialog, and it's enabled, then give
      // it the first chance at handling the message.
      if (s_pControlFocus <> nil) and
         (s_pControlFocus.Dialog = Self as Iz3DDialog) and
         (s_pControlFocus.GetEnabled) then
      begin
        if (s_pControlFocus.HandleKeyboard(AMsg, AwParam, AlParam)) then
        begin
          AHandled:= True;
          Exit;
        end;
      end;

      // Not yet handled, see if this matches a control's hotkey
      // Activate the hotkey if the focus doesn't belong to an
      // edit box.
      if (AMsg = WM_KEYDOWN) and
         (
           (s_pControlFocus = nil) or
           not (s_pControlFocus.GetType in [z3dctEdit, z3dctIMEEdit])
         ) then
      begin
        for i:= 0 to ControlCount - 1 do
        begin
          pControl := m_Controls[i] as Iz3DControl;
          if (pControl.Hotkey = Cardinal(AwParam)) then
          begin
            pControl.OnHotkey;
            AHandled:= True;
            Exit;
          end;
        end;
      end;

      // Not yet handled, check for focus messages
      if (AMsg = WM_KEYDOWN) then
      begin
        // If keyboard input is not enabled, this message should be ignored
        if (not FKeyboardInput) then Exit;

        case AwParam of
          VK_RIGHT,
          VK_DOWN:
            if (s_pControlFocus <> nil) then
            begin
              AHandled:= OnCycleFocus(True);
              Exit;
            end;

          VK_LEFT,
          VK_UP:
            if (s_pControlFocus <> nil) then
            begin
              AHandled:= OnCycleFocus(False);
              Exit;
            end;

          VK_TAB:
          begin
            bShiftDown := ((GetKeyState(VK_SHIFT) and $8000) <> 0);
            AHandled:= OnCycleFocus(not bShiftDown);
            Exit;
          end;
        end;
      end;
    end;


    // Mouse messages
    WM_MOUSEMOVE,
    WM_LBUTTONDOWN,
    WM_LBUTTONUP,
    WM_MBUTTONDOWN,
    WM_MBUTTONUP,
    WM_RBUTTONDOWN,
    WM_RBUTTONUP,
    WM_XBUTTONDOWN,
    WM_XBUTTONUP,
    WM_LBUTTONDBLCLK,
    WM_MBUTTONDBLCLK,
    WM_RBUTTONDBLCLK,
    WM_XBUTTONDBLCLK,
    WM_MOUSEWHEEL:
    begin
      // If not accepting mouse input, return false to indicate the message should still
      // be handled by the application (usually to move the camera).
      if (not FMouseInput) then Exit;

      FMousePoint := Point(short(LOWORD(DWORD(AlParam))), short(HIWORD(DWORD(AlParam))));
      Dec(FMousePoint.x, FLeft);
      Dec(FMousePoint.y, FTop);

      // If caption is enabled, offset the Y coordinate by the negative of its height.
//      if (FCaption) then Dec(FMousePoint.y, Manager.Desktop.ThemeSettings.CaptionHeight);

      // If a control is in focus, it belongs to this dialog, and it's enabled, then give
      // it the first chance at handling the message.
      if (s_pControlFocus <> nil) and
         (s_pControlFocus.Dialog = Self as Iz3DDialog) and
         (s_pControlFocus.GetEnabled) then
      begin
        if s_pControlFocus.HandleMouse(AMsg, FMousePoint, AwParam, AlParam) then
        begin
          AHandled:= True;
          Exit;
        end;
      end;

      // Not yet handled, see if the mouse is over any controls
      pControl := GetControlAtPoint(FMousePoint);
      if (pControl <> nil) and pControl.Enabled then
      begin
        AHandled := pControl.HandleMouse(AMsg, FMousePoint, AwParam, AlParam);
      end else
      begin
        // Mouse not over any controls in this dialog, if there was a control
        // which had focus it just lost it
        if (AMsg = WM_LBUTTONDOWN) and
           (s_pControlFocus <> nil) and
           (s_pControlFocus.Dialog = Self as Iz3DDialog) then
        begin
          s_pControlFocus.OnFocusOut;
          s_pControlFocus := nil;
        end;
      end;

      // Still not handled, hand this off to the dialog. Return false to indicate the
      // message should still be handled by the application (usually to move the camera).
      case AMsg of
        WM_MOUSEMOVE:
        begin
          OnMouseMove(FMousePoint);
          if FDrag then SetLocation(short(LOWORD(DWORD(AlParam)))-FMousePointO.X,
          short(HIWORD(DWORD(AlParam)))-FMousePointO.Y);
          AHandled:= True;
          Exit;
        end;
      end;
    end;

    WM_CAPTURECHANGED:
    begin
      // The application has lost mouse capture.
      // The dialog object may not have received
      // a WM_MOUSEUP when capture changed. Reset
      // FDrag so that the dialog does not mistakenly
      // think the mouse button is still held down.
      if (THandle(AlParam) <> AWnd) then FDrag := False;
    end;
  end;
end;

function Tz3DDialog.GetVisible: Boolean;
begin
  Result:= FVisible;
end;

procedure Tz3DDialog.SetVisible(const Value: Boolean);
begin
  FVisible:= Value;
end;

procedure Tz3DDialog.SetCallback(pCallback: PCallbackz3DguiEvent; pUserContext: Pointer = nil);
begin
  // If this assert triggers, you need to call Tz3DDialog::Init() first.  This change
  // was made so that the z3D's GUI could become seperate and optional from z3D's core.  The
  // creation and interfacing with Iz3DGUIController is now the responsibility
  // of the application if it wishes to use z3D's GUI.
  Assert((FManager <> nil), 'To fix call Tz3DDialog.Init(Default) first.  See comments for details.');

  FCallbackEvent := pCallback;
  FCallbackEventUserContext := pUserContext;
end;

procedure Tz3DDialog.RemoveControl(ID: Integer);
var
  i: Integer;
  pControl: Iz3DControl;
begin
  for i:= 0 to ControlCount - 1 do
  begin
    pControl := m_Controls[i] as Iz3DControl;
    if (pControl.ID = ID) then
    begin
      // Clean focus first
      ClearFocus;

      // Clear references to this control
      if (s_pControlFocus = pControl) then s_pControlFocus := nil;
      if (s_pControlPressed = pControl) then s_pControlPressed := nil;
      if (FControlMouseOver = pControl) then FControlMouseOver := nil;

      m_Controls.Remove(pControl);
      pControl:= nil;
      Exit;
    end;
  end;
end;

procedure Tz3DDialog.Refresh;
var
  i: Integer;
begin
  if (s_pControlFocus <> nil) then s_pControlFocus.OnFocusOut;

  if (FControlMouseOver <> nil) then FControlMouseOver.OnMouseLeave;

  s_pControlFocus := nil;
  s_pControlPressed := nil;
  FControlMouseOver := nil;

  for i:= 0 to ControlCount - 1 do
    (m_Controls[i] as Iz3DControl).Refresh;

  if FKeyboardInput then FocusDefaultControl;
end;

procedure Tz3DDialog.SendEvent(const AEvent: Tz3DControlEvent; bTriggeredByUser: Boolean; pControl: Iz3DControl);
begin
  // If no callback has been registered there's nowhere to send the event to
  if (@FCallbackEvent = nil) then Exit;

  // Discard events triggered programatically if these types of events haven't been
  // enabled
  if (not bTriggeredByUser and not FNonUserEvents) then Exit;

  FCallbackEvent(AEvent, pControl.ID, pControl, FCallbackEventUserContext);
end;

procedure Tz3DDialog.RemoveAllControls;
var
  i: Integer;
  pControl: Iz3DControl;
begin
  if (s_pControlFocus<>nil) and (s_pControlFocus.Dialog = Self as Iz3DDialog) then s_pControlFocus := nil;
  if (s_pControlPressed<>nil) and (s_pControlPressed.Dialog = Self as Iz3DDialog) then s_pControlPressed := nil;
  FControlMouseOver := nil;

  for i:= 0 to ControlCount - 1 do
  begin
    pControl := m_Controls[i] as Iz3DControl;
    pControl:= nil;
  end;

  m_Controls := nil; // RemoveAll;
end;

procedure Tz3DDialog.EnableNonUserEvents(bEnable: Boolean);
begin FNonUserEvents := bEnable; end;

procedure Tz3DDialog.EnableKeyboardInput(bEnable: Boolean);
begin FKeyboardInput := bEnable; end;

procedure Tz3DDialog.EnableMouseInput(bEnable: Boolean);
begin FMouseInput := bEnable; end;

function Tz3DDialog.GetLeft: Integer;
begin
  Result:= FLeft;
end;

function Tz3DDialog.GetTop: Integer;
begin
  Result:= FTop;
end;

procedure Tz3DDialog.SetLeft(const Value: Integer);
begin
  FLeft:= Value;
end;

procedure Tz3DDialog.SetTop(const Value: Integer);
begin
  FTop:= Value;
end;

function Tz3DDialog.GetCaption: PWideChar;
begin
  Result:= FCaptionStr;
end;

{ Tz3DGUIController }

constructor Tz3DGUIController.Create(const ADesktop: Iz3DDesktop);
begin
  inherited Create;
  FDialogs:= TInterfaceList.Create;
  FDesktop:= ADesktop;
end;

function Tz3DGUIController.GetModalMode: Boolean;
begin
  Result:= FModalMode;
end;

procedure Tz3DGUIController.SetModalMode(const Value: Boolean);
begin
  FModalMode:= Value;
end;

procedure Tz3DGUIController.BringToFront(const ADialog: Iz3DDialog);
begin
  FDialogs.Remove(ADialog);
  FDialogs.Add(ADialog);
end;

procedure Tz3DGUIController.GUIRender;
var I: Integer;
    FDevice: IDirect3DDevice9;
begin
  inherited;
  FDevice := z3DCore_GetD3DDevice;
  GetStateBlock.Capture;
  FDevice.SetRenderState(D3DRS_ALPHABLENDENABLE, iTrue);
  FDevice.SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
  FDevice.SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
  FDevice.SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
  FDevice.SetRenderState(D3DRS_SHADEMODE, D3DSHADE_GOURAUD);
  FDevice.SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG2);
  FDevice.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
  FDevice.SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
  FDevice.SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);
  FDevice.SetTextureStageState(0, D3DTSS_RESULTARG, D3DTA_CURRENT);
  FDevice.SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);
  FDevice.SetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
  FDevice.SetVertexShader(nil);
  FDevice.SetPixelShader(nil);

  // Render the dialogs iterating trought the z-order
  for I:= 0 to FDialogs.Count-1 do (FDialogs[I] as Iz3DDialog).Render;

  GetStateBlock.Apply;
end;

function Tz3DGUIController.GetDesktop: Iz3DDesktop;
begin
  Result:= FDesktop;
end;

destructor Tz3DGUIController.Destroy;
begin
  Tz3DUniBuffer.Uninitialize;
  Tz3DIMEEditBox.Uninitialize;
end;

function Tz3DGUIController.GetStateBlock: IDirect3DStateBlock9;
begin
  Result:= FStateBlock;
end;

procedure Tz3DGUIController.CreateScenarioObjects(const AResetDevice: Boolean);
var I: Integer;
    pFontNode: Pz3DFontNode;
begin
  inherited;
  if AResetDevice then
  begin
    for i:= 0 to Length(FFontCache) - 1 do
    begin
      pFontNode := FFontCache[i];
      if (pFontNode.Font <> nil) then pFontNode.Font.OnResetDevice;
    end;
    if (FSprite <> nil) then FSprite.OnResetDevice;
    z3DCore_GetD3DDevice.CreateStateBlock(D3DSBT_ALL, FStateBlock);
  end else
  begin
    for i:= 0 to Length(FFontCache) - 1 do CreateFont(i);
    for i:= 0 to Length(FTextureCache) - 1 do CreateTexture(i);
    D3DXCreateSprite(z3DCore_GetD3DDevice, FSprite);
    Tz3DIMEEditBox.StaticOnCreateDevice;
  end;
end;

procedure Tz3DGUIController.DestroyScenarioObjects(const ALostDevice: Boolean);
var i: Integer;
    pFontNode: Pz3DFontNode;
    pTextureNode: Pz3DTextureNode;
begin
  inherited;
  if ALostDevice then
  begin
    for i:= 0 to Length(FFontCache) - 1 do
    begin
      pFontNode := FFontCache[i];
      if (pFontNode.Font <> nil) then pFontNode.Font.OnLostDevice;
    end;
    if (FSprite <> nil) then FSprite.OnLostDevice;
    FStateBlock := nil;
  end else
  begin
    for i:= 0 to Length(FFontCache) - 1 do
    begin
      pFontNode := FFontCache[i];
      pFontNode.Font := nil;
    end;
    if (FSprite <> nil) then FSprite.OnLostDevice;
    for i:= 0 to Length(FTextureCache) - 1 do
    begin
      pTextureNode := FTextureCache[i];
      pTextureNode.Texture := nil;
    end;
    FSprite := nil;
  end;
end;

procedure Tz3DGUIController.Message(const AWnd: HWND; const AMsg: Cardinal; const AwParam, AlParam: Integer;
  var ADefault: Boolean; var AResult: Integer);
var I: Integer;
    FHandled: Boolean;
begin
  inherited;
  AResult:= Integer(Tz3DIMEEditBox.StaticMsgProc(AMsg, AwParam, AlParam));
  for I:= FDialogs.Count-1 downto 0 do
  begin
    if (not FModalMode or (FDialogs[I] as Iz3DDialog).ModalMode) and
    (not FHandled or z3DSupports(FDialogs[I], Iz3DMainMenuDialog)) then
    (FDialogs[I] as Iz3DDialog).Message(AWnd, AMsg, AwParam, AlParam, FHandled);
  end;
end;

function Tz3DGUIController.GetSprite: ID3DXSprite;
begin
  Result:= FSprite;
end;

function Tz3DGUIController.GetDialogCount: Integer;
begin
  Result:= FDialogs.Count;
end;

function Tz3DGUIController.GetDialogs(const I: Integer): Iz3DDialog;
begin
  Result:= FDialogs[I] as Iz3DDialog;
end;

function Tz3DGUIController.IndexOf(const ADialog: Iz3DDialog): Integer;
begin
  Result:= FDialogs.IndexOf(ADialog);
end;

function Tz3DGUIController.GetFonts(iIndex: Integer): Pz3DFontNode;
begin Result:= FFontCache[iIndex]; end;

function Tz3DGUIController.GetTextureNode(iIndex: Integer): Pz3DTextureNode;
begin
  Result:= FTextureCache[iIndex];
end;

function Tz3DGUIController.RegisterDialog(pDialog: Iz3DDialog): Boolean;
var
  i: Integer;
begin
  Result:= True;

  // Check that the dialog isn't already registered.
  for i := 0 to FDialogs.Count - 1 do
    if (FDialogs[i] = pDialog) then Exit;

  // Add to the list.
  try
    FDialogs.Add(pDialog);
  except
    Result:= False;
    Exit;
  end;

  // Set up next and prev pointers.
  if (FDialogs.Count > 1)
  then (FDialogs[FDialogs.Count - 2] as Iz3DDialog).SetNextDialog(pDialog);
  (FDialogs[FDialogs.Count - 1] as Iz3DDialog).SetNextDialog(FDialogs[0] as Iz3DDialog);
end;

procedure Tz3DGUIController.UnregisterDialog(pDialog: Iz3DDialog);
var
  i: Integer;
  l, r: Integer;
begin
  if pDialog.ModalMode then FModalMode:= False;
  // Search for the dialog in the list.
  for i := 0 to FDialogs.Count - 1 do
    if (FDialogs[i] = pDialog) then
    begin
      FDialogs.Delete(i);
      
      if (FDialogs.Count > 0) then
      begin
        if (i = 0)
        then l := FDialogs.Count - 1
        else l := i - 1;

        if (FDialogs.Count = i)
        then r := 0
        else r := i;

        (FDialogs[l] as Iz3DDialog).SetNextDialog(FDialogs[r] as Iz3DDialog);
      end;
      Break;
    end;
end;

procedure Tz3DGUIController.EnableKeyboardInputForAllDialogs;
var
  i: Integer;
begin
  // Enable keyboard input for all registered dialogs
  for i := 0 to FDialogs.Count - 1 do
    (FDialogs[i] as Iz3DDialog).EnableKeyboardInput(True);
end;

function Tz3DGUIController.AddFont(strFaceName: PWideChar; height, weight: Longint): Integer;
var
  i: Integer;
  pFontNode: Pz3DFontNode;
  pNewFontNode: Pz3DFontNode;
  iFont: Integer;
  // nLen: size_t;
begin
  // See if this font already exists
  for i:= 0 to Length(FFontCache) - 1 do
  begin
    pFontNode := FFontCache[i];
    // StringCchLength(strFaceName, MAX_PATH, nLen);
    if (0 = lstrcmpiW(pFontNode.Name, strFaceName{, nLen})) and
       (pFontNode.Height = height) and
       (pFontNode.Weight = weight) then
    begin
      Result:= i;
      Exit;
    end;
  end;

  // Add a new font and try to create it
  try
    New(pNewFontNode);
  except
    Result:= -1;
    Exit;
  end;

  ZeroMemory(pNewFontNode, SizeOf(Tz3DFontNode));
  StringCchCopy(pNewFontNode.Name, MAX_PATH, strFaceName);
  pNewFontNode.Height := height;
  pNewFontNode.Weight := weight;

  // FFontCache.Add(pNewFontNode);
  iFont := Length(FFontCache);
  SetLength(FFontCache, iFont+1);
  FFontCache[iFont]:= pNewFontNode;

  // If a device is available, try to create immediately
  if (z3DCore_GetD3DDevice <> nil) then CreateFont(iFont);

  Result:= iFont;
end;

function Tz3DDialog.SetFont(index: LongWord; strFaceName: PWideChar; height, weight: Longint): HRESULT;
var
  i, l, iFont: Integer;
begin
  // If this assert triggers, you need to call Tz3DDialog::Init() first.  This change
  // was made so that the z3D's GUI could become seperate and optional from z3D's core.  The
  // creation and interfacing with Tz3DGUIController is now the responsibility
  // of the application if it wishes to use z3D's GUI.
  Assert(Assigned(Manager), 'To fix call Tz3DDialog.Init(Default) first. See comments for details.');

  // Make sure the list is at least as large as the index being set
  l:= Length(m_Fonts);
  if l <= Integer(index) then
  begin
    SetLength(m_Fonts, index+1);
    for i:= l to index do m_Fonts[i]:= -1;
  end;

  iFont := Manager.AddFont(strFaceName, height, weight);
  m_Fonts[index]:= iFont;

  Result:= S_OK;
end;

function Tz3DDialog.GetFont(index: LongWord): Pz3DFontNode;
begin
  if (Manager = nil) then
  begin
    Result:= nil;
    Exit;
  end;
  Result:= Manager.Fonts[m_Fonts[index]];
end;

function Tz3DGUIController.AddTexture(strFilename: PWideChar): Integer;
var
  i: Integer;
  pTextureNode, pNewTextureNode: Pz3DTextureNode;
  iTexture: Integer;
  nLen: size_t;
begin
  // See if this texture already exists
  for i:= 0 to Length(FTextureCache) - 1 do
  begin
    pTextureNode := FTextureCache[i];
    StringCchLength(strFilename, MAX_PATH, nLen);
    if pTextureNode.FileSource and // Sources must match
       // (0 = _wcsnicmp(pTextureNode.strFilename, strFilename, nLen)) then
       (0 =  lstrcmpiW(pTextureNode.Filename, strFilename)) then
    begin
      Result:= i;
      Exit;
    end;
  end;

  // Add a new texture and try to create it
  try
    New(pNewTextureNode);
  except
    Result:= -1;
    Exit;
  end;

  ZeroMemory(pNewTextureNode, SizeOf(Tz3DTextureNode));
  pNewTextureNode.FileSource := True;
  StringCchCopy(pNewTextureNode.Filename, MAX_PATH, strFilename);

  //FTextureCache.Add(pNewTextureNode);
  iTexture := Length(FTextureCache);
  SetLength(FTextureCache, iTexture+1);
  FTextureCache[iTexture]:= pNewTextureNode;

  // If a device is available, try to create immediately
  if (z3DCore_GetD3DDevice <> nil) then CreateTexture(iTexture);

  Result:= iTexture;
end;

function Tz3DGUIController.CreateTexture(iTexture: LongWord): HRESULT;
var
  pTextureNode: Pz3DTextureNode;
  info: TD3DXImageInfo;
  pID: PWideChar;
begin
  pTextureNode := FTextureCache[iTexture];

  if not pTextureNode.FileSource then
  begin
    if (pTextureNode.ResourceID <> 0)
    then pID := PWideChar(size_t(pTextureNode.ResourceID))
    else pID := pTextureNode.Filename;

    // Create texture from resource
    Result :=  D3DXCreateTextureFromResourceExW(z3DCore_GetD3DDevice,
                   pTextureNode.ResourceModule, pID, D3DX_DEFAULT, D3DX_DEFAULT,
                   1, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED,
                   D3DX_DEFAULT, D3DX_DEFAULT, 0,
                   @info, nil, pTextureNode.Texture);
    if FAILED(Result) then
    begin
      Result:= DXTRACE_ERR('D3DXCreateTextureFromResourceEx', Result);
      Exit;
    end;
  end else
  begin
    // Make sure there's a texture to create
    if (pTextureNode.Filename[0] = #0) then
    begin
      Result:= S_OK;
      Exit;
    end;

    // Create texture from file
    Result :=  D3DXCreateTextureFromFileExW(z3DCore_GetD3DDevice, pTextureNode.Filename, D3DX_DEFAULT, D3DX_DEFAULT,
                   1, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED,
                   D3DX_DEFAULT, D3DX_DEFAULT, 0,
                   @info, nil, pTextureNode.Texture);
    if FAILED(Result) then
    begin
      Result:= DXTRACE_ERR('D3DXCreateTextureFromFileEx', Result);
      Exit;
    end;
  end;

  // Store dimensions
  pTextureNode.Width := info.Width;
  pTextureNode.Height := info.Height;

  Result:= S_OK;
end;

function IS_INTRESOURCE(_r: Pointer): Boolean;
begin
  Result:= ((ULONG_PTR(_r) shr 16) = 0);
end;

function Tz3DGUIController.AddTexture(strResourceName: PWideChar; hResourceModule: HMODULE): Integer;
var
  i: Integer;
  pTextureNode, pNewTextureNode: Pz3DTextureNode;
  iTexture: Integer;
  nLen: size_t;
begin
  // See if this texture already exists
  for i:= 0 to Length(FTextureCache) - 1 do
  begin
    pTextureNode := FTextureCache[i];
    if not pTextureNode.FileSource and      // Sources must match
       (pTextureNode.ResourceModule = hResourceModule) then // Module handles must match
    begin
      if IS_INTRESOURCE(strResourceName) then
      begin
        // Integer-based ID
        if (INT_PTR(strResourceName) = pTextureNode.ResourceID) then
        begin
          Result:= i;
          Exit;
        end;
      end else
      begin
        // String-based ID
        StringCchLength(strResourceName, MAX_PATH, nLen);
        // if (0 = _wcsnicmp(pTextureNode.strFilename, strResourceName, nLen)) then
        if (0 = lstrcmpiW(pTextureNode.Filename, strResourceName{, nLen})) then
        begin
          Result:= i;
          Exit;
        end;
      end;
    end;
  end;

  // Add a new texture and try to create it
  try
    New(pNewTextureNode);
  except
    Result:= -1;
    Exit;
  end;

  ZeroMemory(pNewTextureNode, SizeOf(Tz3DTextureNode));
  pNewTextureNode.ResourceModule := hResourceModule;
  if IS_INTRESOURCE(strResourceName)
  then pNewTextureNode.ResourceID := Integer(size_t(strResourceName))
  else
  begin
    pNewTextureNode.ResourceID := 0;
    StringCchCopy(pNewTextureNode.Filename, MAX_PATH, strResourceName);
  end;

  //FTextureCache.Add(pNewTextureNode);
  iTexture := Length(FTextureCache);
  SetLength(FTextureCache, iTexture+1);
  FTextureCache[iTexture]:= pNewTextureNode;

  // If a device is available, try to create immediately
  if (z3DCore_GetD3DDevice <> nil) then CreateTexture(iTexture);

  Result:= iTexture;
end;

function Tz3DDialog.SetTexture(index: LongWord; strFilename: PWideChar): HRESULT;
var
  i, l, iTexture: Integer;
begin
  // If this assert triggers, you need to call Tz3DDialog::Init() first.  This change
  // was made so that the z3D's GUI could become seperate and optional from z3D's core.  The
  // creation and interfacing with Tz3DGUIController is now the responsibility
  // of the application if it wishes to use z3D's GUI.
  Assert(Assigned(Manager), 'To fix this, call Tz3DDialog::Init() first. See comments for details.');

  // Make sure the list is at least as large as the index being set
  l:= Length(m_Textures);
  if l <= Integer(index) then
  begin
    SetLength(m_Textures, index+1);
    for i:= l to index do m_Textures[i]:= -1;
  end;

  iTexture := Manager.AddTexture(strFilename);

  m_Textures[index]:= iTexture;
  Result:= S_OK;
end;

function Tz3DDialog.SetTexture(index: LongWord; strResourceName: PWideChar; hResourceModule: HMODULE): HRESULT;
var
  i, L: LongWord;
  iTexture: Integer;
begin
  // If this assert triggers, you need to call Tz3DDialog::Init() first.  This change
  // was made so that the z3D's GUI could become seperate and optional from z3D's core.  The
  // creation and interfacing with Tz3DGUIController is now the responsibility
  // of the application if it wishes to use z3D's GUI.
  Assert(Assigned(Manager), 'To fix this, call Tz3DDialog::Init() first.  See comments for details.');

  // Make sure the list is at least as large as the index being set
  L:= Length(m_Textures);
  if (L >= index) then
  begin
    SetLength(m_Textures, index+1);
    for i:= L to index do m_Textures[i]:= -1;
  end;

  iTexture := FManager.AddTexture(strResourceName, hResourceModule);

  m_Textures[index] := iTexture;
  Result:= S_OK;
end;

function Tz3DDialog.GetTexture(index: LongWord): Pz3DTextureNode;
begin
  if (Manager = nil) then
  begin
    Result:= nil;
    Exit;
  end;

  Result:= Manager.GetTextureNode(m_Textures[index]);
end;

function Tz3DDialog.GetControlAtPoint(pt: TPoint): Iz3DControl;
var
  i: Integer;
  pControl: Iz3DControl;
begin
  // Search through all child controls for the first one which
  // contains the mouse point
  for i:= 0 to ControlCount - 1 do
  begin
    pControl := m_Controls[i] as Iz3DControl;
    if (pControl = nil) then Continue;
    // We only return the current control if it is visible
    // and enabled.  Because GetControlAtPoint() is used to do mouse
    // hittest, it makes sense to perform this filtering.
    if pControl.ContainsPoint(pt) and pControl.Enabled and pControl.Visible then
    begin
      Result:= pControl;
      Exit;
    end;
  end;
  Result:= nil;
end;

function Tz3DDialog.GetControlEnabled(ID: Integer): Boolean;
var
  pControl: Iz3DControl;
begin
  pControl := GetControl(ID);
  if (pControl = nil) then Result:= False
  else Result:= pControl.Enabled;
end;

procedure Tz3DDialog.SetControlEnabled(ID: Integer; bEnabled: Boolean);
var
  pControl: Iz3DControl;
begin
  pControl := GetControl(ID);
  if (pControl <> nil) then pControl.Enabled:= bEnabled;
end;

procedure Tz3DDialog.OnMouseUp(pt: TPoint);
begin
  s_pControlPressed := nil;
  FControlMouseOver := nil;
end;

procedure Tz3DDialog.OnMouseMove(pt: TPoint);
var
  pControl: Iz3DControl;
begin
  // Figure out which control the mouse is over now
  pControl := GetControlAtPoint(pt);

  // If the mouse is still over the same control, nothing needs to be done
  if (pControl = FControlMouseOver) then Exit;

  // Handle mouse leaving the old control
  if (FControlMouseOver <> nil) then FControlMouseOver.OnMouseLeave;

  // Handle mouse entering the new control
  FControlMouseOver := pControl;
  if (pControl <> nil) then FControlMouseOver.OnMouseEnter;
end;

function Tz3DDialog.SetDefaultDisplay(nControlType: Tz3DControlType; iDisplay: LongWord; const pDisplay: Iz3DDisplay): HRESULT;
var
  i, l: Integer;
  pDisplayHolder: Pz3DDisplayHolder;
  pNewHolder: Pz3DDisplayHolder;
begin
  // If this Display type already exist in the list, simply update the stored Display
  for i:= 0 to Length(m_DefaultDisplays) - 1 do
  begin
    pDisplayHolder := m_DefaultDisplays[i];

    if (pDisplayHolder.ControlType = nControlType) and
       (pDisplayHolder.DisplayIndex = iDisplay) then
    begin
      pDisplayHolder.Display.Assign(pDisplay);
      Result:= S_OK;
      Exit;
    end;
  end;

  // Otherwise, add a new entry
  try
    New(pNewHolder);
    pNewHolder.Display:= Tz3DDisplay.Create;
  except
    Result:= E_OUTOFMEMORY;
    Exit;
  end;

  pNewHolder.ControlType := nControlType;
  pNewHolder.DisplayIndex := iDisplay;
  pNewHolder.Display.Assign(pDisplay);

  // m_DefaultDisplays.Add(pNewHolder);
  l:= Length(m_DefaultDisplays);
  SetLength(m_DefaultDisplays, l+1);
  m_DefaultDisplays[l]:= pNewHolder;

  Result:= S_OK;
end;

function Tz3DDialog.GetDefaultDisplay(nControlType: Tz3DControlType; iDisplay: LongWord): Iz3DDisplay;
var
  i: Integer;
  pDisplayHolder: Pz3DDisplayHolder;
begin
  for i:= 0 to Length(m_DefaultDisplays) - 1 do
  begin
    pDisplayHolder := m_DefaultDisplays[i];
    if (pDisplayHolder.ControlType = nControlType) and
    (pDisplayHolder.DisplayIndex = iDisplay) then
    begin
      Result:= pDisplayHolder.Display;
      Exit;
    end;
  end;
  Result:= nil;
end;

function Tz3DDialog.AddLabel(ID: Integer; strText: PWideChar; x, y, width, height: Integer; bIsDefault: Boolean = False; ppCreated: PIz3DLabel = nil): HRESULT;
var
  FLabel: Iz3DLabel;
begin
  try
    FLabel := Tz3DLabel.Create(Self);
  except
    Result:= E_OUTOFMEMORY;
    Exit;
  end;
  if (ppCreated <> nil) then ppCreated^ := FLabel;

  Result := AddControl(FLabel);
  if FAILED(Result) then Exit;

  // Set the ID and list index
  FLabel.ID := ID;
  FLabel.Text:= strText;
  FLabel.SetLocation(x, y);
  FLabel.SetSize(width, height);
  FLabel.Default:= bIsDefault;
  Result:= S_OK;
end;

function Tz3DDialog.AddButton(ID: Integer; strText: PWideChar; x, y, width, height: Integer; nHotkey: LongWord = 0; bIsDefault: Boolean = False; ppCreated: PIz3DButton = nil): HRESULT;
var
  pButton: Iz3DButton;
begin
  try
    pButton := Tz3DButton.Create(Self);
  except
    Result:= E_OUTOFMEMORY;
    Exit;
  end;
  if (ppCreated <> nil) then ppCreated^ := pButton;

  Result := AddControl(pButton);
  if FAILED(Result) then Exit;

  // Set the ID and list index
  pButton.ID:= ID;
  pButton.Text:= strText;
  pButton.SetLocation(x, y);
  pButton.SetSize(width, height);
  pButton.Hotkey:= nHotkey;
  pButton.Default:= bIsDefault;

  Result:= S_OK;
end;

function Tz3DDialog.AddCheckBox(ID: Integer; strText: PWideChar; x, y, width, height: Integer; bChecked: Boolean = False; nHotkey: LongWord = 0; bIsDefault: Boolean = False; ppCreated: PIz3DCheckBox = nil): HRESULT;
var
  pCheckBox: Iz3DCheckBox;
begin
  try
    pCheckBox := Tz3DCheckBox.Create(Self);
  except
    Result:= E_OUTOFMEMORY;
    Exit;
  end;
  if (ppCreated <> nil) then ppCreated^ := pCheckBox;

  Result := AddControl(pCheckBox);
  if FAILED(Result) then Exit;

  // Set the ID and list index
  pCheckBox.ID:= ID;
  pCheckBox.Text:= strText;
  pCheckBox.SetLocation(x, y);
  pCheckBox.SetSize(width, height);
  pCheckBox.Hotkey:= nHotkey;
  pCheckBox.Default:= bIsDefault;
  pCheckBox.Checked:= bChecked;

  Result:= S_OK;
end;

function Tz3DDialog.AddRadioButton(ID: Integer; nButtonGroup: LongWord; strText: PWideChar; x, y, width, height: Integer; bChecked: Boolean = False; nHotkey: LongWord = 0; bIsDefault: Boolean = False; ppCreated: PIz3DRadioButton = nil): HRESULT;
var
  pRadioButton: Iz3DRadioButton;
begin
  try
    pRadioButton := Tz3DRadioButton.Create(Self);
    if (ppCreated <> nil) then ppCreated^ := pRadioButton;
  except
    Result:= E_OUTOFMEMORY;
    Exit;
  end;

  Result := AddControl(pRadioButton);
  if FAILED(Result) then Exit;

  // Set the ID and list index
  pRadioButton.ID:= ID;
  pRadioButton.Text:= strText;
  pRadioButton.ButtonGroup:= nButtonGroup;
  pRadioButton.SetLocation(x, y);
  pRadioButton.SetSize(width, height);
  pRadioButton.Hotkey:= nHotkey;
  pRadioButton.Checked:= bChecked; // <-- look HERE
  pRadioButton.Default:= bIsDefault;
  pRadioButton.Checked:= bChecked; //todo: look above - validate what is't really needed

  Result:= S_OK;
end;

function Tz3DDialog.AddComboBox(ID: Integer; x, y, width, height: Integer; nHotKey: LongWord = 0; bIsDefault: Boolean = False; ppCreated: PIz3DComboBox = nil): HRESULT;
var
  pComboBox: Iz3DComboBox;
begin
  try
    pComboBox := Tz3DComboBox.Create(Self);
    if (ppCreated <> nil) then ppCreated^ := pComboBox;
  except
    Result:= E_OUTOFMEMORY;
    Exit;
  end;

  Result := AddControl(pComboBox);
  if FAILED(Result) then Exit;

  // Set the ID and list index
  pComboBox.ID:= ID;
  pComboBox.SetLocation(x, y);
  pComboBox.SetSize(width, height);
  pComboBox.Hotkey:= nHotkey;
  pComboBox.Default := bIsDefault;

  Result:= S_OK;
end;

function Tz3DDialog.AddTrackBar(ID: Integer; x, y, width, height: Integer; min: Integer = 0; max: Integer = 100; value: Integer = 50; bIsDefault: Boolean = False; ppCreated: PIz3DTrackBar = nil): HRESULT;
var
  FTrackBar: Iz3DTrackBar;
begin
  try
    FTrackBar := Tz3DTrackBar.Create(Self);

    if (ppCreated <> nil) then ppCreated^ := FTrackBar;
  except
    on EOutOfMemory do
    begin
      Result:= E_OUTOFMEMORY;
      Exit;
    end;
  end;

  Result := AddControl(FTrackBar);
  if FAILED(Result) then Exit;

  // Set the ID and list index
  FTrackBar.ID:= ID;
  FTrackBar.SetLocation(x, y);
  FTrackBar.SetSize(width, height);
  FTrackBar.Default := bIsDefault;
  FTrackBar.SetRange(min, max);
  FTrackBar.SetValue(value);
  FTrackBar.UpdateRects;

  Result:= S_OK;
end;

function Tz3DDialog.AddEditBox(ID: Integer; strText: PWideChar; x, y, width, height: Integer; bIsDefault: Boolean = False; ppCreated: PIz3DEdit = nil): HRESULT;
var
  pEditBox: Iz3DEdit;
begin
  try
    pEditBox := Tz3DEdit.Create(Self);

    if (ppCreated <> nil) then ppCreated^:= pEditBox;
  except
    on EOutOfMemory do
    begin
      Result:= E_OUTOFMEMORY;
      Exit;
    end;
  end;

  Result := AddControl(pEditBox);
  if FAILED(Result) then Exit;

  // Set the ID and position
  pEditBox.ID := ID;
  pEditBox.SetLocation(x, y);
  pEditBox.SetSize(width, height);
  pEditBox.Default := bIsDefault;

  if (strText <> nil) then pEditBox.SetText(strText);

  Result:= S_OK;
end;

function Tz3DDialog.AddIMEEditBox(ID: Integer; strText: PWideChar; x, y, width, height: Integer; bIsDefault: Boolean = False; ppCreated: PIz3DIMEEditBox = nil): HRESULT;
var
  pEditBox: Iz3DIMEEditBox;
begin
  try
    pEditBox := Tz3DIMEEditBox.Create(Self);

    if (ppCreated <> nil) then ppCreated^:= pEditBox;
  except
    on EOutOfMemory do
    begin
      Result:= E_OUTOFMEMORY;
      Exit;
    end;
  end;

  Result := AddControl(pEditBox);
  if FAILED(Result) then Exit;

  // Set the ID and position
  pEditBox.ID := ID;
  pEditBox.SetLocation(x, y);
  pEditBox.SetSize(width, height);
  pEditBox.Default := bIsDefault;

  if (strText <> nil) then pEditBox.SetText(strText);

  Result:= S_OK;
end;

function Tz3DDialog.AddListBox(ID: Integer; x, y, width, height: Integer; dwStyle: Tz3DListBoxStyle = z3dlbsNormal; ppCreated: PIz3DListBox = nil): HRESULT;
var
  pListBox: Iz3DListBox;
begin
  try
    pListBox := Tz3DListBox.Create(Self);
    if (ppCreated <> nil) then ppCreated^:= pListBox;
  except
    Result:= E_OUTOFMEMORY;
    Exit;
  end;

  Result := AddControl(pListBox);
  if FAILED(Result) then Exit;

  // Set the ID and position
  pListBox.ID:= ID;
  pListBox.SetLocation(x, y);
  pListBox.SetSize(width, height);
  pListBox.Style:= dwStyle;

  Result:= S_OK;
end;

function Tz3DDialog.InitControl(const pControl: Iz3DControl): HRESULT;
var
  i: Integer;
  pDisplayHolder: Pz3DDisplayHolder;
begin
  if (pControl = nil) then
  begin
    Result:= E_INVALIDARG;
    Exit;
  end;

  pControl.Index := ControlCount;
    
  // Look for a default Display entries
  for i:= 0 to Length(m_DefaultDisplays) - 1 do
  begin
    pDisplayHolder := m_DefaultDisplays[i];
    if (pDisplayHolder.ControlType = pControl.GetType)
    then pControl.SetDisplay(pDisplayHolder.DisplayIndex, pDisplayHolder.Display);
  end;

  Result:= pControl.OnInit;
  if z3DFailedTrace(Result) then Exit;

  Result:= S_OK;
end;

function Tz3DDialog.AddControl(const pControl: Iz3DControl): HRESULT;
begin
  Result := InitControl(pControl);
  if FAILED(Result) then
  begin
    Result:= DXTRACE_ERR('Cz3DDialog.InitControl', Result);
    Exit;
  end;
  m_Controls.Add(pControl);
  Result:= S_OK;
end;

function Tz3DDialog.GetLabel(ID: Integer): Iz3DLabel;
begin
  Result:= GetControl(ID, z3dctLabel) as Iz3DLabel;
end;

function Tz3DDialog.GetButton(ID: Integer): Iz3DButton;
begin
  Result:= GetControl(ID, z3dctButton) as Iz3DButton;
end;

function Tz3DDialog.GetCheckBox(ID: Integer): Iz3DCheckBox;
begin
  Result:= GetControl(ID, z3dctCheckBox) as Iz3DCheckBox;
end;

function Tz3DDialog.GetRadioButton(ID: Integer): Iz3DRadioButton;
begin
  Result:= GetControl(ID, z3dctRadioButton) as Iz3DRadioButton;
end;

function Tz3DDialog.GetComboBox(ID: Integer): Iz3DComboBox;
begin
  Result:= GetControl(ID, z3dctComboBox) as Iz3DComboBox;
end;

function Tz3DDialog.GetTrackBar(ID: Integer): Iz3DTrackBar;
begin
  Result:= Tz3DTrackBar(GetControl(ID, z3dctTrackBar));
end;

function Tz3DDialog.GetEditBox(ID: Integer): Iz3DEdit;
begin
  Result:= GetControl(ID, z3dctEdit) as Iz3DEdit;
end;

function Tz3DDialog.GetIMEEditBox(ID: Integer): Iz3DIMEEditBox;
begin
  Result:= GetControl(ID, z3dctIMEEdit) as Iz3DIMEEditBox;
end;

function Tz3DDialog.GetListBox(ID: Integer): Iz3DListBox;
begin
  Result:= GetControl(ID, z3dctListBox) as Iz3DListBox;
end;

function Tz3DDialog.GetControl(ID: Integer): Iz3DControl;
var
  i: Integer;
  pControl: Iz3DControl;
begin
  // Try to find the control with the given ID
  for i:= 0 to ControlCount - 1 do
  begin
    pControl := m_Controls[i] as Iz3DControl;

    if (pControl.ID = ID) then
    begin
      Result:= pControl;
      Exit;
    end;
  end;

  // Not found
  Result:= nil;
end;

function Tz3DDialog.GetControlProp(ID: Integer): Iz3DControl;
begin
  Result := GetControl(ID);
end;

function Tz3DDialog.GetControl(ID: Integer; nControlType: Tz3DControlType): Iz3DControl;
var
  i: Integer;
  pControl: Iz3DControl;
begin
  // Try to find the control with the given ID
  for i:= 0 to ControlCount - 1 do
  begin
    pControl := m_Controls[i] as Iz3DControl;

    if (pControl.ID = ID) and (pControl.GetType = nControlType) then
    begin
      Result:= pControl;
      Exit;
    end;
  end;

  // Not found
  Result:= nil;
end;

function Tz3DDialog.GetNextControl(pControl: Iz3DControl): Iz3DControl;
var
  index: Integer;
  pDialog: Iz3DDialog;
begin
  index := pControl.Index + 1;
  pDialog := pControl.Dialog;

  // Cycle through dialogs in the loop to find the next control. Note
  // that if only one control exists in all looped dialogs it will
  // be the returned 'next' control.
  while (index >= pDialog.ControlCount) do
  begin
    pDialog := pDialog.GetNextDialog;
    index := 0;
  end;

  Result:= pDialog.ControlIndex[index];
end;

function Tz3DDialog.GetPrevControl(pControl: Iz3DControl): Iz3DControl;
var
  index: Integer;
  pDialog: Iz3DDialog;
begin
  index := pControl.Index - 1;

  pDialog := pControl.Dialog;

  // Cycle through dialogs in the loop to find the next control. Note
  // that if only one control exists in all looped dialogs it will
  // be the returned 'previous' control.
  while (index < 0) do
  begin
    pDialog := pDialog.GetPrevDialog;
    if (pDialog = nil) then pDialog := pControl.Dialog;

    index := pDialog.ControlCount - 1;
  end;

  Result:= pDialog.ControlIndex[index];
end;

procedure Tz3DDialog.ClearRadioButtonGroup(nGroup: LongWord);
var
  i: Integer;
  pControl: Iz3DControl;
  pRadioButton: Iz3DRadioButton;
begin
  // Find all radio buttons with the given group number
  for i:= 0 to ControlCount - 1 do
  begin
    pControl := m_Controls[i] as Iz3DControl;

    if (pControl.GetType = z3dctRadioButton) then
    begin
      pRadioButton := pControl as Iz3DRadioButton;

      if (pRadioButton.ButtonGroup = nGroup)
      then pRadioButton.SetChecked(False, False);
    end;
  end;
end;

procedure Tz3DDialog.ClearComboBox(ID: Integer);
var
  pComboBox: Iz3DComboBox;
begin
  pComboBox := GetComboBox(ID);
  if (pComboBox = nil) then Exit;

  pComboBox.RemoveAllItems;
end;

procedure Tz3DDialog.RequestFocus(pControl: Iz3DControl);
begin
  if (s_pControlFocus = pControl) then Exit;

  if (not pControl.CanHaveFocus) then Exit;

  if (s_pControlFocus <> nil) then s_pControlFocus.OnFocusOut;

  pControl.OnFocusIn;
  s_pControlFocus := pControl;
end;

function Tz3DDialog.DrawRect(const pRect: TRect; color: TD3DColor): HRESULT;
var
  rcScreen: TRect;
  vertices: array[0..3] of Tz3DScreenVertex;
  pd3dDevice: IDirect3DDevice9;
  pDecl: IDirect3DVertexDeclaration9;
begin
  rcScreen := pRect;
  OffsetRect(rcScreen, FLeft, FTop);

  // If caption is enabled, offset the Y position by its height.
//  if FCaption then OffsetRect(rcScreen, 0, Manager.Desktop.ThemeSettings.CaptionHeight);

  vertices[0]:= z3DScreenVertex(rcScreen.left  -0.5, rcScreen.top -0.5,    0.5, 1.0, color, 0, 0);
  vertices[1]:= z3DScreenVertex(rcScreen.right -0.5, rcScreen.top -0.5,    0.5, 1.0, color, 0, 0);
  vertices[2]:= z3DScreenVertex(rcScreen.right -0.5, rcScreen.bottom -0.5, 0.5, 1.0, color, 0, 0);
  vertices[3]:= z3DScreenVertex(rcScreen.left  -0.5, rcScreen.bottom -0.5, 0.5, 1.0, color, 0, 0);

  pd3dDevice := z3DCore_GetD3DDevice;

  // Since we're doing our own drawing here we need to flush the sprites
  Manager.Sprite.Flush;
  pd3dDevice.GetVertexDeclaration(pDecl);  // Preserve the sprite's current vertex decl
  pd3dDevice.SetFVF(Tz3DScreenVertex_FVF);

  pd3dDevice.SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG2);
  pd3dDevice.SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG2);

  pd3dDevice.DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, vertices, SizeOf(Tz3DScreenVertex));

  pd3dDevice.SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
  pd3dDevice.SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);

  // Restore the vertex decl
  pd3dDevice.SetVertexDeclaration(pDecl);
  pDecl:= nil;

  Result:= S_OK;
end;

function Tz3DDialog.DrawPolyLine(apPoints: PPoint; nNumPoints: LongWord; color: TD3DColor): HRESULT;
begin
//todo: Don't forget convert this to Pascal
(*  z3D_SCREEN_VERTEX* vertices = new z3D_SCREEN_VERTEX[ nNumPoints ];
  if( vertices == NULL )
      return E_OUTOFMEMORY;

  z3D_SCREEN_VERTEX* pVertex = vertices;
  POINT* pt = apPoints;
  for( UINT i=0; i < nNumPoints; i++ )
  {
      pVertex->x = FLeft + (float) pt->x;
      pVertex->y = FTop + (float) pt->y;
      pVertex->z = 0.5f;
      pVertex->h = 1.0f;
      pVertex->color = color;
      pVertex->tu = 0.0f;
      pVertex->tv = 0.0f;

      pVertex++;
      pt++;
  }

  IDirect3DDevice9* pd3dDevice = Manager.GetD3DDevice();

  // Since we're doing our own drawing here we need to flush the sprites
  Manager.FSprite->Flush();
  IDirect3DVertexDeclaration9 *pDecl = NULL;
  pd3dDevice->GetVertexDeclaration( &pDecl );  // Preserve the sprite's current vertex decl
  pd3dDevice->SetFVF( z3D_SCREEN_VERTEX::FVF );

  pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG2 );
  pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG2 );

  pd3dDevice->DrawPrimitiveUP( D3DPT_LINESTRIP, nNumPoints - 1, vertices, sizeof(z3D_SCREEN_VERTEX) );

  pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_MODULATE );
  pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_MODULATE );

  // Restore the vertex decl
  pd3dDevice->SetVertexDeclaration( pDecl );
  pDecl->Release();

  SAFE_DELETE_ARRAY( vertices ); *)
  Result:= S_OK;
end;

function Tz3DDialog.DrawSprite(pDisplay: Iz3DDisplay; const prcDest: TRect): HRESULT;
var
  rcTexture, rcScreen: TRect;
  pTextureNode: Pz3DTextureNode;
  fScaleX, fScaleY: Single;
  matTransform: TD3DXMatrixA16;
  vPos: TD3DXVector3;
begin
  Result:= S_OK;

  // No need to draw fully transparent layers
  if (pDisplay.TextureColor.Current.a = 0) then Exit;
  // No need to draw ZERO square sprite
  if (RectWidth(prcDest) = 0) or (RectHeight(prcDest) = 0) then Exit;

  rcTexture := pDisplay.TextureRect;

  rcScreen := prcDest;
  OffsetRect(rcScreen, FLeft, FTop);

  // If caption is enabled, offset the Y position by its height.
//  if FCaption then OffsetRect(rcScreen, 0, Manager.Desktop.ThemeSettings.CaptionHeight);

  pTextureNode := GetTexture(pDisplay.GetTexture);
  if (pTextureNode = nil) then
  begin
    Result:= E_FAIL;
    Exit;
  end;

  fScaleX := RectWidth(rcScreen) / RectWidth(rcTexture);
  fScaleY := RectHeight(rcScreen) / RectHeight(rcTexture);

  D3DXMatrixScaling(matTransform, fScaleX, fScaleY, 1.0);

  Manager.Sprite.SetTransform(matTransform);

  vPos:= D3DXVector3(rcScreen.left, rcScreen.top, 0.0);

  vPos.x := vPos.x / fScaleX;
  vPos.y := vPos.y / fScaleY;

  Result:= Manager.Sprite.Draw(pTextureNode.Texture, @rcTexture, nil, @vPos, D3DXColorToDWord(pDisplay.TextureColor.Current));
end;

function Tz3DDialog.CalcTextRect(strText: PWideChar; pDisplay: Iz3DDisplay; prcDest: PRect; nCount: Integer = -1): HRESULT;
var
  pFontNode: Pz3DFontNode;
  dwTextFormat: DWORD;
begin
  pFontNode := GetFont(pDisplay.Font);
  if (pFontNode = nil) then
  begin
    Result:= E_FAIL;
    Exit;
  end;
  
  dwTextFormat := pDisplay.TextFormat or DT_CALCRECT;
  // Since we are only computing the rectangle, we don't need a sprite.
  Result := pFontNode.Font.DrawTextW(nil, strText, nCount, prcDest, dwTextFormat, D3DXColorToDWord(pDisplay.FontColor.Current));
  if FAILED(Result) then Exit;

  Result:= S_OK;
end;

function Tz3DDialog.DrawText(strText: PWideChar; pDisplay: Iz3DDisplay; const rcDest: TRect; bShadow: Boolean = False; nCount: Integer = -1): HRESULT;
var
  rcScreen, rcShadow: TRect;
  matTransform: TD3DXMatrixA16;
  pFontNode: Pz3DFontNode;
  FShadowValue: Byte;
begin
  // No need to draw fully transparent layers
  if (pDisplay.FontColor.Current.a = 0) then
  begin
    Result:= S_OK;
    Exit;
  end;

  rcScreen := rcDest;
  OffsetRect(rcScreen, FLeft, FTop);

  // If caption is enabled, offset the Y position by its height.
//  if FCaption then OffsetRect(rcScreen, 0, Manager.Desktop.ThemeSettings.CaptionHeight);

  //debug
  //DrawRect(rcScreen, D3DCOLOR_ARGB(100, 255, 0, 0));

  D3DXMatrixIdentity(matTransform);
  Manager.Sprite.SetTransform(matTransform);

  pFontNode := GetFont(pDisplay.Font);

  if ((pDisplay.FontColor.Current.r+pDisplay.FontColor.Current.g+pDisplay.FontColor.Current.b) / 3) > 0.5 then
  FShadowValue:= 0 else FShadowValue:= 255;
  if (bShadow) then
  begin
    rcShadow := rcScreen;
    OffsetRect(rcShadow, 1, 1);
    Result := pFontNode.Font.DrawTextW(Manager.Sprite, strText, nCount, @rcShadow, pDisplay.TextFormat, D3DCOLOR_ARGB(Trunc(pDisplay.FontColor.Current.a * 255), FShadowValue, FShadowValue, FShadowValue));
    if FAILED(Result) then Exit;
    rcShadow := rcScreen;
    OffsetRect(rcShadow, -1, -1);
    Result := pFontNode.Font.DrawTextW(Manager.Sprite, strText, nCount, @rcShadow, pDisplay.TextFormat, D3DCOLOR_ARGB(Trunc(pDisplay.FontColor.Current.a * 255), FShadowValue, FShadowValue, FShadowValue));
    if FAILED(Result) then Exit;
    rcShadow := rcScreen;
    OffsetRect(rcShadow, -1, 1);
    Result := pFontNode.Font.DrawTextW(Manager.Sprite, strText, nCount, @rcShadow, pDisplay.TextFormat, D3DCOLOR_ARGB(Trunc(pDisplay.FontColor.Current.a * 255), FShadowValue, FShadowValue, FShadowValue));
    if FAILED(Result) then Exit;
    rcShadow := rcScreen;
    OffsetRect(rcShadow, 1, -1);
    Result := pFontNode.Font.DrawTextW(Manager.Sprite, strText, nCount, @rcShadow, pDisplay.TextFormat, D3DCOLOR_ARGB(Trunc(pDisplay.FontColor.Current.a * 255), FShadowValue, FShadowValue, FShadowValue));
    if FAILED(Result) then Exit;
  end;

  Result := pFontNode.Font.DrawTextW(Manager.Sprite, strText, nCount, @rcScreen, pDisplay.TextFormat, D3DXColorToDWord(pDisplay.FontColor.Current));
  if FAILED(Result) then Exit;

  Result:= S_OK;
end;

procedure Tz3DDialog.SetBackgroundColors(colorAllCorners: TD3DColor);
begin
  SetBackgroundColors(colorAllCorners, colorAllCorners, colorAllCorners, colorAllCorners);
end;

procedure Tz3DDialog.SetBackgroundColors(colorTopLeft, colorTopRight, colorBottomLeft, colorBottomRight: TD3DColor); 
begin
  m_colorTopLeft := colorTopLeft;
  m_colorTopRight := colorTopRight;
  m_colorBottomLeft := colorBottomLeft;
  m_colorBottomRight := colorBottomRight;
end;

procedure Tz3DDialog.SetCaption(const pwszText: PWideChar);
begin
  StringCchCopy(FCaptionStr, SizeOf(FCaptionStr) div SizeOf(FCaptionStr[0]), pwszText);
end;

procedure Tz3DDialog.GetLocation(out Pt: TPoint);
begin
  Pt.x := FLeft; Pt.y := FTop;
end;

procedure Tz3DDialog.SetLocation(x, y: Integer);
begin
  FLeft := x; FTop := y;
end;

procedure Tz3DDialog.SetSize(width, height: Integer);
begin
  FWidth := width; FHeight := height;
end;

procedure Tz3DDialog.SetNextDialog(pNextDialog: Iz3DDialog);
begin
  if (pNextDialog = nil) then pNextDialog := Self;

  FNextDialog := pNextDialog;
  if Assigned(pNextDialog) then FNextDialog.SetPrevDialog(Self);
end;

procedure Tz3DDialog.SetRefreshTime(fTime: Single);
begin
  s_fTimeRefresh := fTime;
end;

procedure Tz3DDialog.ClearFocus;
begin
  if (s_pControlFocus <> nil) then
  begin
    s_pControlFocus.OnFocusOut;
    s_pControlFocus := nil;
  end;

  ReleaseCapture;
end;

procedure Tz3DDialog.FocusDefaultControl;
var
  i: Integer;
  pControl: Iz3DControl;
begin
  // Check for default control in this dialog
  for i:= 0 to ControlCount - 1 do
  begin
    pControl := m_Controls[i] as Iz3DControl;
    if (pControl.Default) then
    begin
      // Remove focus from the current control
      ClearFocus;

      // Give focus to the default control
      s_pControlFocus := pControl;
      s_pControlFocus.OnFocusIn;
      Exit;
    end;
  end;
end;

function Tz3DDialog.OnCycleFocus(bForward: Boolean): Boolean;
var
  pControl: Iz3DControl;
  pDialog: Iz3DDialog;      // pDialog and pLastDialog are used to track wrapping of
  pLastDialog: Iz3DDialog;  // focus from first control to last or vice versa.

  i: Integer;
  d: Integer;
  nLastDialogIndex: Integer;
  nDialogIndex: Integer;
begin
  Result:= True;

  pControl := nil;
  pDialog := nil;
  pLastDialog := nil;

  if (s_pControlFocus = nil) then
  begin
    // If s_pControlFocus is NULL, we focus the first control of first dialog in
    // the case that bForward is true, and focus the last control of last dialog when
    // bForward is false.
    //
    if bForward then
    begin
      // Search for the first control from the start of the dialog
      // array.
      for d := 0 to FManager.DialogCount - 1 do
      begin
        pDialog := FManager.Dialogs[d];
        pLastDialog := FManager.Dialogs[d];
        if Assigned(pDialog) and (pDialog.ControlCount > 0) then
        begin
          pControl := pDialog.ControlIndex[0];
          Break;
        end;
      end;

      if not (Assigned(pDialog) and Assigned(pControl)) then
      begin
        // No dialog has been registered yet or no controls have been
        // added to the dialogs. Cannot proceed.
        Exit;
      end;
    end
    else
    begin
      // Search for the first control from the end of the dialog
      // array.
      for d := FManager.DialogCount - 1 downto 0 do
      begin
        pDialog := FManager.Dialogs[d];
        pLastDialog := FManager.Dialogs[d];
        if Assigned(pDialog) and (ControlCount > 0) then
        begin
          pControl := pDialog.ControlIndex[pDialog.ControlCount - 1];
          Break;
        end;
      end;

      if not (Assigned(pDialog) and Assigned(pControl)) then
      begin
        // No dialog has been registered yet or no controls have been
        // added to the dialogs. Cannot proceed.
        Exit;
      end;
    end;
  end
  else
  if (s_pControlFocus.Dialog <> Self as Iz3DDialog) then
  begin
    // If a control belonging to another dialog has focus, let that other
    // dialog handle this event by returning false.
    //
    Result:= False;
    Exit;
  end
  else
  begin
    // Focused control belongs to this dialog. Cycle to the
    // next/previous control.
    pLastDialog := s_pControlFocus.Dialog;
    if bForward
    then pControl := GetNextControl(s_pControlFocus)
    else pControl := GetPrevControl(s_pControlFocus);
    pDialog := pControl.Dialog;
  end;

  for i := 0 to $ffff - 1 do
  begin
    // If we just wrapped from last control to first or vice versa,
    // set the focused control to NULL. This state, where no control
    // has focus, allows the camera to work.

    nLastDialogIndex := FManager.IndexOf(pLastDialog);
    nDialogIndex := FManager.IndexOf(pDialog);

    if (not bForward and (nLastDialogIndex < nDialogIndex)) or
       (bForward and (nDialogIndex < nLastDialogIndex)) then
    begin
      if Assigned(s_pControlFocus) then s_pControlFocus.OnFocusOut;
      s_pControlFocus := nil;
      Exit;
    end;

    // If we've gone in a full circle then focus doesn't change
    if (pControl = s_pControlFocus) then Exit;

    // If the dialog accepts keybord input and the control can have focus then
    // move focus
    if (pControl.Dialog.IsKeyboardInputEnabled and pControl.CanHaveFocus) then
    begin
      if Assigned(s_pControlFocus) then s_pControlFocus.OnFocusOut;
      s_pControlFocus := pControl;
      s_pControlFocus.OnFocusIn;
      Exit;
    end;

    pLastDialog := pDialog;
    if bForward
    then pControl := GetNextControl(pControl)
    else pControl := GetPrevControl(pControl);
    pDialog := pControl.Dialog;
  end;

  // If we reached this point, the chain of dialogs didn't form a complete loop
  DXTRACE_ERR('Cz3DDialog: Multiple dialogs are improperly chained together', E_FAIL);
  Result:= False;
end;

function Tz3DGUIController.CreateFont(index: LongWord): HRESULT; // ( UINT iFont )
var
  pFontNode: Pz3DFontNode;
begin
  pFontNode := FFontCache[index];

  SafeRelease(pFontNode.Font);

  Result:= D3DXCreateFontW(z3DCore_GetD3DDevice, pFontNode.Height, 0, pFontNode.Weight, 1, False, DEFAULT_CHARSET,
                           OUT_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH or FF_DONTCARE,
                           pFontNode.Name, pFontNode.Font);
  if z3DFailedTrace(Result) then Exit;

  Result:= S_OK;
end;

procedure Tz3DDialog.InitDefaultDisplays;
var
  Display: Iz3DDisplay;
  rcTexture: TRect;
  nScrollBarStartX: Integer;
  nScrollBarStartY: Integer;
begin

  m_colorTopLeft := Manager.Desktop.ThemeSettings.DialogColorTL.D3DColor;
  m_colorTopRight := Manager.Desktop.ThemeSettings.DialogColorTR.D3DColor;
  m_colorBottomLeft := Manager.Desktop.ThemeSettings.DialogColorBL.D3DColor;
  m_colorBottomRight := Manager.Desktop.ThemeSettings.DialogColorBR.D3DColor;
  m_fTimeLastRefresh := 0;

  SetFont(0, Manager.Desktop.ThemeSettings.DefaultFont.Name, z3DFontHeight(Manager.Desktop.ThemeSettings.DefaultFont.Size), Manager.Desktop.ThemeSettings.DefaultFont.Format);
  SetFont(127, Manager.Desktop.ThemeSettings.DefaultFont.Name, z3DFontHeight(Manager.Desktop.ThemeSettings.DefaultFont.Size), Manager.Desktop.ThemeSettings.DefaultFont.Format or FW_BOLD);
  Display:= Tz3DDisplay.Create;

  //-------------------------------------
  // Display for the caption
  //-------------------------------------
  SetRect(rcTexture, 17, 269, 241, 287);
  m_CapDisplay.SetTexture(0, @rcTexture);
  m_CapDisplay.TextureColor.States[ z3dcsNormal ] := D3DCOLOR_ARGB(255, 255, 255, 255);
  m_CapDisplay.FontColor.States[ z3dcsNormal ] := D3DCOLOR_ARGB(255, 255, 255, 255);
  m_CapDisplay.SetFontParams(127, D3DCOLOR_ARGB(255, 255, 255, 255), DT_LEFT or DT_VCENTER);
  // Pre-blend as we don't need to transition the state
  m_CapDisplay.TextureColor.Blend(z3dcsNormal, -1);
  m_CapDisplay.FontColor.Blend(z3dcsNormal, -1);

  //-------------------------------------
  // Tz3DLabel
  //-------------------------------------
  Display.SetFontParams(0, z3DD3DColor(Manager.Desktop.ThemeSettings.DefaultFont.Color), Manager.Desktop.ThemeSettings.DefaultFont.Format);
  Display.FontColor.States[ z3dcsDisabled ] := D3DCOLOR_ARGB(200, 200, 200, 200);

  // Assign the Display
  SetDefaultDisplay(z3dctLabel, 0, Display);


  //-------------------------------------
  // Tz3DButton - Button
  //-------------------------------------
  SetRect(rcTexture, 0, 0, 136, 54);
  Display.SetTexture(0, @rcTexture);
  Display.SetFontParams(0, z3DD3DColor(Manager.Desktop.ThemeSettings.DefaultFont.Color), Manager.Desktop.ThemeSettings.DefaultFont.Format or DT_CENTER);
  Display.TextureColor.States[ z3dcsNormal ] := D3DCOLOR_ARGB(150, 255, 255, 255);
  Display.TextureColor.States[ z3dcsPressed ] := D3DCOLOR_ARGB(200, 255, 255, 255);
  Display.FontColor.States[ z3dcsMouseOver ] := D3DCOLOR_ARGB(255, 0, 0, 0);
    
  // Assign the Display
  SetDefaultDisplay(z3dctButton, 0, Display);
    

  //-------------------------------------
  // Tz3DButton - Fill layer
  //-------------------------------------
  SetRect(rcTexture, 136, 0, 252, 54);
  Display.SetTexture(0, @rcTexture, D3DCOLOR_ARGB(0, 255, 255, 255));
  Display.TextureColor.States[ z3dcsMouseOver ] := D3DCOLOR_ARGB(160, 255, 255, 255);
  Display.TextureColor.States[ z3dcsPressed ] := D3DCOLOR_ARGB(60, 0, 0, 0);
  Display.TextureColor.States[ z3dcsFocus ] := D3DCOLOR_ARGB(30, 255, 255, 255);
    
    
  // Assign the Display
  SetDefaultDisplay(z3dctButton, 1, Display);



  //-------------------------------------
  // Tz3DCheckBox - Box
  //-------------------------------------
  SetRect(rcTexture, 0, 54, 27, 81);
  Display.SetTexture(0, @rcTexture);
  Display.SetFontParams(0, z3DD3DColor(Manager.Desktop.ThemeSettings.CheckBoxFont.Color), Manager.Desktop.ThemeSettings.CheckBoxFont.Format);
  Display.FontColor.States[ z3dcsDisabled ] := D3DCOLOR_ARGB( 200, 200, 200, 200);
  Display.TextureColor.States[ z3dcsNormal ] := D3DCOLOR_ARGB(150, 255, 255, 255);
  Display.TextureColor.States[ z3dcsFocus ] := D3DCOLOR_ARGB(200, 255, 255, 255);
  Display.TextureColor.States[ z3dcsPressed ] := D3DCOLOR_ARGB(255, 255, 255, 255);

  // Assign the Display
  SetDefaultDisplay(z3dctCheckBox, 0, Display);


  //-------------------------------------
  // Tz3DCheckBox - Check
  //-------------------------------------
  SetRect(rcTexture, 27, 54, 54, 81);
  Display.SetTexture(0, @rcTexture);
    
  // Assign the Display
  SetDefaultDisplay(z3dctCheckBox, 1, Display );


  //-------------------------------------
  // Tz3DRadioButton - Box
  //-------------------------------------
  SetRect(rcTexture, 54, 54, 81, 81 );
  Display.SetTexture(0, @rcTexture);
  Display.SetFontParams(0, z3DD3DColor(Manager.Desktop.ThemeSettings.RadioButtonFont.Color), Manager.Desktop.ThemeSettings.RadioButtonFont.Format);
  Display.FontColor.States[ z3dcsDisabled ] := D3DCOLOR_ARGB( 200, 200, 200, 200);
  Display.TextureColor.States[ z3dcsNormal ] := D3DCOLOR_ARGB(150, 255, 255, 255);
  Display.TextureColor.States[ z3dcsFocus ] := D3DCOLOR_ARGB(200, 255, 255, 255);
  Display.TextureColor.States[ z3dcsPressed ] := D3DCOLOR_ARGB(255, 255, 255, 255);

  // Assign the Display
  SetDefaultDisplay(z3dctRadioButton, 0, Display);


  //-------------------------------------
  // Tz3DRadioButton - Check
  //-------------------------------------
  SetRect(rcTexture, 81, 54, 108, 81);
  Display.SetTexture(0, @rcTexture);

  // Assign the Display
  SetDefaultDisplay(z3dctRadioButton, 1, Display);


  //-------------------------------------
  // Tz3DComboBox - Main
  //-------------------------------------
  SetRect(rcTexture, 7, 81, 247, 123);
  Display.SetTexture(0, @rcTexture);
  Display.SetFontParams(0, z3DD3DColor(Manager.Desktop.ThemeSettings.DefaultFont.Color), Manager.Desktop.ThemeSettings.DefaultFont.Format);
  Display.TextureColor.States[ z3dcsNormal ] := D3DCOLOR_ARGB(150, 200, 200, 200);
  Display.TextureColor.States[ z3dcsFocus ] := D3DCOLOR_ARGB(170, 230, 230, 230);
  Display.TextureColor.States[ z3dcsDisabled ] := D3DCOLOR_ARGB(70, 200, 200, 200);
  Display.FontColor.States[ z3dcsMouseOver ] := D3DCOLOR_ARGB(255, 0, 0, 0);
  Display.FontColor.States[ z3dcsPressed ] := D3DCOLOR_ARGB(255, 0, 0, 0);
  Display.FontColor.States[ z3dcsDisabled ] := D3DCOLOR_ARGB(200, 200, 200, 200);

  // Assign the Display
  SetDefaultDisplay(z3dctComboBox, 0, Display);


  //-------------------------------------
  // Tz3DComboBox - Button
  //-------------------------------------
  SetRect(rcTexture, 98, 189, 151, 238);
  Display.SetTexture(0, @rcTexture);
  Display.TextureColor.States[ z3dcsNormal ] := D3DCOLOR_ARGB(150, 255, 255, 255);
  Display.TextureColor.States[ z3dcsPressed ] := D3DCOLOR_ARGB(255, 150, 150, 150);
  Display.TextureColor.States[ z3dcsFocus ] := D3DCOLOR_ARGB(200, 255, 255, 255);
  Display.TextureColor.States[ z3dcsDisabled ] := D3DCOLOR_ARGB(70, 255, 255, 255);

  // Assign the Display
  SetDefaultDisplay(z3dctComboBox, 1, Display);


  //-------------------------------------
  // Tz3DComboBox - Dropdown
  //-------------------------------------
  SetRect(rcTexture, 13, 123, 241, 160);
  Display.SetTexture(0, @rcTexture);
  Display.SetFontParams(0, D3DCOLOR_ARGB(255, 0, 0, 0), DT_LEFT or DT_TOP);

  // Assign the Display
  SetDefaultDisplay(z3dctComboBox, 2, Display);


  //-------------------------------------
  // Tz3DComboBox - Selection
  //-------------------------------------
  SetRect(rcTexture, 12, 163, 239, 183);
  Display.SetTexture(0, @rcTexture);
  Display.SetFontParams(0, D3DCOLOR_ARGB(255, 255, 255, 255), DT_LEFT or DT_TOP);

  // Assign the Display
  SetDefaultDisplay(z3dctComboBox, 3, Display);


  //-------------------------------------
  // Tz3DTrackBar - Track
  //-------------------------------------
  SetRect(rcTexture, 1, 187, 93, 228);
  Display.SetTexture(0, @rcTexture);
  Display.TextureColor.States[ z3dcsNormal ] := D3DCOLOR_ARGB(150, 255, 255, 255);
  Display.TextureColor.States[ z3dcsFocus ] := D3DCOLOR_ARGB(200, 255, 255, 255);
  Display.TextureColor.States[ z3dcsDisabled ] := D3DCOLOR_ARGB(70, 255, 255, 255);

  // Assign the Display
  SetDefaultDisplay(z3dctTrackBar, 0, Display);

  //-------------------------------------
  // Tz3DTrackBar - Button
  //-------------------------------------
  SetRect(rcTexture, 151, 193, 192, 234);
  Display.SetTexture(0, @rcTexture);

  // Assign the Display
  SetDefaultDisplay(z3dctTrackBar, 1, Display);

  //-------------------------------------
  // Tz3DScrollBar - Track
  //-------------------------------------
  nScrollBarStartX := 196;
  nScrollBarStartY := 191;
  SetRect(rcTexture, nScrollBarStartX + 0, nScrollBarStartY + 21, nScrollBarStartX + 22, nScrollBarStartY + 32);
  Display.SetTexture(0, @rcTexture);
  Display.TextureColor.States[ z3dcsDisabled ] := D3DCOLOR_ARGB(255, 200, 200, 200);

  // Assign the Display
  SetDefaultDisplay(z3dctScrollBar, 0, Display);

  //-------------------------------------
  // Tz3DScrollBar - Up Arrow
  //-------------------------------------
  SetRect(rcTexture, nScrollBarStartX + 0, nScrollBarStartY + 1, nScrollBarStartX + 22, nScrollBarStartY + 21);
  Display.SetTexture(0, @rcTexture);
  Display.TextureColor.States[ z3dcsDisabled ] := D3DCOLOR_ARGB(255, 200, 200, 200);

  // Assign the Display
  SetDefaultDisplay(z3dctScrollBar, 1, Display);


  //-------------------------------------
  // Tz3DScrollBar - Down Arrow
  //-------------------------------------
  SetRect(rcTexture, nScrollBarStartX + 0, nScrollBarStartY + 32, nScrollBarStartX + 22, nScrollBarStartY + 53);
  Display.SetTexture(0, @rcTexture);
  Display.TextureColor.States[ z3dcsDisabled ] := D3DCOLOR_ARGB(255, 200, 200, 200);

  // Assign the Display
  SetDefaultDisplay(z3dctScrollBar, 2, Display);

  //-------------------------------------
  // Tz3DScrollBar - Button
  //-------------------------------------
  SetRect(rcTexture, 220, 192, 238, 234);
  Display.SetTexture(0, @rcTexture);

  // Assign the Display
  SetDefaultDisplay(z3dctScrollBar, 3, Display);


  //-------------------------------------
  // Tz3DProgressBar - Background
  //-------------------------------------

  SetRect(rcTexture, 8, 82, 248, 121);
  Display.SetTexture(0, @rcTexture);

  // Assign the Display
  SetDefaultDisplay(z3dctProgressBar, 0, Display);

  //-------------------------------------
  // Tz3DProgressBar - Progress
  //-------------------------------------

  SetRect(rcTexture, 12, 163, 239, 183);
  Display.SetTexture(0, @rcTexture);
  Display.SetFontParams(0, D3DCOLOR_ARGB(255, 255, 255, 255), DT_LEFT or DT_TOP);

  // Assign the Display
  SetDefaultDisplay(z3dctProgressBar, 1, Display);


  //-------------------------------------
  // Tz3DEdit
  //-------------------------------------
  // Display assignment:
  //   0 - text area
  //   1 - top left border
  //   2 - top border
  //   3 - top right border
  //   4 - left border
  //   5 - right border
  //   6 - lower left border
  //   7 - lower border
  //   8 - lower right border

  Display.SetFontParams(0, D3DCOLOR_ARGB(255, 0, 0, 0 ), DT_LEFT or DT_TOP);

  // Assign the style
  SetRect(rcTexture, 14, 90, 241, 113);
  Display.SetTexture(0, @rcTexture);
  SetDefaultDisplay(z3dctEdit, 0, Display);
  SetRect(rcTexture, 8, 82, 14, 90);
  Display.SetTexture(0, @rcTexture);
  SetDefaultDisplay(z3dctEdit, 1, Display);
  SetRect(rcTexture, 14, 82, 241, 90);
  Display.SetTexture(0, @rcTexture);
  SetDefaultDisplay(z3dctEdit, 2, Display);
  SetRect(rcTexture, 241, 82, 246, 90);
  Display.SetTexture(0, @rcTexture);
  SetDefaultDisplay(z3dctEdit, 3, Display);
  SetRect(rcTexture, 8, 90, 14, 113);
  Display.SetTexture(0, @rcTexture);
  SetDefaultDisplay(z3dctEdit, 4, Display);
  SetRect(rcTexture, 241, 90, 246, 113);
  Display.SetTexture(0, @rcTexture);
  SetDefaultDisplay(z3dctEdit, 5, Display);
  SetRect(rcTexture, 8, 113, 14, 121);
  Display.SetTexture(0, @rcTexture);
  SetDefaultDisplay(z3dctEdit, 6, Display);
  SetRect(rcTexture, 14, 113, 241, 121);
  Display.SetTexture(0, @rcTexture);
  SetDefaultDisplay(z3dctEdit, 7, Display);
  SetRect(rcTexture, 241, 113, 246, 121);
  Display.SetTexture(0, @rcTexture);
  SetDefaultDisplay(z3dctEdit, 8, Display);


  //-------------------------------------
  // Tz3DIMEEditBox
  //-------------------------------------

  Display.SetFontParams(0, D3DCOLOR_ARGB(255, 0, 0, 0), DT_LEFT or DT_TOP);

  // Assign the style
  SetRect(rcTexture, 14, 90, 241, 113);
  Display.SetTexture(0, @rcTexture);
  SetDefaultDisplay(z3dctIMEEdit, 0, Display);
  SetRect(rcTexture, 8, 82, 14, 90);
  Display.SetTexture(0, @rcTexture);
  SetDefaultDisplay(z3dctIMEEdit, 1, Display);
  SetRect(rcTexture, 14, 82, 241, 90);
  Display.SetTexture(0, @rcTexture);
  SetDefaultDisplay(z3dctIMEEdit, 2, Display);
  SetRect(rcTexture, 241, 82, 246, 90);
  Display.SetTexture(0, @rcTexture);
  SetDefaultDisplay(z3dctIMEEdit, 3, Display);
  SetRect(rcTexture, 8, 90, 14, 113);
  Display.SetTexture(0, @rcTexture);
  SetDefaultDisplay(z3dctIMEEdit, 4, Display);
  SetRect(rcTexture, 241, 90, 246, 113);
  Display.SetTexture(0, @rcTexture);
  SetDefaultDisplay(z3dctIMEEdit, 5, Display);
  SetRect(rcTexture, 8, 113, 14, 121);
  Display.SetTexture(0, @rcTexture);
  SetDefaultDisplay(z3dctIMEEdit, 6, Display);
  SetRect(rcTexture, 14, 113, 241, 121);
  Display.SetTexture(0, @rcTexture);
  SetDefaultDisplay(z3dctIMEEdit, 7, Display);
  SetRect(rcTexture, 241, 113, 246, 121);
  Display.SetTexture(0, @rcTexture);
  SetDefaultDisplay(z3dctIMEEdit, 8, Display);
  // Display 9 for IME text, and indicator button
  SetRect(rcTexture, 0, 0, 136, 54);
  Display.SetTexture(0, @rcTexture);
  Display.SetFontParams(0, D3DCOLOR_ARGB(255, 0, 0, 0), DT_CENTER or DT_VCENTER );
  SetDefaultDisplay(z3dctIMEEdit, 9, Display);

  //-------------------------------------
  // Tz3DListBox - Main
  //-------------------------------------

  SetRect(rcTexture, 13, 123, 241, 160);
  Display.SetTexture(0, @rcTexture);
  Display.SetFontParams(0, D3DCOLOR_ARGB(255, 0, 0, 0), DT_LEFT or DT_TOP);

  // Assign the Display
  SetDefaultDisplay(z3dctListBox, 0, Display);

  //-------------------------------------
  // Tz3DListBox - Selection
  //-------------------------------------

  SetRect(rcTexture, 16, 166, 240, 183);
  Display.SetTexture(0, @rcTexture);
  Display.SetFontParams(0, D3DCOLOR_ARGB(255, 255, 255, 255), DT_LEFT or DT_TOP);

  // Assign the Display
  SetDefaultDisplay(z3dctListBox, 1, Display);
end;

function Tz3DGUIController.GetFontsCount: Integer;
begin
  Result:= Length(FFontCache);
end;

function Tz3DGUIController.GetTextureNodeCount: Integer;
begin
  Result:= Length(FTextureCache);
end;

{ Tz3DControl }

constructor Tz3DControl.Create(const pDialog: Iz3DDialog = nil);
begin
  inherited Create;

  m_Type := z3dctButton;
  FDialog := pDialog;
  m_ID := 0;
  m_Index := 0;
  FUserData := nil;

  FEnabled := True;
  FVisible := True;
  FMouseOver := False;
  FHasFocus := False;
  FIsDefault := False;

  FDialog := nil;
  SetLength(m_Displays, 0);

  FLeft := 0;
  FTop := 0;
  FWidth := 0;
  FHeight := 0;

  ZeroMemory(@FBoundingBox, SizeOf(FBoundingBox));
end;

destructor Tz3DControl.Destroy;
begin
  inherited;
end;

function Tz3DControl.OnInit: HRESULT;
begin
  Result:= S_OK;
end;

function Tz3DControl.GetHotkey: LongWord;
begin
  Result:= FHotkey;
end;

function Tz3DControl.GetID: Integer;
begin
  Result:= m_ID;
end;

function Tz3DControl.GetIndex: LongWord;
begin
  Result:= m_Index;
end;

procedure Tz3DControl.SetIndex(const Value: LongWord);
begin
  m_Index:= Value;
end;

function Tz3DControl.GetDialog: Iz3DDialog;
begin
  Result:= FDialog;
end;

function Tz3DControl.GetIsDefault: Boolean;
begin
  Result:= FIsDefault;
end;

function Tz3DControl.GetType: Tz3DControlType;
begin
  Result:= m_Type;
end;

function Tz3DControl.GetVisible: Boolean;
begin
  Result:= FVisible;
end;

procedure Tz3DControl.SetHotkey(const Value: LongWord);
begin
  FHotKey:= Value;
end;

procedure Tz3DControl.SetID(const Value: Integer);
begin
  m_ID:= value;
end;

procedure Tz3DControl.SetIsDefault(const Value: Boolean);
begin
  FIsDefault:= Value;
end;

function Tz3DControl.GetUserData: Pointer;
begin
  Result:= FUserData;
end;

procedure Tz3DControl.SetUserData(const Value: Pointer);
begin
  FUserData:= value;
end;

function Tz3DControl.MsgProc(uMsg: LongWord; wParam: WPARAM; lParam: LPARAM): Boolean;
begin
  Result:= False;
end;

function Tz3DControl.HandleKeyboard(uMsg: LongWord; wParam: WPARAM; lParam: LPARAM): Boolean;
begin
  Result:= False;
end;

function Tz3DControl.HandleMouse(uMsg: LongWord; pt: TPoint; wParam: WPARAM; lParam: LPARAM): Boolean;
begin
  Result:= False;
end;

function Tz3DControl.CanHaveFocus: Boolean;
begin
  Result:= False;
end;

procedure Tz3DControl.OnFocusIn;
begin
  FHasFocus := True;
end;

procedure Tz3DControl.OnFocusOut;
begin
  FHasFocus := False;
end;

procedure Tz3DControl.OnMouseEnter;
begin
  FMouseOver := True;
end;

procedure Tz3DControl.OnMouseLeave;
begin
  FMouseOver := False;
end;

function Tz3DControl.ContainsPoint(pt: TPoint): LongBool;
begin
  Result:= PtInRect(FBoundingBox, pt);
end;

procedure Tz3DControl.SetLocation(x, y: Integer);
begin
  FLeft := x; FTop := y;
  UpdateRects;
end;

procedure Tz3DControl.SetSize(width, height: Integer);
begin
  FWidth := width; FHeight := height;
  UpdateRects;
end;

procedure Tz3DControl.SetTextColor(Color: TD3DColor);
var
  pDisplay: Iz3DDisplay;
begin
  pDisplay := m_Displays[0];

  if (pDisplay <> nil) then
    pDisplay.FontColor.States[z3dcsNormal] := Color;
end;

procedure Tz3DControl.SetDisplay(iDisplay: LongWord; const pDisplay: Iz3DDisplay);
var i: Integer;
    pCurDisplay: Iz3DDisplay;
begin
  // Make certain the array is this large
  for i:= Length(m_Displays) to iDisplay do
  begin
    SetLength(m_Displays, i+1);
    m_Displays[i]:= Tz3DDisplay.Create;
  end;
  // Update the data
  pCurDisplay := m_Displays[iDisplay];
  pCurDisplay.Assign(pDisplay);
end;

procedure Tz3DControl.Refresh;
var
  i: Integer;
begin
  FMouseOver := False;
  FHasFocus := False;

  for i:= 0 to Length(m_Displays) - 1 do
    m_Displays[i].Refresh;
end;

procedure Tz3DControl.UpdateRects;
begin
  SetRect(FBoundingBox, FLeft, FTop, FLeft + FWidth, FTop + FHeight);
end;

procedure Tz3DControl.SetEnabled(bEnabled: Boolean);
begin FEnabled := bEnabled; end;

function Tz3DControl.GetEnabled: Boolean;
begin Result:= FEnabled; end;

procedure Tz3DControl.SetVisible(bVisible: Boolean);
begin FVisible := bVisible; end;

function Tz3DControl.GetDisplay(iDisplay: LongWord): Iz3DDisplay;
begin
  Result:= m_Displays[iDisplay];
end;

function Tz3DControl.GetHeight: Integer;
begin
  Result:= FHeight;
end;

function Tz3DControl.GetLeft: Integer;
begin
  Result:= FLeft;
end;

function Tz3DControl.GetTop: Integer;
begin
  Result:= FTop;
end;

function Tz3DControl.GetWidth: Integer;
begin
  Result:= FWidth;
end;

procedure Tz3DControl.SetHeight(const Value: Integer);
begin
  FHeight:= Value;
end;

procedure Tz3DControl.SetLeft(const Value: Integer);
begin
  FLeft:= Value;
end;

procedure Tz3DControl.SetTop(const Value: Integer);
begin
  FTop:= Value;
end;

procedure Tz3DControl.SetWidth(const Value: Integer);
begin
  FWidth:= Value;
end;

procedure Tz3DControl.OnHotkey;
begin
  // Abstract method //
end;

procedure Tz3DControl.Render;
begin
  // Abstract method //
end;

{ Tz3DLabel }

constructor Tz3DLabel.Create(const pDialog: Iz3DDialog = nil);
begin
  inherited;
  m_Type := z3dctLabel;
  FDialog := pDialog;
  ZeroMemory(@m_strText, SizeOf(m_strText));
end;

procedure Tz3DLabel.Render;
var
  iState: Tz3DControlState;
  pDisplay: Iz3DDisplay;
begin
  if not Visible then Exit;

  iState := z3dcsNormal;
  if not Enabled then iState := z3dcsDisabled;

  pDisplay := m_Displays[0];

  pDisplay.FontColor.Blend(iState);

  FDialog.DrawText(m_strText, pDisplay, FBoundingBox, Dialog.Manager.Desktop.ThemeSettings.DefaultFont.Shadow);
end;

function Tz3DLabel.ContainsPoint(pt: TPoint): LongBool;
begin
  Result:= False;
end;

function Tz3DLabel.GetTextCopy(strDest: PWideChar; bufferCount: LongWord): HRESULT;
begin
  // Validate incoming parameters
  if (strDest = nil) or (bufferCount = 0) then
  begin
    Result:= E_INVALIDARG;
    Exit;
  end;

  // Copy the window text
  StringCchCopy(strDest, bufferCount, m_strText);

  Result:= S_OK;
end;

function Tz3DLabel.GetText: PWideChar;
begin
  Result:= m_strText;
end;

procedure Tz3DLabel.SetText(strText: PWideChar);
begin
  if (strText = nil)
  then m_strText[0] := #0
  else StringCchCopy(m_strText, MAX_PATH, strText);
end;

{ Tz3DButton }

constructor Tz3DButton.Create(const pDialog: Iz3DDialog = nil);
begin
  inherited;
  FEnableBackground:= True;
  m_Type := z3dctButton;
  FDialog := pDialog;
  FPressed := False;
  FHotkey := 0;
end;

function Tz3DButton.GetEnableBackground: Boolean;
begin
  Result:= FEnableBackground;
end;

procedure Tz3DButton.SetEnableBackground(const Value: Boolean);
begin
  FEnableBackground:= Value;
end;

function Tz3DButton.HandleKeyboard(uMsg: LongWord; wParam: WPARAM; lParam: LPARAM): Boolean;
begin
  if not Enabled or not Visible then
  begin
    Result:= False;
    Exit;
  end;

  Result:= True;

  case uMsg of
    WM_KEYDOWN:
    begin
      case wParam of
        VK_SPACE:
        begin
          FPressed := True;
          Exit;
        end;
      end;
    end;

    WM_KEYUP:
    begin
      case wParam of
        VK_SPACE:
        begin
          if (FPressed) then
          begin
            FPressed := False;
            FDialog.SendEvent(z3dceButtonClick, True, Self);
          end;
          Exit;
        end;
      end;
    end;

  end; {case}
  Result:= False;
end;

function Tz3DButton.HandleMouse(uMsg: LongWord; pt: TPoint; wParam: WPARAM; lParam: LPARAM): Boolean;
begin
  if not Enabled or not Visible then
  begin
    Result:= False;
    Exit;
  end;

  Result:= True;

  case uMsg of
    WM_LBUTTONDOWN,
    WM_LBUTTONDBLCLK:
    begin
      if ContainsPoint(pt) then
      begin
        // Pressed while inside the control
        FPressed := True;
        SetCapture(z3DCore_GetHWND);

        if (not FHasFocus) then FDialog.RequestFocus(Self);

        Exit;
      end;
    end;

    WM_LBUTTONUP:
    begin
      if (FPressed) then
      begin
        FPressed := False;
        ReleaseCapture;

        if (not FDialog.IsKeyboardInputEnabled) then FDialog.ClearFocus;

        // Button click
        if ContainsPoint(pt) then
          FDialog.SendEvent(z3dceButtonClick, True, Self);

        Exit;
      end;
    end;
  end;

  Result:= False;
end;

function Tz3DButton.GetPressed: Boolean;
begin
  Result:= FPressed;
end;

procedure Tz3DButton.OnHotkey;
begin
  if FDialog.IsKeyboardInputEnabled then FDialog.RequestFocus(Self);
  FDialog.SendEvent(z3dceButtonClick, True, Self);
end;

function Tz3DButton.ContainsPoint(pt: TPoint): LongBool;
begin
  Result:= PtInRect(FBoundingBox, pt);
end;

function Tz3DButton.CanHaveFocus: Boolean;
begin
  Result:= Visible and Enabled;
end;

procedure Tz3DButton.Render;
var
//  nOffsetX, nOffsetY: Integer;
  iState: Tz3DControlState;
  pDisplay: Iz3DDisplay;
  fBlendRate: Single;
  rcWindow: TRect;
begin
//  nOffsetX := 0;
//  nOffsetY := 0;

  iState := z3dcsNormal;

  if not Visible then iState := z3dcsHidden else
  if not Enabled then iState := z3dcsDisabled else
  if Pressed then
  begin
    iState := z3dcsPressed;

//    nOffsetX := 1;
//    nOffsetY := 2;
  end
  else if (FMouseOver) then
  begin
    iState := z3dcsMouseOver;

//    nOffsetX := -1;
//    nOffsetY := -2;
  end
  else if (FHasFocus) then
  begin
    iState := z3dcsFocus;
  end;

  pDisplay := m_Displays[0];

  fBlendRate := IfThen((iState = z3dcsPressed), 0.0, 0.8);

  rcWindow := FBoundingBox;


  // Blend current color
  pDisplay.TextureColor.Blend(iState, fBlendRate);
  pDisplay.FontColor.Blend(iState, fBlendRate);

  if FEnableBackground then
  FDialog.DrawSprite(pDisplay, rcWindow);
  FDialog.DrawText(m_strText, pDisplay, rcWindow, Dialog.Manager.Desktop.ThemeSettings.DefaultFont.Shadow);

  // Main button
  pDisplay := m_Displays[1];


  // Blend current color
  pDisplay.TextureColor.Blend(iState, fBlendRate);
  pDisplay.FontColor.Blend(iState, fBlendRate);

  if FEnableBackground then
  FDialog.DrawSprite(pDisplay, rcWindow);
  FDialog.DrawText(m_strText, pDisplay, rcWindow, Dialog.Manager.Desktop.ThemeSettings.DefaultFont.Shadow);
end;

{ Tz3DCheckBox }

constructor Tz3DCheckBox.Create(const pDialog: Iz3DDialog = nil);
begin
  inherited;
  m_Type := z3dctCheckBox;
  FDialog := pDialog;

  FChecked := False;
end;

function Tz3DCheckBox.HandleKeyboard(uMsg: LongWord; wParam: WPARAM; lParam: LPARAM): Boolean;
begin
  if not Enabled or not Visible then
  begin
    Result:= False;
    Exit;
  end;

  Result:= True;

  case uMsg of
    WM_KEYDOWN:
    begin
      case wParam of
        VK_SPACE:
        begin
          FPressed := True;
          Exit;
        end;
      end;
    end;

    WM_KEYUP:
    begin
      case wParam of
        VK_SPACE:
        begin
          if Pressed then
          begin
            FPressed := false;
            SetCheckedInternal(not Checked, True);
          end;
          Exit;
        end;
      end;
    end;
  end;
  Result:= False;
end;

function Tz3DCheckBox.HandleMouse(uMsg: LongWord; pt: TPoint; wParam: WPARAM; lParam: LPARAM): Boolean;
begin
  if not Enabled or not Visible then
  begin
    Result:= False;
    Exit;
  end;

  Result:= True;

  case uMsg of
    WM_LBUTTONDOWN,
    WM_LBUTTONDBLCLK:
    begin
      if ContainsPoint(pt) then
      begin
        // Pressed while inside the control
        FPressed := True;
        SetCapture(z3DCore_GetHWND);

        if (not FHasFocus) then FDialog.RequestFocus(Self);

        Exit;
      end;
    end;

    WM_LBUTTONUP:
    begin
      if Pressed then
      begin
        FPressed := false;
        ReleaseCapture;

        // Button click
        if ContainsPoint(pt) then SetCheckedInternal(not Checked, True);

        Exit;
      end;
    end;
  end;

  Result:= False;
end;

procedure Tz3DCheckBox.OnHotkey;
begin
  if FDialog.IsKeyboardInputEnabled then FDialog.RequestFocus(Self);
  SetCheckedInternal(not FChecked, True);
end;

function Tz3DCheckBox.GetChecked: Boolean;
begin
  Result:= FChecked;
end;

procedure Tz3DCheckBox.SetChecked(bChecked: Boolean);
begin
  SetCheckedInternal(bChecked, False);
end;

procedure Tz3DCheckBox.SetCheckedInternal(bChecked, bFromInput: Boolean);
begin
  FChecked := bChecked;

  FDialog.SendEvent(z3dcrCheckBoxChange, bFromInput, Self);
end;

function Tz3DCheckBox.ContainsPoint(pt: TPoint): LongBool;
begin
  Result:= PtInRect(FBoundingBox, pt) or
           PtInRect(FButton, pt);
end;

procedure Tz3DCheckBox.UpdateRects;
begin
  inherited;

  FButton := FBoundingBox;
  FButton.right := FButton.left + RectHeight(FButton);

  FText := FBoundingBox;
  Inc(FText.left, Trunc(1.25 * RectWidth(FButton)));
end;

procedure Tz3DCheckBox.Render;
var
  iState: Tz3DControlState;
  pDisplay: Iz3DDisplay;
  fBlendRate: Single;
begin
  iState := z3dcsNormal;

  if not Visible then iState := z3dcsHidden else
  if not Enabled then iState := z3dcsDisabled else
  if Pressed then iState := z3dcsPressed else
  if FMouseOver then iState := z3dcsMouseOver else
  if FHasFocus then iState := z3dcsFocus;

  pDisplay := m_Displays[0];

  fBlendRate := IfThen((iState = z3dcsPressed), 0.0, 0.8);

  pDisplay.TextureColor.Blend(iState, fBlendRate);
  pDisplay.FontColor.Blend(iState, fBlendRate);

  FDialog.DrawSprite(pDisplay, FButton);
  FDialog.DrawText(m_strText, pDisplay, FText, Dialog.Manager.Desktop.ThemeSettings.CheckBoxFont.Shadow);

  if not Checked then iState := z3dcsHidden;

  pDisplay := m_Displays[1];

  pDisplay.TextureColor.Blend(iState, fBlendRate);
  FDialog.DrawSprite(pDisplay, FButton);
end;

{ Tz3DRadioButton }

constructor Tz3DRadioButton.Create(const pDialog: Iz3DDialog = nil);
begin
  inherited;
  m_Type := z3dctRadioButton;
  FDialog := pDialog;
end;

function Tz3DRadioButton.GetButtonGroup: LongWord;
begin
  Result:= FButtonGroup;
end;

function Tz3DRadioButton.HandleKeyboard(uMsg: LongWord; wParam: WPARAM; lParam: LPARAM): Boolean;
begin
  if not Enabled or not Visible then
  begin
    Result:= False;
    Exit;
  end;

  Result:= True;
  
  case uMsg of
    WM_KEYDOWN:
    begin
      case wParam of
        VK_SPACE:
        begin
          FPressed := True;
          Exit;
        end;

        WM_KEYUP:
        begin
          case wParam of
            VK_SPACE:
            begin
              if Pressed then
              begin
                FPressed := False;

                FDialog.ClearRadioButtonGroup(FButtonGroup);
                FChecked := not FChecked;

                FDialog.SendEvent(z3dceRadioButtonChange, True, Self);
              end;
              Exit;
            end;
          end;
        end;
      end;
    end;
  end;
  Result:= False;
end;

function Tz3DRadioButton.HandleMouse(uMsg: LongWord; pt: TPoint; wParam: WPARAM; lParam: LPARAM): Boolean;
begin
  if not Enabled or not Visible then
  begin
    Result:= False;
    Exit;
  end;

  Result:= True;

  case uMsg of
    WM_LBUTTONDOWN,
    WM_LBUTTONDBLCLK:
    begin
      if ContainsPoint(pt) then
      begin
        // Pressed while inside the control
        FPressed := true;
        SetCapture(z3DCore_GetHWND);

        if (not FHasFocus) then FDialog.RequestFocus(Self);
        Exit;
      end;
    end;

    WM_LBUTTONUP:
    begin
      if Pressed then
      begin
        FPressed := False;
        ReleaseCapture;

        // Button click
        if ContainsPoint(pt) then
        begin
          FDialog.ClearRadioButtonGroup(FButtonGroup);
          FChecked := not FChecked;

          FDialog.SendEvent(z3dceRadioButtonChange, True, Self);
        end;
        Exit;
      end;
    end;
  end;

  Result:= false;
end;

procedure Tz3DRadioButton.OnHotkey;
begin
  if FDialog.IsKeyboardInputEnabled then FDialog.RequestFocus(Self);
  SetCheckedInternal(True, True, True);
end;

procedure Tz3DRadioButton.SetChecked(bChecked: Boolean);
begin
  SetCheckedInternal(bChecked, True, False);
end;

procedure Tz3DRadioButton.SetButtonGroup(const Value: LongWord);
begin
  FButtonGroup:= Value;
end;

procedure Tz3DRadioButton.SetChecked(bChecked: Boolean; bClearGroup: Boolean = True);
begin
  SetCheckedInternal(bChecked, bClearGroup, False);
end;

procedure Tz3DRadioButton.SetCheckedInternal(bChecked, bClearGroup, bFromInput: Boolean);
begin
  if (bChecked and bClearGroup) then FDialog.ClearRadioButtonGroup(FButtonGroup);
  FChecked := bChecked;
  FDialog.SendEvent(z3dceRadioButtonChange, bFromInput, Self);
end;

function Tz3DDialog.GetControlIndex(AIndex: Integer): Iz3DControl;
begin
  Result:= m_Controls[AIndex] as Iz3DControl;
end;

function Tz3DDialog.HasFocus: Boolean;
begin
  Result:= Manager.IndexOf(Self) = Manager.DialogCount-1;
end;

procedure Tz3DDialog.SetFocus;
begin
  if HasFocus then Exit;
  Manager.BringToFront(Self);
end;

procedure Tz3DDialog.Hide;
begin
  FVisible:= False;
  FManager.ModalMode:= False;
end;

procedure Tz3DDialog.Show;
begin
  FVisible:= True;
end;

procedure Tz3DDialog.ShowModal;
begin
  ModalResult:= z3dmdkNone;
  FManager.ModalMode:= True;
  FVisible:= True;
  FModalMode:= True;
  while ModalResult = z3dmdkNone do z3DCore_ProcessMessages;
end;

function Tz3DDialog.GetModalMode: Boolean;
begin
  Result:= FModalMode;
end;

function Tz3DDialog.GetEnableBackground: Boolean;
begin
  Result:= FEnableBackground;
end;

procedure Tz3DDialog.SetEnableBackground(const Value: Boolean);
begin
  FEnableBackground:= Value;
end;

function Tz3DDialog.GetEnableBorder: Boolean;
begin
  Result:= FEnableBorder;
end;

procedure Tz3DDialog.SetEnableBorder(const Value: Boolean);
begin
  FEnableBorder:= Value;
end;

function Tz3DDialog.GetDesktopOnly: Boolean;
begin
  Result:= FDesktopOnly;
end;

procedure Tz3DDialog.SetDesktopOnly(const Value: Boolean);
begin
  FDesktopOnly:= Value;
end;

{ Tz3DScrollBar }

constructor Tz3DScrollBar.Create(const pDialog: Iz3DDialog);
begin
  inherited;
  m_Type := z3dctScrollBar;
  FDialog := pDialog;

  FShowThumb := True;
  FDrag := False;

  SetRect(FUpButton, 0, 0, 0, 0);
  SetRect(FDownButton, 0, 0, 0, 0);
  SetRect(FTrack, 0, 0, 0, 0);
  SetRect(FThumb, 0, 0, 0, 0);
  FPosition := 0;
  FPageSize := 1;
  FStart := 0;
  FEnd := 1;
  m_Arrow := CLEAR;
  m_dArrowTS := 0.0;
end;

procedure Tz3DScrollBar.UpdateRects;
begin
  inherited;

  SetRect(FUpButton, FBoundingBox.left, FBoundingBox.top,
                        FBoundingBox.right, FBoundingBox.top + RectWidth(FBoundingBox));
  SetRect(FDownButton, FBoundingBox.left, FBoundingBox.bottom - RectWidth(FBoundingBox),
                          FBoundingBox.right, FBoundingBox.bottom);
  SetRect(FTrack, FUpButton.left, FUpButton.bottom,
                     FDownButton.right, FDownButton.top);
  FThumb.left := FUpButton.left;
  FThumb.right := FUpButton.right;

  UpdateThumbRect;
end;

// Compute the dimension of the scroll thumb
procedure Tz3DScrollBar.UpdateThumbRect;
var
  nThumbHeight: Integer;
  nMaxPosition: Integer;
begin
  if (FEnd - FStart > FPageSize) then
  begin
    nThumbHeight := Max(RectHeight(FTrack) * FPageSize div (FEnd - FStart), SCROLLBAR_MINTHUMBSIZE);
    nMaxPosition := FEnd - FStart - FPageSize;
    FThumb.top := FTrack.top + (FPosition - FStart) * (RectHeight(FTrack) - nThumbHeight) div nMaxPosition;
    FThumb.bottom := FThumb.top + nThumbHeight;
    FShowThumb := True;
  end else
  begin
    // No content to scroll
    FThumb.bottom := FThumb.top;
    FShowThumb := False;
  end;
end;

function Tz3DScrollBar.GetPageSize: Integer;
begin
  Result:= FPageSize;
end;

function Tz3DScrollBar.GetPosition: Integer;
begin
  Result:= FPosition;
end;

procedure Tz3DScrollBar.Scroll(nDelta: Integer);
begin
  Inc(FPosition, nDelta);
  Cap;
  UpdateThumbRect;
end;

procedure Tz3DScrollBar.ShowItem(nIndex: Integer);
begin
  // Cap the index
  if (nIndex < 0) then nIndex := 0;
  if (nIndex >= FEnd) then nIndex := FEnd - 1;

  // Adjust position
  if (FPosition > nIndex) then FPosition := nIndex else
  if (FPosition + FPageSize <= nIndex) then FPosition := nIndex - FPageSize + 1;

  UpdateThumbRect;
end;

function Tz3DScrollBar.HandleKeyboard(uMsg: LongWord; wParam: WPARAM;
  lParam: LPARAM): Boolean;
begin
  Result:= False;
end;

var
  ThumbOffsetY: Integer = 0;

function Tz3DScrollBar.HandleMouse(uMsg: LongWord; pt: TPoint;
  wParam: WPARAM; lParam: LPARAM): Boolean;
var
  nMaxFirstItem: Integer;
  nMaxThumb: Integer;
begin
  Result:= True;

  m_LastMouse := pt;
  case uMsg of
    WM_LBUTTONDOWN,
    WM_LBUTTONDBLCLK:
    begin
      // Check for click on up button
      if PtInRect(FUpButton, pt) then
      begin
        SetCapture(z3DCore_GetHWND);
        if (FPosition > FStart) then Dec(FPosition);
        UpdateThumbRect;
        m_Arrow := CLICKED_UP;
        m_dArrowTS := z3DCore_GetTime;
        Exit;
      end;

      // Check for click on down button
      if PtInRect(FDownButton, pt) then
      begin
        SetCapture(z3DCore_GetHWND);
        if (FPosition + FPageSize < FEnd) then Inc(FPosition);
        UpdateThumbRect;
        m_Arrow := CLICKED_DOWN;
        m_dArrowTS := z3DCore_GetTime;
        Exit;
      end;

      // Check for click on thumb
      if PtInRect(FThumb, pt) then
      begin
        SetCapture(z3DCore_GetHWND);
        FDrag := True;
        ThumbOffsetY := pt.y - FThumb.top;
        Exit;
      end;

      // Check for click on track
      if (FThumb.left <= pt.x) and (FThumb.right > pt.x) then
      begin
        SetCapture(z3DCore_GetHWND);
        if (FThumb.top > pt.y) and
           (FTrack.top <= pt.y) then
        begin
          Scroll(-(FPageSize - 1));
          Exit;
        end else
        if (FThumb.bottom <= pt.y) and
           (FTrack.bottom > pt.y) then
        begin
          Scroll(FPageSize - 1);
          Exit;
        end;
      end;
    end;

    WM_LBUTTONUP:
    begin
      FDrag := False;
      ReleaseCapture;
      UpdateThumbRect;
      m_Arrow := CLEAR;
    end;

    WM_MOUSEMOVE:
    begin
      if FDrag then
      begin
        Inc(FThumb.bottom, pt.y - ThumbOffsetY - FThumb.top);
        FThumb.top := pt.y - ThumbOffsetY;
        if (FThumb.top < FTrack.top) then OffsetRect(FThumb, 0, FTrack.top - FThumb.top) else
        if (FThumb.bottom > FTrack.bottom) then OffsetRect(FThumb, 0, FTrack.bottom - FThumb.bottom);

        // Compute first item index based on thumb position
        nMaxFirstItem := FEnd - FStart - FPageSize;  // Largest possible index for first item
        nMaxThumb := RectHeight(FTrack) - RectHeight(FThumb);  // Largest possible thumb position from the top

        FPosition := FStart +
                      ( FThumb.top - FTrack.top +
                        nMaxThumb div (nMaxFirstItem * 2) ) * // Shift by half a row to avoid last row covered by only one pixel
                      nMaxFirstItem  div nMaxThumb;

        Exit;
      end;
    end;
  end;

  Result:= False;
end;

function Tz3DScrollBar.MsgProc(uMsg: LongWord; wParam: WPARAM; lParam: LPARAM): Boolean;
begin
  if (WM_CAPTURECHANGED = uMsg) then
  begin
    // The application just lost mouse capture. We may not have gotten
    // the WM_MOUSEUP message, so reset FDrag here.
    if (THandle(lParam) <> z3DCore_GetHWND) then FDrag := False;
  end;

  Result:= False;
end;

procedure Tz3DScrollBar.Render;
var
  dCurrTime: Double;
  iState: Tz3DControlState;
  fBlendRate: Single;
  pDisplay: Iz3DDisplay;
begin
  inherited;
  // Check if the arrow button has been held for a while.
  // If so, update the thumb position to simulate repeated
  // scroll.
  if (m_Arrow <> CLEAR) then
  begin
    dCurrTime := z3DCore_GetTime;
    if PtInRect(FUpButton, m_LastMouse) then
    begin
      case m_Arrow of
        CLICKED_UP:
          if (SCROLLBAR_ARROWCLICK_DELAY < dCurrTime - m_dArrowTS) then
          begin
            Scroll(-1);
            m_Arrow := HELD_UP;
            m_dArrowTS := dCurrTime;
          end;

        HELD_UP:
          if (SCROLLBAR_ARROWCLICK_REPEAT < dCurrTime - m_dArrowTS) then
          begin
            Scroll(-1);
            m_dArrowTS := dCurrTime;
          end;
      end; 
    end else
    if PtInRect(FDownButton, m_LastMouse) then
    begin
      case m_Arrow of
        CLICKED_DOWN:
          if (SCROLLBAR_ARROWCLICK_DELAY < dCurrTime - m_dArrowTS) then
          begin
            Scroll(1);
            m_Arrow := HELD_DOWN;
            m_dArrowTS := dCurrTime;
          end;

        HELD_DOWN:
          if (SCROLLBAR_ARROWCLICK_REPEAT < dCurrTime - m_dArrowTS) then
          begin
            Scroll(1);
            m_dArrowTS := dCurrTime;
          end;
      end;
    end;
  end;

  iState := z3dcsNormal;

  if not FVisible then iState := z3dcsHidden
  else if (not FEnabled or not FShowThumb) then iState := z3dcsDisabled
  else if FMouseOver then iState := z3dcsMouseOver
  else if FHasFocus  then iState := z3dcsFocus;

  fBlendRate := IfThen(iState = z3dcsPressed, 0.0, 0.8);

  // Background track layer
  pDisplay := m_Displays[0];

  // Blend current color
  pDisplay.TextureColor.Blend(iState, fBlendRate);
  FDialog.DrawSprite(pDisplay, FTrack);

  // Up Arrow
  pDisplay := m_Displays[1];

  // Blend current color
  pDisplay.TextureColor.Blend(iState, fBlendRate);
  FDialog.DrawSprite(pDisplay, FUpButton);

  // Down Arrow
  pDisplay := m_Displays[2];

  // Blend current color
  pDisplay.TextureColor.Blend(iState, fBlendRate);
  FDialog.DrawSprite(pDisplay, FDownButton);

  // Thumb button
  pDisplay := m_Displays[3];

  // Blend current color
  pDisplay.TextureColor.Blend(iState, fBlendRate);
  FDialog.DrawSprite(pDisplay, FThumb);
end;


procedure Tz3DScrollBar.SetTrackRange(nStart, nEnd: Integer);
begin
  FStart := nStart;
  FEnd := nEnd;
  Cap;
  UpdateThumbRect;
end;

procedure Tz3DScrollBar.Cap;
begin
  if (FPosition < FStart) or
     (FEnd - FStart <= FPageSize) then
  begin
    FPosition := FStart;
  end else
  if (FPosition + FPageSize > FEnd)
  then FPosition := FEnd - FPageSize;
end;

procedure Tz3DScrollBar.SetPageSize(nPageSize: Integer);
begin
  FPageSize := nPageSize;
  Cap;
  UpdateThumbRect;
end;


procedure Tz3DScrollBar.SetTrackPos(nPosition: Integer);
begin
  FPosition := nPosition;
  Cap;
  UpdateThumbRect;
end;

{ Tz3DListBox }

constructor Tz3DListBox.Create(const pDialog: Iz3DDialog);
begin
  inherited;
  m_ScrollBar:= Tz3DScrollBar.Create(pDialog);
  m_Items:= TList.Create;
  m_Type := z3dctListBox;
  FDialog := pDialog;
  FStyle := z3dlbsNormal;
  FSBWidth := 16;
  FSelected := -1;
  FSelStart := 0;
  FDrag := false;
  FBorder := 6;
  FMargin := 5;
  FTextHeight := 0;
end;

destructor Tz3DListBox.Destroy;
begin
  RemoveAllItems;
  FreeAndNil(m_Items);
  FreeAndNil(m_ScrollBar);
  inherited;
end;

procedure Tz3DListBox.UpdateRects;
var
  pFontNode: Pz3DFontNode;
begin
  inherited;

  FSelection := FBoundingBox;
  Dec(FSelection.right, FSBWidth);
  InflateRect(FSelection, -FBorder, -FBorder);
  FText := FSelection;
  InflateRect(FText, -FMargin, 0);

  // Update the scrollbar's rects
  m_ScrollBar.SetLocation(FBoundingBox.right - FSBWidth, FBoundingBox.top);
  m_ScrollBar.SetSize(FSBWidth, FHeight);
  pFontNode := FDialog.Manager.Fonts[m_Displays[0].Font];
  if (pFontNode <> nil) and (pFontNode.Height <> 0) then
  begin
    m_ScrollBar.SetPageSize(RectHeight(FText) div pFontNode.Height);

    // The selected item may have been scrolled off the page.
    // Ensure that it is in page again.
    m_ScrollBar.ShowItem(FSelected);
  end;
end;

function Tz3DListBox.AddItem(const wszText: PWideChar; pData: Pointer): HRESULT;
var
  pNewItem: Pz3DListBoxItem;
begin
  Result:= S_OK;
  try
    New(pNewItem);

    StringCchCopy(pNewItem.strText, 256, wszText);
    pNewItem.pData := pData;
    SetRect(pNewItem.rcActive, 0, 0, 0, 0);
    pNewItem.bSelected := False;

    m_Items.Add(pNewItem);
    m_ScrollBar.SetTrackRange(0, m_Items.Count);
  except
    Dispose(pNewItem);
    Result:= E_OUTOFMEMORY;
    Exit;
  end;
end;

function Tz3DListBox.InsertItem(nIndex: Integer; const wszText: PWideChar;
  pData: Pointer): HRESULT;
var
  pNewItem: Pz3DListBoxItem;
begin
  Result:= S_OK;
  try
    New(pNewItem);

    StringCchCopy(pNewItem.strText, 256, wszText);
    pNewItem.pData := pData;
    SetRect(pNewItem.rcActive, 0, 0, 0, 0);
    pNewItem.bSelected := False;

    m_Items.Insert(nIndex, pNewItem);
    m_ScrollBar.SetTrackRange(0, m_Items.Count);
  except
    Dispose(pNewItem);
    Result:= E_OUTOFMEMORY;
    Exit;
  end;
end;

procedure Tz3DListBox.RemoveItem(nIndex: Integer);
var
  pItem: Pz3DListBoxItem;
begin
  if (nIndex < 0) or (nIndex >= m_Items.Count) then Exit;

  pItem := Pz3DListBoxItem(m_Items[nIndex]);
  Dispose(pItem);
  m_Items.Delete(nIndex); // Remove(nIndex);

  m_ScrollBar.SetTrackRange(0, m_Items.Count);
  if (FSelected >= m_Items.Count) then FSelected := m_Items.Count - 1;

  FDialog.SendEvent(z3dceListBoxBeginSelect, True, Self);
end;

procedure Tz3DListBox.RemoveItemByText(wszText: PWideChar);
begin
end;

procedure Tz3DListBox.RemoveItemByData(pData: Pointer);
begin
end;

procedure Tz3DListBox.RemoveAllItems;
var
  i: Integer;
  pItem: Pz3DListBoxItem;
begin
  for i := 0 to m_Items.Count - 1 do
  begin
    pItem := Pz3DListBoxItem(m_Items[i]);
    Dispose(pItem);
  end;

  m_Items.Clear; // RemoveAll;
  m_ScrollBar.SetTrackRange(0, 1);
end;

function Tz3DListBox.GetItem(nIndex: Integer): Pz3DListBoxItem;
begin
  Result:= nil;
  if (nIndex < 0) or (nIndex >= m_Items.Count) then Exit;
  Result:= m_Items[nIndex];
end;

// For single-selection listbox, returns the index of the selected item.
// For multi-selection, returns the first selected item after the nPreviousSelected position.
// To search for the first selected item, the app passes -1 for nPreviousSelected.  For
// subsequent searches, the app passes the returned index back to GetSelectedIndex as.
// nPreviousSelected.
// Returns -1 on error or if no item is selected.
function Tz3DListBox.GetSelectedIndex(nPreviousSelected: Integer): Integer;
var
  i: Integer;
  pItem: Pz3DListBoxItem;
begin
  Result:= -1;
  if (nPreviousSelected < -1) then Exit;

  if (FStyle = z3dlbsMultiSelect) then
  begin
    // Multiple selection enabled. Search for the next item with the selected flag.
    for i := nPreviousSelected + 1 to m_Items.Count - 1 do
    begin
      pItem := Pz3DListBoxItem(m_Items[i]);

      if (pItem.bSelected) then
      begin
        Result:= i;
        Exit;
      end;
    end;

    Result:= -1;
  end else
  begin
    // Single selection
    Result:= FSelected;
  end;
end;

procedure Tz3DListBox.SelectItem(nNewIndex: Integer);
var
  nOldSelected: Integer;
begin
  // If no item exists, do nothing.
  if (m_Items.Count = 0) then Exit;

  nOldSelected := FSelected;

  // Adjust FSelected
  FSelected := nNewIndex;

  // Perform capping
  if (FSelected < 0) then FSelected := 0;
  if (FSelected >= m_Items.Count) then FSelected := m_Items.Count - 1;

  if (nOldSelected <> FSelected) then
  begin
    if (FStyle = z3dlbsMultiSelect) then
    begin
      Pz3DListBoxItem(m_Items[FSelected])^.bSelected := True;
    end;

    // Update selection start
    FSelStart := FSelected;

    // Adjust scroll bar
    m_ScrollBar.ShowItem(FSelected);
  end;

  FDialog.SendEvent(z3dceListBoxBeginSelect, True, Self);
end;

function Tz3DListBox.HandleKeyboard(uMsg: LongWord; wParam: WPARAM; lParam: LPARAM): Boolean;
var
  nOldSelected: Integer;
  i, n: Integer;
  nEnd: Integer;
begin
  Result:= True;
  if (not FEnabled or not FVisible) then
  begin
    Result:= False;
    Exit;
  end;

  // Let the scroll bar have a chance to handle it first
  if m_ScrollBar.HandleKeyboard(uMsg, wParam, lParam) then Exit;

  case uMsg of
    WM_KEYDOWN:
    begin
      case wParam of
        VK_UP, VK_DOWN,
        VK_NEXT, VK_PRIOR,
        VK_HOME, VK_END:
        begin
          // If no item exists, do nothing.
          if (m_Items.Count = 0) then Exit;
          nOldSelected := FSelected;

          // Adjust FSelected
          case wParam of
            VK_UP:    Dec(FSelected);
            VK_DOWN:  Inc(FSelected);
            VK_NEXT:  Inc(FSelected, m_ScrollBar.PageSize - 1);
            VK_PRIOR: Dec(FSelected, m_ScrollBar.PageSize - 1);
            VK_HOME:  FSelected := 0;
            VK_END:   FSelected := m_Items.Count - 1;
          end;

          // Perform capping
          if (FSelected < 0) then FSelected := 0;
          if (FSelected >= m_Items.Count) then FSelected := m_Items.Count - 1;

          if (nOldSelected <> FSelected) then
          begin
            if (FStyle = z3dlbsMultiSelect) then
            begin
              // Multiple selection

              // Clear all selection
              for i := 0 to m_Items.Count - 1 do
              begin
                Pz3DListBoxItem(m_Items[i]).bSelected := False;
              end;

              if (GetKeyState(VK_SHIFT) < 0) then
              begin
                // Select all items from FSelStart to
                // FSelected
                nEnd := Max(FSelStart, FSelected);

                for n := Min(FSelStart, FSelected) to nEnd - 1 do
                  Pz3DListBoxItem(m_Items[n]).bSelected := true;
              end else
              begin
                Pz3DListBoxItem(m_Items[FSelected]).bSelected := True;

                // Update selection start
                FSelStart := FSelected;
              end;
            end else
              FSelStart := FSelected;

            // Adjust scroll bar
            m_ScrollBar.ShowItem(FSelected);

            // Send notification
            FDialog.SendEvent(z3dceListBoxBeginSelect, True, Self);
          end;
          Exit;
        end;

        // Space is the hotkey for double-clicking an item.
        //
        VK_SPACE:
        begin
          FDialog.SendEvent(z3dceListBoxDblClick, True, Self);
          Exit;
        end;
      end;
    end;
  end;

  Result:= False;
end;

function Tz3DListBox.HandleMouse(uMsg: LongWord; pt: TPoint;
  wParam: WPARAM; lParam: LPARAM): Boolean;
var
  nClicked: Integer;
  pSelItem: Pz3DListBoxItem;
  nBegin, nEnd: Integer;
  i, n: Integer;
  bLastSelected: Boolean;
  nItem: Integer;
  uLines: LongWord;
  nScrollAmount: Integer;  
begin
  Result:= True;
  if (not FEnabled or not FVisible) then
  begin
    Result:= False;
    Exit;
  end;

  // First acquire focus
  if (WM_LBUTTONDOWN = uMsg) and (not FHasFocus)
  then FDialog.RequestFocus(Self);

  // Let the scroll bar handle it first.
  if m_ScrollBar.HandleMouse( uMsg, pt, wParam, lParam) then Exit;

  case uMsg of
    WM_LBUTTONDOWN,
    WM_LBUTTONDBLCLK:
    begin
      // Check for clicks in the text area
      if (m_Items.Count > 0) and PtInRect(FSelection, pt) then
      begin
        // Compute the index of the clicked item

        if (FTextHeight <> 0)
        then nClicked := m_ScrollBar.TrackPos + (pt.y - FText.top) div FTextHeight
        else nClicked := -1;

        // Only proceed if the click falls on top of an item.

        if (nClicked >= m_ScrollBar.TrackPos) and
           (nClicked < m_Items.Count) and
           (nClicked < m_ScrollBar.TrackPos + m_ScrollBar.PageSize) then
        begin
          SetCapture(z3DCore_GetHWND);
          FDrag := True;

          // If this is a double click, fire off an event and exit
          // since the first click would have taken care of the selection
          // updating.
          if (uMsg = WM_LBUTTONDBLCLK) then
          begin
            FDialog.SendEvent(z3dceListBoxDblClick, True, Self);
            Exit;
          end;

          FSelected := nClicked;
          if (wParam and MK_SHIFT = 0) then FSelStart := FSelected;

          // If this is a multi-selection listbox, update per-item
          // selection data.
          if (FStyle = z3dlbsMultiSelect) then
          begin
            pSelItem := Pz3DListBoxItem(m_Items[FSelected]);

            // Determine behavior based on the state of Shift and Ctrl
            if (wParam and (MK_SHIFT or MK_CONTROL) = MK_CONTROL) then
            begin
              // Control click. Reverse the selection of this item.
              pSelItem.bSelected := not pSelItem.bSelected;
            end else
            if (wParam and (MK_SHIFT or MK_CONTROL) = MK_SHIFT) then
            begin
              // Shift click. Set the selection for all items
              // from last selected item to the current item.
              // Clear everything else.

              nBegin := Min(FSelStart, FSelected);
              nEnd := Max(FSelStart, FSelected);

              for i := 0 to nBegin - 1 do
                Pz3DListBoxItem(m_Items[i]).bSelected := False;

              for i := nEnd + 1 to m_Items.Count - 1 do
                Pz3DListBoxItem(m_Items[i]).bSelected := False;

              for i := nBegin to nEnd do
                Pz3DListBoxItem(m_Items[i]).bSelected := True;

            end else
            if (wParam and (MK_SHIFT or MK_CONTROL) = (MK_SHIFT or MK_CONTROL)) then
            begin
              // Control-Shift-click.

              // The behavior is:
              //   Set all items from FSelStart to FSelected to
              //     the same state as FSelStart, not including FSelected.
              //   Set FSelected to selected.

              nBegin := Min(FSelStart, FSelected);
              nEnd := Max(FSelStart, FSelected);

              // The two ends do not need to be set here.

              bLastSelected := Pz3DListBoxItem(m_Items[FSelStart]).bSelected;
              for i := nBegin + 1 to nEnd - 1 do
                Pz3DListBoxItem(m_Items[i]).bSelected := bLastSelected;

              pSelItem.bSelected := True;

              // Restore FSelected to the previous value
              // This matches the Windows behavior

              FSelected := FSelStart;
            end else
            begin
              // Simple click.  Clear all items and select the clicked
              // item.

              for i := 0 to m_Items.Count - 1 do
                Pz3DListBoxItem(m_Items[i]).bSelected := False;

              pSelItem.bSelected := True;
            end;
          end;  // End of multi-selection case

          FDialog.SendEvent(z3dceListBoxBeginSelect, True, Self);
        end;

        Exit;
      end;
    end;

    WM_LBUTTONUP:
    begin
      ReleaseCapture;
      FDrag := False;

      if (FSelected <> -1) then
      begin
        // Set all items between FSelStart and FSelected to
        // the same state as FSelStart
        nEnd := Max(FSelStart, FSelected);

        for n := Min(FSelStart, FSelected) + 1 to nEnd - 1 do
          Pz3DListBoxItem(m_Items[n]).bSelected := Pz3DListBoxItem(m_Items[FSelStart]).bSelected;
        Pz3DListBoxItem(m_Items[FSelected]).bSelected := Pz3DListBoxItem(m_Items[FSelStart]).bSelected;

        // If FSelStart and FSelected are not the same,
        // the user has dragged the mouse to make a selection.
        // Notify the application of this.
        if (FSelStart <> FSelected)
        then FDialog.SendEvent(z3dceListBoxBeginSelect, True, Self);

        FDialog.SendEvent(z3dceListBoxEndSelect, True, Self);
      end;
      Result:= False;
      Exit;
    end;

    WM_MOUSEMOVE:
    if FDrag then
    begin
      // Compute the index of the item below cursor

      if (FTextHeight <> 0) 
      then nItem := m_ScrollBar.TrackPos + (pt.y - FText.top) div FTextHeight
      else nItem := -1;

      // Only proceed if the cursor is on top of an item.

      if (nItem >= m_ScrollBar.TrackPos) and
         (nItem < m_Items.Count) and
         (nItem < m_ScrollBar.TrackPos + m_ScrollBar.PageSize) then
      begin
        FSelected := nItem;
        FDialog.SendEvent(z3dceListBoxBeginSelect, True, Self);
      end else
      if (nItem < m_ScrollBar.TrackPos) then
      begin
        // User drags the mouse above window top
        m_ScrollBar.Scroll(-1);
        FSelected := m_ScrollBar.TrackPos;
        FDialog.SendEvent(z3dceListBoxBeginSelect, True, Self);
      end else
      if (nItem >= m_ScrollBar.TrackPos + m_ScrollBar.PageSize) then
      begin
        // User drags the mouse below window bottom
        m_ScrollBar.Scroll(1);
        FSelected := Min(m_Items.Count, m_ScrollBar.TrackPos + m_ScrollBar.PageSize ) - 1;
        FDialog.SendEvent(z3dceListBoxBeginSelect, True, Self);
      end;
    end;

    WM_MOUSEWHEEL:
    begin
      SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, @uLines, 0);
      nScrollAmount := Integer(ShortInt(HIWORD(wParam))) div WHEEL_DELTA * Integer(uLines);
      m_ScrollBar.Scroll( -nScrollAmount);
      Result:= true;
      Exit;
    end;
  end;

  Result:= False;
end;

function Tz3DListBox.MsgProc(uMsg: LongWord; wParam: WPARAM; lParam: LPARAM): Boolean;
begin
  if (WM_CAPTURECHANGED = uMsg) then
  begin
    // The application just lost mouse capture. We may not have gotten
    // the WM_MOUSEUP message, so reset FDrag here.
    if (THandle(lParam) <> z3DCore_GetHWND) then FDrag := False;
  end;

  Result:= False;
end;

var bSBInit: Boolean = False;

procedure Tz3DListBox.Render;
var
  pDisplay: Iz3DDisplay;
  pSelDisplay: Iz3DDisplay;
  rc, rcSel: TRect;
  i: Integer;
  pItem: Pz3DListBoxItem;
  bSelectedStyle: Boolean;
begin
  if (FVisible = False) then Exit;

  pDisplay := m_Displays[0];
  pDisplay.TextureColor.Blend(z3dcsNormal);
  pDisplay.FontColor.Blend(z3dcsNormal);

  pSelDisplay := m_Displays[1];
  pSelDisplay.TextureColor.Blend(z3dcsNormal);
  pSelDisplay.FontColor.Blend(z3dcsNormal);

  FDialog.DrawSprite(pDisplay, FBoundingBox);

  // Render the text
  if (m_Items.Count > 0) then
  begin
    // Find out the height of a single line of text
    rc := FText;
    rcSel := FSelection;
    rc.bottom := rc.top + FDialog.Manager.Fonts[pDisplay.Font].Height;

    // Update the line height formation
    FTextHeight := rc.bottom - rc.top;

    if not bSBInit then
    begin
      // Update the page size of the scroll bar
      if (FTextHeight <> 0)
      then m_ScrollBar.SetPageSize(RectHeight(FText) div FTextHeight)
      else m_ScrollBar.SetPageSize(RectHeight(FText));
      bSBInit := True;
    end;

    rc.right := FText.right;
    for i := m_ScrollBar.TrackPos to m_Items.Count - 1 do
    begin
      if (rc.bottom > FText.bottom) then Break;

      pItem := Pz3DListBoxItem(m_Items[i]);

      // Determine if we need to render this item with the
      // selected element.
      bSelectedStyle := False;

      if (FStyle <> z3dlbsMultiSelect) and (i = FSelected)
      then bSelectedStyle := True
      else if (FStyle = z3dlbsMultiSelect) then
      begin
        if FDrag and
           ( (i >= FSelected) and (i < FSelStart) or
             (i <= FSelected) and (i > FSelStart) )
        then bSelectedStyle := Pz3DListBoxItem(m_Items[FSelStart]).bSelected
        else if pItem.bSelected then
          bSelectedStyle := True;
      end;

      if bSelectedStyle then
      begin
        rcSel.top := rc.top;
        rcSel.bottom := rc.bottom;
        FDialog.DrawSprite(pSelDisplay, rcSel);
        FDialog.DrawText(pItem.strText, pSelDisplay, rc);
      end else
        FDialog.DrawText(pItem.strText, pDisplay, rc);

      OffsetRect(rc, 0, FTextHeight);
    end;
  end;

  // Render the scroll bar
  m_ScrollBar.Render;
end;

function Tz3DListBox.GetSBWidth: Integer;
begin
 Result:= FSBWidth;
end;

function Tz3DListBox.GetSelected: Integer;
begin
  Result:= FSelected;
end;

function Tz3DListBox.GetStyle: Tz3DListBoxStyle;
begin
  Result:= FStyle;
end;

function Tz3DListBox.CanHaveFocus: Boolean;
begin
  Result:= FVisible and FEnabled;
end;

function Tz3DListBox.GetSelectedItem(nPreviousSelected: Integer): Pz3DListBoxItem;
begin
  Result:= GetItem(GetSelectedIndex(nPreviousSelected));
end;

function Tz3DListBox.OnInit: HRESULT;
begin
  inherited OnInit;
  if FDialog <> nil then Result:= FDialog.InitControl(m_ScrollBar);
end;

procedure Tz3DListBox.SetBorder(nBorder, nMargin: Integer);
begin
  FBorder := nBorder;
  FMargin := nMargin;
end;

procedure Tz3DListBox.SetScrollBarWidth(nWidth: Integer);
begin
  FSBWidth := nWidth;
  UpdateRects;
end;

procedure Tz3DListBox.SetStyle(dwStyle: Tz3DListBoxStyle);
begin
  FStyle := dwStyle;
end;

function Tz3DListBox.GetSize: Integer;
begin
  Result:= m_Items.Count;
end;

procedure Tz3DListBox.SetDialog(const Value: Iz3DDialog);
begin
  inherited;
  if FDialog <> nil then FDialog.InitControl(m_ScrollBar);
  m_ScrollBar.Dialog:= FDialog;
end;

{ Tz3DComboBox }

constructor Tz3DComboBox.Create(const pDialog: Iz3DDialog);
begin
  inherited;
  m_ScrollBar:= Tz3DScrollBar.Create(pDialog);
  m_Type := z3dctComboBox;
  FDialog := pDialog;
  FDropHeight := 64;
  FSBWidth := 16;
  FOpened := False;
  m_iSelected := -1;
  m_iFocused := -1;
end;

destructor Tz3DComboBox.Destroy;
begin
  RemoveAllItems;
  FreeAndNil(m_ScrollBar);
  inherited;
end;

procedure Tz3DComboBox.SetTextColor(Color: TD3DColor);
var
  pDisplay: Iz3DDisplay;
begin
  pDisplay := m_Displays[0];

  if (pDisplay <> nil) then
    pDisplay.FontColor.States[z3dcsNormal] := Color;

  pDisplay := m_Displays[2];

  if (pDisplay <> nil) then
    pDisplay.FontColor.States[z3dcsNormal] := Color;
end;

function Tz3DComboBox.GetSBWidth: Integer;
begin
  Result:= FSBWidth;
end;

procedure Tz3DComboBox.UpdateRects;
var
  pFontNode: Pz3DFontNode;
begin
  inherited;

  FButton := FBoundingBox;
  FButton.left := FButton.right - RectHeight(FButton);

  FText := FBoundingBox;
  FText.right := FButton.left;

  FDropdown := FText;
  OffsetRect(FDropdown, 0, Trunc(0.9 * RectHeight(FText)));
  Inc(FDropdown.bottom,  FDropHeight);
  Dec(FDropdown.right, FSBWidth);

  FDropdownText := FDropdown;
  Inc(FDropdownText.left,   Trunc(0.1 * RectWidth(FDropdown)));
  Dec(FDropdownText.right,  Trunc(0.1 * RectWidth(FDropdown)));
  Inc(FDropdownText.top,    Trunc(0.1 * RectHeight(FDropdown)));
  Dec(FDropdownText.bottom, Trunc(0.1 * RectHeight(FDropdown)));

  // Update the scrollbar's rects
  m_ScrollBar.SetLocation(FDropdown.right, FDropdown.top+2);
  m_ScrollBar.SetSize(FSBWidth, RectHeight(FDropdown)-2);
  pFontNode := FDialog.Manager.Fonts[m_Displays[2].Font];
  if (pFontNode <> nil) and (pFontNode.Height <> 0) then
  begin
    m_ScrollBar.SetPageSize(RectHeight(FDropdownText) div pFontNode.Height);

    // The selected item may have been scrolled off the page.
    // Ensure that it is in page again.
    m_ScrollBar.ShowItem(m_iSelected);
  end;
end;

procedure Tz3DComboBox.OnFocusOut;
begin
  inherited;
  FOpened := False;
end;

function Tz3DComboBox.HandleKeyboard(uMsg: LongWord; wParam: WPARAM;
  lParam: LPARAM): Boolean;
const
  REPEAT_MASK = $40000000;
begin
  Result:= True;
  if (not FEnabled or not FVisible) then
  begin
    Result:= False;
    Exit;
  end;

  // Let the scroll bar have a chance to handle it first
  if m_ScrollBar.HandleKeyboard(uMsg, wParam, lParam) then Exit;

  case uMsg of
    WM_KEYDOWN:
    case wParam of
      VK_RETURN:
      if FOpened then
      begin
        if (m_iSelected <> m_iFocused) then
        begin
          m_iSelected := m_iFocused;
          FDialog.SendEvent(z3dceComboBoxChange, True, Self);
        end;
        FOpened := False;

        if not FDialog.IsKeyboardInputEnabled then FDialog.ClearFocus;
        
        Exit;
      end;

      VK_F4:
      begin
        // Filter out auto-repeats
        if (lParam and REPEAT_MASK <> 0) then Exit;

        FOpened := not FOpened;

        if not FOpened then
        begin
          FDialog.SendEvent(z3dceComboBoxChange, True, Self);
          if not FDialog.IsKeyboardInputEnabled then FDialog.ClearFocus;
        end;
        
        Exit;
      end;

      VK_LEFT, VK_UP:
      begin
        if (m_iFocused > 0) then
        begin
          Dec(m_iFocused);
          m_iSelected := m_iFocused;

          if not FOpened then
            FDialog.SendEvent(z3dceComboBoxChange, True, Self);
        end;
        Exit;
      end;

      VK_RIGHT, VK_DOWN:
      begin
        if (m_iFocused+1 < Integer(GetNumItems)) then
        begin
          Inc(m_iFocused);
          m_iSelected := m_iFocused;

          if not FOpened then
            FDialog.SendEvent(z3dceComboBoxChange, True, Self);
        end;
        Exit;
      end;
    end;
  end;

  Result:= False;
end;

function Tz3DComboBox.HandleMouse(uMsg: LongWord; pt: TPoint;
  wParam: WPARAM; lParam: LPARAM): Boolean;
var
  i: Integer;
  pItem: Pz3DComboBoxItem;
  zDelta: Integer;
  uLines: LongWord;
begin
  Result:= True;
  if (not FEnabled or not FVisible) then
  begin
    Result:= False;
    Exit;
  end;

  // Let the scroll bar handle it first.
  if m_ScrollBar.HandleMouse(uMsg, pt, wParam, lParam) then Exit;

  case uMsg of
    WM_MOUSEMOVE:
    begin
      if FOpened and PtInRect(FDropdown, pt) then
      begin
        // Determine which item has been selected
        for i:= 0 to Length(m_Items) - 1 do
        begin
          pItem := m_Items[i];
          if pItem.bVisible and PtInRect(pItem.rcActive, pt)
          then m_iFocused := i;
        end;
        Exit;
      end;
    end;

    WM_LBUTTONDOWN,
    WM_LBUTTONDBLCLK:
    begin
      if ContainsPoint(pt) then
      begin
        // Pressed while inside the control
        FPressed := True;
        SetCapture(z3DCore_GetHWND);

        if not FHasFocus then FDialog.RequestFocus(Self);

        // Toggle dropdown
        if FHasFocus then
        begin
          FOpened := not FOpened;

          if not FOpened then
            if not FDialog.IsKeyboardInputEnabled then FDialog.ClearFocus;
        end;
        Exit;
      end;

      // Perhaps this click is within the dropdown
      if FOpened and PtInRect(FDropdown, pt) then
      begin
        // Determine which item has been selected
        for i:= m_ScrollBar.TrackPos to Length(m_Items) - 1 do
        begin
          pItem := m_Items[i];
          if pItem.bVisible and PtInRect(pItem.rcActive, pt) then
          begin
            m_iSelected := i;
            m_iFocused := i;
            FDialog.SendEvent(z3dceComboBoxChange, True, Self);
            FOpened := False;

            if not FDialog.IsKeyboardInputEnabled then FDialog.ClearFocus;
            Break;
          end;
        end;

        Exit;
      end;

      // Mouse click not on main control or in dropdown, fire an event if needed
      if FOpened then
      begin
        m_iFocused := m_iSelected;

        FDialog.SendEvent(z3dceComboBoxChange, True, Self);
        FOpened := False;
      end;

      // Make sure the control is no longer in a pressed state
      FPressed := False;

      // Release focus if appropriate
      if not FDialog.IsKeyboardInputEnabled then FDialog.ClearFocus;
    end;

    WM_LBUTTONUP:
    begin
      if FPressed and ContainsPoint(pt) then
      begin
        // Button click
        FPressed := False;
        ReleaseCapture;
        Exit;
      end;
    end;

    WM_MOUSEWHEEL:
    begin
      zDelta := HIWORD(wParam) div WHEEL_DELTA;
      if FOpened then 
      begin
        SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, @uLines, 0);
        m_ScrollBar.Scroll(-zDelta * Integer(uLines));
      end else
      begin
        if (zDelta > 0) then
        begin
          if (m_iFocused > 0) then
          begin
            Dec(m_iFocused);
            m_iSelected := m_iFocused;

            if not FOpened then
              FDialog.SendEvent(z3dceComboBoxChange, True, Self);
          end;
        end else
        begin
          if (m_iFocused + 1 < Integer(GetNumItems)) then
          begin
            Inc(m_iFocused);
            m_iSelected := m_iFocused;

            if not FOpened then
              FDialog.SendEvent(z3dceComboBoxChange, True, Self);
          end;
        end;
      end;
      Exit;
    end;
  end;
  Result:= False;
end;

procedure Tz3DComboBox.OnHotkey;
begin
  if FOpened then Exit;
  if (m_iSelected = -1) then Exit;

  if FDialog.IsKeyboardInputEnabled then FDialog.RequestFocus(Self);

  Inc(m_iSelected);
  if (m_iSelected >= Length(m_Items)) then m_iSelected := 0;

  m_iFocused := m_iSelected;
  FDialog.SendEvent(z3dceComboBoxChange, True, Self);
end;

procedure Tz3DComboBox.Render;
var
  iState: Tz3DControlState;
  pDisplay: Iz3DDisplay;
  pSelectionDisplay: Iz3DDisplay;
  pFont: Pz3DFontNode;
  curY: Integer;
  nRemainingHeight: Integer;
  i: Integer;
  pItem: Pz3DComboBoxItem;
  rc: TRect;
//  nOffsetX: Integer;
//  nOffsetY: Integer;
  fBlendRate: Single;
  rcWindow: TRect;
begin
  iState := z3dcsNormal;

  if not FOpened then iState := z3dcsHidden;

  // Dropdown box
  pDisplay := m_Displays[2];

  // If we have not initialized the scroll bar page size,
  // do that now.
  if not bSBInit then
  begin
    // Update the page size of the scroll bar
    if (FDialog.Manager.Fonts[pDisplay.Font].Height <> 0)
    then m_ScrollBar.SetPageSize(RectHeight(FDropdownText) div FDialog.Manager.Fonts[pDisplay.Font].Height)
    else m_ScrollBar.SetPageSize(RectHeight(FDropdownText));
    bSBInit := true;
  end;

  // Scroll bar
  if FOpened then
    m_ScrollBar.Render;

  // Blend current color
  pDisplay.TextureColor.Blend(iState);
  pDisplay.FontColor.Blend(iState);

  FDialog.DrawSprite(pDisplay, FDropdown);

  // Selection outline
  pSelectionDisplay := m_Displays[3];
  pSelectionDisplay.TextureColor.Current := pDisplay.TextureColor.Current;
  pSelectionDisplay.FontColor.Current := D3DXColorFromDWord(pSelectionDisplay.FontColor.States[z3dcsNormal]);

  pFont := FDialog.GetFont(pDisplay.Font);
  if Assigned(pFont) then
  begin
    curY := FDropdownText.top;
    nRemainingHeight := RectHeight(FDropdownText);

    for i := m_ScrollBar.TrackPos to Length(m_Items) - 1 do
    begin
      pItem := m_Items[i];

      // Make sure there's room left in the dropdown
      Dec(nRemainingHeight, pFont.Height);
      if (nRemainingHeight < 0) then
      begin
        pItem.bVisible := False;
        Continue;
      end;

      SetRect(pItem.rcActive, FDropdownText.left, curY, FDropdownText.right, curY + pFont.Height);
      Inc(curY, pFont.Height);
      pItem.bVisible := True;
      if FOpened then
      begin
        if (i = m_iFocused) then
        begin
          SetRect(rc, FDropdown.left, pItem.rcActive.top-2, FDropdown.right, pItem.rcActive.bottom+2);
          FDialog.DrawSprite(pSelectionDisplay, rc);
          FDialog.DrawText(pItem.strText, pSelectionDisplay, pItem.rcActive);
        end else
        FDialog.DrawText(pItem.strText, pDisplay, pItem.rcActive);
      end;
    end;
  end;

//  nOffsetX := 0;
//  nOffsetY := 0;

  iState := z3dcsNormal;

  if not FVisible then iState := z3dcsHidden
  else if not FEnabled then iState := z3dcsDisabled
  else if FPressed  then
  begin
    iState := z3dcsPressed;

//    nOffsetX := 1;
//    nOffsetY := 2;
  end
  else if FMouseOver then
  begin
    iState := z3dcsMouseOver;

//    nOffsetX := -1;
//    nOffsetY := -2;
  end
  else if FHasFocus then
    iState := z3dcsFocus;

  fBlendRate := IfThen(iState = z3dcsPressed, 0.0, 0.8);

  // Button
  pDisplay := m_Displays[1];

  // Blend current color
  pDisplay.TextureColor.Blend(iState, fBlendRate);

  rcWindow := FButton;
//  OffsetRect(rcWindow, nOffsetX, nOffsetY);
  FDialog.DrawSprite(pDisplay, rcWindow);

  if FOpened then iState := z3dcsPressed;
  pDisplay := m_Displays[0];

  // Blend current color
  pDisplay.TextureColor.Blend(iState, fBlendRate);
  pDisplay.FontColor.Blend(iState, fBlendRate);

  FDialog.DrawSprite(pDisplay, FText);

  if (m_iSelected >= 0) and (m_iSelected < Length(m_Items)) then
  begin
    pItem := m_Items[m_iSelected];
    if (pItem <> nil) then FDialog.DrawText(pItem.strText, pDisplay,
    Rect(FText.Left+10, FText.Top, FText.Right, FText.Bottom), Dialog.Manager.Desktop.ThemeSettings.DefaultFont.Shadow);
  end;
end;

function Tz3DComboBox.AddItem(const strText: PWideChar; pData: Pointer): HRESULT;
var
  pItem: Pz3DComboBoxItem;
  l: Integer;
begin
  // Validate parameters
  if (strText = nil) then
  begin
    Result:= E_INVALIDARG;
    Exit;
  end;

  // Create a new item and set the data
  try
    New(pItem);
  except
    Result:= DXTRACE_ERR_MSGBOX('new', E_OUTOFMEMORY);
    Exit;
  end;

  ZeroMemory(pItem, SizeOf(Tz3DComboBoxItem));
  StringCchCopy(pItem.strText, 256, strText);
  pItem.pData := pData;

  // m_Items.Add(pItem);
  l:= Length(m_Items);
  SetLength(m_Items, l+1);
  m_Items[l]:= pItem;

  // Update the scroll bar with new range
  m_ScrollBar.SetTrackRange(0, Length(m_Items));

  // If this is the only item in the list, it's selected
  if (GetNumItems = 1) then
  begin
    m_iSelected := 0;
    m_iFocused := 0;
    FDialog.SendEvent(z3dceComboBoxChange, False, Self);
  end;

  Result:= S_OK;
end;

procedure Tz3DComboBox.RemoveItem(index: LongWord);
var
  pItem: Pz3DComboBoxItem;
begin
  pItem := m_Items[index];
  Dispose(pItem);
  // m_Items.Remove(index);
  Move(m_Items[index+1], m_Items[index], (Length(m_Items)-Integer(index)-1)*SizeOf(Pz3DComboBoxItem));
  SetLength(m_Items, Length(m_Items)-1);

  m_ScrollBar.SetTrackRange(0, Length(m_Items));
  if (m_iSelected >= Length(m_Items)) then m_iSelected := Length(m_Items) - 1;
end;

procedure Tz3DComboBox.RemoveAllItems;
var
  i: Integer;
  pItem: Pz3DComboBoxItem;
begin
  for i:= 0 to Length(m_Items) - 1 do
  begin
    pItem := Pz3DComboBoxItem(m_Items[i]);
    Dispose(pItem);
  end;

  m_Items:= nil; // RemoveAll;
  m_ScrollBar.SetTrackRange(0, 1);
  m_iSelected := -1;
  m_iFocused := -1;
end;

function Tz3DComboBox.ContainsItem(const strText: PWideChar; iStart: LongWord = 0): Boolean;
begin
  Result:= (-1 <> FindItem(strText));
end;

function Tz3DComboBox.FindItem(const strText: PWideChar; iStart: LongWord = 0): Integer;
var
  i: Integer;
begin
  Result:= -1;
  if (strText = nil) then Exit;

  for i:= iStart to Length(m_Items) - 1 do
  begin
    if (lstrcmpW(m_Items[i].strText, strText) = 0) then
    begin
      Result:= i;
      Exit;
    end;
  end;
end;

function Tz3DComboBox.GetSelectedData: Pointer;
begin
  if (m_iSelected < 0) then Result:= nil
  else Result:= m_Items[m_iSelected].pData;
end;

function Tz3DComboBox.GetSelectedItem: Pz3DComboBoxItem;
begin
  if (m_iSelected < 0) then Result:= nil
  else Result:= m_Items[m_iSelected];
end;

function Tz3DComboBox.GetItemData(const strText: PWideChar): Pointer;
var
  index: Integer;
  pItem: Pz3DComboBoxItem;
begin
  Result:= nil;
  index := FindItem(strText);
  if (index = -1) then Exit;

  pItem := m_Items[index];
  if (pItem = nil) then
  begin
    DXTRACE_ERR('GetItemData', E_FAIL);
    Exit;
  end;

  Result:= pItem.pData;
end;

function Tz3DComboBox.GetItemData(nIndex: Integer): Pointer;
begin
  Result:= nil;
  if (nIndex < 0) or (nIndex >= Length(m_Items)) then Exit;

  Result:= m_Items[nIndex].pData;
end;

function Tz3DComboBox.SetSelectedByIndex(index: LongWord): HRESULT;
begin
  if (index >= GetNumItems) then
  begin
    Result:= E_INVALIDARG;
    Exit;
  end;

  m_iSelected := index;
  m_iFocused := index;
  FDialog.SendEvent(z3dceComboBoxChange, False, Self);

  Result:= S_OK;
end;

function Tz3DComboBox.SetSelectedByText(const strText: PWideChar): HRESULT;
var
  index: Integer;
begin
  if (strText = nil) then
  begin
    Result:= E_INVALIDARG;
    Exit;
  end;

  index := FindItem( strText);
  if (index = -1) then
  begin
    Result:= E_FAIL;
    Exit;
  end;

  m_iSelected := index;
  m_iFocused := index;
  FDialog.SendEvent(z3dceComboBoxChange, False, Self);

  Result:= S_OK;
end;

function Tz3DComboBox.SetSelectedByData(pData: Pointer): HRESULT;
var
  i: Integer;
begin
  for i:= 0 to Length(m_Items) - 1 do
  begin
    if (m_Items[i].pData = pData) then
    begin
      m_iSelected := i;
      m_iFocused := i;
      FDialog.SendEvent(z3dceComboBoxChange, False, Self);
      Result:= S_OK;
      Exit;
    end;
  end;

  Result:= E_FAIL;
end;

function Tz3DComboBox.CanHaveFocus: Boolean;
begin
  Result:= FVisible and FEnabled;
end;

function Tz3DComboBox.GetItem(index: LongWord): Pz3DComboBoxItem;
begin
  Result:= m_Items[index];
end;

function Tz3DComboBox.GetNumItems: LongWord;
begin
  Result:= Length(m_Items);
end;

function Tz3DComboBox.OnInit: HRESULT;
begin
  inherited OnInit;
  if FDialog <> nil then Result:= FDialog.InitControl(m_ScrollBar);
end;

procedure Tz3DComboBox.SetDropHeight(nHeight: LongWord);
begin
  FDropHeight := nHeight;
  UpdateRects;
end;

procedure Tz3DComboBox.SetScrollBarWidth(nWidth: Integer);
begin
  FSBWidth := nWidth;
  UpdateRects;
end;

procedure Tz3DComboBox.SetDialog(const Value: Iz3DDialog);
begin
  inherited;
  if FDialog <> nil then FDialog.InitControl(m_ScrollBar);
  m_ScrollBar.Dialog:= FDialog;
end;

{ Tz3DTrackBar }

constructor Tz3DTrackBar.Create(const pDialog: Iz3DDialog);
begin
  inherited;
  m_Type := z3dctTrackBar;
  FDialog := pDialog;

  FMin := 0;
  FMax := 100;
  FValue := 50;

  FPressed := False;
end;

function Tz3DTrackBar.GetValue: Integer;
begin
  Result:= FValue;
end;

function Tz3DTrackBar.ContainsPoint(pt: TPoint): LongBool;
begin
  Result:= PtInRect(FBoundingBox, pt) or
           PtInRect(FButton, pt);
end;

procedure Tz3DTrackBar.UpdateRects;
begin
  inherited;

  FButton := FBoundingBox;
  FButton.right := FButton.left + RectHeight(FButton);
  OffsetRect(FButton, -RectWidth(FButton) div 2, 0);

  if (FMax - FMin) <> 0 then
  begin
    FButtonX := Trunc(((FValue - FMin) * RectWidth(FBoundingBox) / (FMax - FMin)));
    OffsetRect(FButton, FButtonX, 0);
  end;
end;

function Tz3DTrackBar.ValueFromPos(x: Integer): Integer;
var
  fValuePerPixel: Single;
begin
  fValuePerPixel := (FMax - FMin) / RectWidth(FBoundingBox);
  Result:= Trunc((0.5 + FMin + fValuePerPixel * (x - FBoundingBox.left)));
end;

function Tz3DTrackBar.HandleKeyboard(uMsg: LongWord; wParam: WPARAM; lParam: LPARAM): Boolean;
begin
  Result:= False;
  if not FEnabled or not FVisible then Exit;

  case uMsg of
    WM_KEYDOWN:
    begin
      Result:= True;
      case wParam of
        VK_HOME:          SetValueInternal(FMin, True);
        VK_END:           SetValueInternal(FMax, True);
        VK_LEFT, VK_DOWN: SetValueInternal(FValue - 1, True);
        VK_RIGHT, VK_UP:  SetValueInternal(FValue + 1, True);
        VK_NEXT:          SetValueInternal(FValue - IfThen(10 > (FMax - FMin) div 10, 10, (FMax - FMin) div 10), True);
        VK_PRIOR:         SetValueInternal(FValue + IfThen(10 > (FMax - FMin) div 10, 10, (FMax - FMin) div 10), True);
       else
        Result:= False;
      end;
      Exit;
    end;
  end;
end;

function Tz3DTrackBar.HandleMouse(uMsg: LongWord; pt: TPoint;
  wParam: WPARAM; lParam: LPARAM): Boolean;
var
  nScrollAmount: Integer;
begin
  if not FEnabled or not FVisible then
  begin
    Result:= False;
    Exit;
  end;

  Result:= True;

  case uMsg of
    WM_LBUTTONDOWN,
    WM_LBUTTONDBLCLK:
    begin
      if PtInRect(FButton, pt) then
      begin
        // Pressed while inside the control
        FPressed := True;
        SetCapture(z3DCore_GetHWND);

        FDragX := pt.x;
        //FDragY = pt.y;
        FDragOffset := FButtonX - FDragX;

        //FDragValue = FValue;

        if not FHasFocus then FDialog.RequestFocus(Self);
        Exit;
      end;

      if PtInRect(FBoundingBox, pt) then
      begin
        FDragX := pt.x;
        FDragOffset := 0;
        FPressed := True;

        if not FHasFocus then FDialog.RequestFocus(Self);

        if not FHasFocus then FDialog.RequestFocus(Self);

        if (pt.x > FButtonX + FLeft) then
        begin
          SetValueInternal(FValue + 1, True);
          Exit;
        end;

        if (pt.x < FButtonX + FLeft) then
        begin
          SetValueInternal(FValue - 1, True);
          Exit;
        end;
      end;
    end;

    WM_LBUTTONUP:
    begin
      if FPressed then
      begin
        FPressed := False;
        ReleaseCapture;
        FDialog.SendEvent(z3dceTrackBarChange, True, Self);
        Exit;
      end;
    end;

    WM_MOUSEMOVE:
    begin
      if FPressed then
      begin
        SetValueInternal(ValueFromPos(FLeft + pt.x + FDragOffset), True);
        Exit;
      end;
    end;

    WM_MOUSEWHEEL:
    begin
      nScrollAmount := Integer(ShortInt(HIWORD(wParam))) div WHEEL_DELTA;
      SetValueInternal(FValue - nScrollAmount, True);
      Exit;
    end;
  end;

  Result:= False;
end;

procedure Tz3DTrackBar.GetRange(out nMin, nMax: Integer);
begin
  nMin := FMin;
  nMax := FMax;
end;

procedure Tz3DTrackBar.SetRange(nMin, nMax: Integer);
begin
  FMin := nMin;
  FMax := nMax;
  SetValueInternal(FValue, False);
end;

procedure Tz3DTrackBar.SetValueInternal(nValue: Integer; bFromInput: Boolean);
begin
  // Clamp to range
  nValue := Max(FMin, nValue);
  nValue := Min(FMax, nValue);

  if (nValue = FValue) then Exit;

  FValue := nValue;
  UpdateRects;

  FDialog.SendEvent(z3dceTrackBarChange, bFromInput, Self);
end;

procedure Tz3DTrackBar.Render;
var
//  nOffsetX, nOffsetY: Integer;
  iState: Tz3DControlState;
  fBlendRate: Single;
  pDisplay: Iz3DDisplay;
begin
  // nOffsetX := 0; // - never used
  // nOffsetY := 0; // - never used

  iState := z3dcsNormal;

  if not FVisible then iState := z3dcsHidden
  else if not FEnabled then iState := z3dcsDisabled
  else if FPressed then
  begin
    iState := z3dcsPressed;
    // nOffsetX := 1; // - never used
    //nOffsetY := 2; // - never used
  end else if FMouseOver then
  begin
    iState := z3dcsMouseOver;

    // nOffsetX := -1; // - never used
    // nOffsetY := -2; // - never used
  end else if FHasFocus then
  begin
    iState := z3dcsFocus;
  end;

  fBlendRate := IfThen(iState = z3dcsPressed, 0.0, 0.8);

  pDisplay := m_Displays[0];

  // Blend current color
  pDisplay.TextureColor.Blend(iState, fBlendRate);
  FDialog.DrawSprite(pDisplay, FBoundingBox);

  //TODO: remove magic numbers
  pDisplay := m_Displays[1];

  // Blend current color
  pDisplay.TextureColor.Blend(iState, fBlendRate);
  FDialog.DrawSprite(pDisplay, FButton);
end;

function Tz3DTrackBar.CanHaveFocus: Boolean;
begin
  Result:= True;
end;

procedure Tz3DTrackBar.SetValue(nValue: Integer);
begin
  SetValueInternal(nValue, False);
end;

{ Tz3DProgressBar }

constructor Tz3DProgressBar.Create(const pDialog: Iz3DDialog);
begin
  inherited;
  m_Type := z3dctProgressBar;
  FDialog := pDialog;
  FMin := 0;
  FMax := 100;
  FValue := 50;
end;

function Tz3DProgressBar.GetValue: Integer;
begin
  Result:= FValue;
end;

function Tz3DProgressBar.ContainsPoint(pt: TPoint): LongBool;
begin
  Result:= PtInRect(FBoundingBox, pt);
end;

procedure Tz3DProgressBar.UpdateRects;
begin
  inherited;
  FProgress := FBoundingBox;
  InflateRect(FProgress, -2, -2);
  if (FMax - FMin) <> 0 then
  FProgress.Right:= FProgress.Left + Trunc(((FValue - FMin) * (RectWidth(FBoundingBox)-4) / (FMax - FMin))) else
  FProgress.Right:= FProgress.Left;
end;

function Tz3DProgressBar.ValueFromPos(x: Integer): Integer;
var
  fValuePerPixel: Single;
begin
  fValuePerPixel := (FMax - FMin) / RectWidth(FBoundingBox);
  Result:= Trunc((0.5 + FMin + fValuePerPixel * (x - FBoundingBox.left)));
end;

function Tz3DProgressBar.HandleKeyboard(uMsg: LongWord; wParam: WPARAM; lParam: LPARAM): Boolean;
begin
  Result:= False;
end;

function Tz3DProgressBar.HandleMouse(uMsg: LongWord; pt: TPoint;
  wParam: WPARAM; lParam: LPARAM): Boolean;
begin
  Result:= False;
end;

procedure Tz3DProgressBar.GetRange(out nMin, nMax: Integer);
begin
  nMin := FMin;
  nMax := FMax;
end;

procedure Tz3DProgressBar.SetRange(nMin, nMax: Integer);
begin
  FMin := nMin;
  FMax := nMax;
  SetValueInternal(FValue, False);
end;

procedure Tz3DProgressBar.SetValueInternal(nValue: Integer; bFromInput: Boolean);
begin
  // Clamp to range
  nValue := Max(FMin, nValue);
  nValue := Min(FMax, nValue);
  if (nValue = FValue) then Exit;
  FValue := nValue;
  UpdateRects;
end;

procedure Tz3DProgressBar.Render;
var
//  nOffsetX, nOffsetY: Integer;
  iState: Tz3DControlState;
  fBlendRate: Single;
  pDisplay: Iz3DDisplay;
begin
  // nOffsetX := 0; // - never used
  // nOffsetY := 0; // - never used

  iState := z3dcsNormal;

  if not FVisible then iState := z3dcsHidden
  else if not FEnabled then iState := z3dcsDisabled
  else if FHasFocus then
  begin
    iState := z3dcsFocus;
  end;

  fBlendRate := IfThen(iState = z3dcsPressed, 0.0, 0.8);

  pDisplay := m_Displays[0];

  // Blend current color
  pDisplay.TextureColor.Blend(iState, fBlendRate);
  FDialog.DrawSprite(pDisplay, FBoundingBox);

  //TODO: remove magic numbers
  pDisplay := m_Displays[1];

  // Blend current color
  pDisplay.TextureColor.Blend(iState, fBlendRate);
  FDialog.DrawSprite(pDisplay, FProgress);
end;

function Tz3DProgressBar.CanHaveFocus: Boolean;
begin
  Result:= True;
end;

procedure Tz3DProgressBar.SetValue(nValue: Integer);
begin
  SetValueInternal(nValue, False);
end;

var
  s_bHideCaret: Boolean; // If true, we don't render the caret.


{ Tz3DUniBuffer }

type
  TUSP_ScriptApplyDigitSubstitution = function (
    const psds: PScriptDigitSubstitute;   // In   Digit substitution settings
    psc: PScriptControl;                  // Out  Script control structure
    pss: PScriptState                     // Out  Script state structure
    ): HRESULT; stdcall;

  TUSP_ScriptStringAnalyse = function (
    hdc: HDC;                  //In  Device context (required)
    const pString: Pointer;    //In  String in 8 or 16 bit characters
    cString: Integer;          //In  Length in characters (Must be at least 1)
    cGlyphs: Integer;          //In  Required glyph buffer size (default cString*1.5 + 16)
    iCharset: Integer;         //In  Charset if an ANSI string, -1 for a Unicode string
    dwFlags: DWORD;            //In  Analysis required
    iReqWidth: Integer;        //In  Required width for fit and/or clip
    psControl: PScriptControl; //In  Analysis control (optional)
    psState: PScriptState;     //In  Analysis initial state (optional)
    const piDx: PInteger;      //In  Requested logical dx array
    pTabdef: PScriptTabDef;    //In  Tab positions (optional)
    const pbInClass: PByte;    //In  Legacy GetCharacterPlacement character classifications (deprecated)

    pssa:  PScriptStringAnalysis //Out Analysis of string
    ): HRESULT; stdcall;

  TUSP_ScriptStringCPtoX = function (
    ssa: TScriptStringAnalysis;        //In  String analysis
    icp: Integer;                      //In  Caret character position
    fTrailing: BOOL;                   //In  Which edge of icp
    out pX: Integer                    //Out Corresponding x offset
    ): HRESULT; stdcall;

  TUSP_ScriptStringXtoCP = function (
    ssa: TScriptStringAnalysis;        // In
    iX: Integer;                       // In
    piCh: PInteger;                    // Out
    piTrailing: PInteger               // Out
    ): HRESULT; stdcall;

  TUSP_ScriptStringFree = function (
    pssa: PScriptStringAnalysis  //InOut Address of pointer to analysis
    ): HRESULT; stdcall;

  TUSP_ScriptString_pLogAttr = function (
    ssa: TScriptStringAnalysis
    ): {const} PScriptLogAttr; stdcall;

  TUSP_ScriptString_pcOutChars = function (
    ssa: TScriptStringAnalysis
    ): {const} PInteger; stdcall; 


// Empty implementation of the Uniscribe API
function Dummy_ScriptApplyDigitSubstitution(
    const psds: PScriptDigitSubstitute;   // In   Digit substitution settings
    psc: PScriptControl;                  // Out  Script control structure
    pss: PScriptState                     // Out  Script state structure
    ): HRESULT; stdcall;
begin Result:= E_NOTIMPL; end;

function Dummy_ScriptStringAnalyse(
    hdc: HDC;                  //In  Device context (required)
    const pString: Pointer;    //In  String in 8 or 16 bit characters
    cString: Integer;          //In  Length in characters (Must be at least 1)
    cGlyphs: Integer;          //In  Required glyph buffer size (default cString*1.5 + 16)
    iCharset: Integer;         //In  Charset if an ANSI string, -1 for a Unicode string
    dwFlags: DWORD;            //In  Analysis required
    iReqWidth: Integer;        //In  Required width for fit and/or clip
    psControl: PScriptControl; //In  Analysis control (optional)
    psState: PScriptState;     //In  Analysis initial state (optional)
    const piDx: PInteger;      //In  Requested logical dx array
    pTabdef: PScriptTabDef;    //In  Tab positions (optional)
    const pbInClass: PByte;    //In  Legacy GetCharacterPlacement character classifications (deprecated)

    pssa:  PScriptStringAnalysis //Out Analysis of string
    ): HRESULT; stdcall;
begin Result:= E_NOTIMPL; end;

function Dummy_ScriptStringCPtoX(
    ssa: TScriptStringAnalysis;        //In  String analysis
    icp: Integer;                      //In  Caret character position
    fTrailing: BOOL;                   //In  Which edge of icp
    out pX: Integer                    //Out Corresponding x offset
    ): HRESULT; stdcall;
begin Result:= E_NOTIMPL; end;

function Dummy_ScriptStringXtoCP(
    ssa: TScriptStringAnalysis;        // In
    iX: Integer;                       // In
    piCh: PInteger;                    // Out
    piTrailing: PInteger               // Out
    ): HRESULT; stdcall;
begin Result:= E_NOTIMPL; end;

function Dummy_ScriptStringFree(
    pssa: PScriptStringAnalysis  //InOut Address of pointer to analysis
    ): HRESULT; stdcall; 
begin Result:= E_NOTIMPL; end;

function Dummy_ScriptString_pLogAttr(
    ssa: TScriptStringAnalysis
    ): {const} PScriptLogAttr; stdcall;
begin Result:= nil; end;

function Dummy_ScriptString_pcOutChars(
    ssa: TScriptStringAnalysis
    ): {const} PInteger; stdcall;
begin Result:= nil; end;

var
  // Function pointers
  _ScriptApplyDigitSubstitution: TUSP_ScriptApplyDigitSubstitution = Dummy_ScriptApplyDigitSubstitution;
  _ScriptStringAnalyse: TUSP_ScriptStringAnalyse = Dummy_ScriptStringAnalyse;
  _ScriptStringCPtoX: TUSP_ScriptStringCPtoX = Dummy_ScriptStringCPtoX;
  _ScriptStringXtoCP: TUSP_ScriptStringXtoCP = Dummy_ScriptStringXtoCP;
  _ScriptStringFree: TUSP_ScriptStringFree = Dummy_ScriptStringFree;
  _ScriptString_pLogAttr: TUSP_ScriptString_pLogAttr = Dummy_ScriptString_pLogAttr;
  _ScriptString_pcOutChars: TUSP_ScriptString_pcOutChars = Dummy_ScriptString_pcOutChars;

  s_hDll: THandle {HINSTANCE} = 0; // Uniscribe DLL handle

{ Tz3DUniBuffer }

constructor Tz3DUniBuffer.Create(nInitialSize: Integer);
begin
  Tz3DUniBuffer.Initialize;
  FBufferSize := 0;
  FwszBuffer := nil;
  FAnalyseRequired := True;
  m_Analysis := nil;
  FFontNode := nil;
  if (nInitialSize > 0) then SetBufferSize(nInitialSize);
end;

destructor Tz3DUniBuffer.Destroy;
begin
  FreeMem(FwszBuffer);
  if (m_Analysis <> nil) then _ScriptStringFree(@m_Analysis);
  inherited;
end;

function Tz3DUniBuffer.GetBufferSize: Integer;
begin
  Result:= FBufferSize;
end;

function Tz3DUniBuffer.GetFontNode: Pz3DFontNode;
begin
  Result:= FFontNode;
end;

function Tz3DUniBuffer.GetwszBuffer: PWideChar;
begin
  Result:= FwszBuffer;
end;

procedure Tz3DUniBuffer.SetFontNode(const Value: Pz3DFontNode);
begin
  FFontNode:= Value;
end;

class procedure Tz3DUniBuffer.Initialize;
var
  wszPath: array[0..MAX_PATH] of WideChar;
  len1, len2: Integer;
  temp: FARPROC;
begin
  if (s_hDll <> 0) then Exit; // Only need to do once

  if (GetSystemDirectoryW(wszPath, MAX_PATH+1) = 0) then Exit;

  // Verify whether it is safe to concatenate these strings
  len1 := lstrlenW(wszPath);
  len2 := lstrlenW(UNISCRIBE_DLLNAME);
  if (len1 + len2 > MAX_PATH) then Exit;

  // We have verified that the concatenated string will fit into wszPath,
  // so it is safe to concatenate them.
  StringCchCat(wszPath, MAX_PATH, UNISCRIBE_DLLNAME);

  s_hDll := LoadLibraryW(wszPath);
  if (s_hDll <> 0) then
  begin
    temp:= GetProcAddress(s_hDll, 'ScriptApplyDigitSubstitution'); if (temp<>nil) then _ScriptApplyDigitSubstitution:= temp;
    temp:= GetProcAddress(s_hDll, 'ScriptStringAnalyse'); if (temp<>nil) then _ScriptStringAnalyse:= temp;
    temp:= GetProcAddress(s_hDll, 'ScriptStringCPtoX'); if (temp<>nil) then _ScriptStringCPtoX:= temp;
    temp:= GetProcAddress(s_hDll, 'ScriptStringXtoCP'); if (temp<>nil) then _ScriptStringXtoCP:= temp;
    temp:= GetProcAddress(s_hDll, 'ScriptStringFree'); if (temp<>nil) then _ScriptStringFree:= temp;
    temp:= GetProcAddress(s_hDll, 'ScriptString_pLogAttr'); if (temp<>nil) then _ScriptString_pLogAttr:= temp;
    temp:= GetProcAddress(s_hDll, 'ScriptString_pcOutChars'); if (temp<>nil) then _ScriptString_pcOutChars:= temp;
  end;
end;

class procedure Tz3DUniBuffer.Uninitialize;
begin
  if (s_hDll <> 0) then
  begin
    _ScriptApplyDigitSubstitution := Dummy_ScriptApplyDigitSubstitution;
    _ScriptStringAnalyse := Dummy_ScriptStringAnalyse;
    _ScriptStringCPtoX := Dummy_ScriptStringCPtoX;
    _ScriptStringXtoCP := Dummy_ScriptStringXtoCP;
    _ScriptStringFree := Dummy_ScriptStringFree;
    _ScriptString_pLogAttr := Dummy_ScriptString_pLogAttr;
    _ScriptString_pcOutChars:= Dummy_ScriptString_pcOutChars;

    FreeLibrary(s_hDll);
    s_hDll := 0;
  end;
end;

function Tz3DUniBuffer.SetBufferSize(nNewSize: Integer): Boolean;
var
  nAllocateSize: Integer;
  pTempBuffer: PWideChar;
begin
  // If the current size is already the maximum allowed,
  // we can't possibly allocate more.
  if (FBufferSize = z3D_MAX_EDITBOXLENGTH) then
  begin
    Result:= False;
    Exit;
  end;

  nAllocateSize := IfThen((nNewSize = -1) or (nNewSize < FBufferSize * 2),
                     IfThen((FBufferSize <> 0), FBufferSize * 2, 256), nNewSize * 2);

  // Cap the buffer size at the maximum allowed.
  if (nAllocateSize > z3D_MAX_EDITBOXLENGTH) then
    nAllocateSize := z3D_MAX_EDITBOXLENGTH;

  try
    GetMem(pTempBuffer, SizeOf(WideChar) * nAllocateSize);
  except
    Result:= False;
    Exit;
  end;

  if (FwszBuffer <> nil) then
  begin
    CopyMemory(pTempBuffer, FwszBuffer, (lstrlenW(FwszBuffer) + 1) * SizeOf(WideChar));
    FreeMem(FwszBuffer);
  end else
    ZeroMemory(pTempBuffer, SizeOf(WideChar) * nAllocateSize);

  FwszBuffer := pTempBuffer;
  FBufferSize := nAllocateSize;
  Result:= True;
end;

// Uniscribe -- Analyse() analyses the string in the buffer

function Tz3DUniBuffer.Analyse: HRESULT;
var
  ScriptControl: TScriptControl; // For uniscribe
  ScriptState:   TScriptState;   // For uniscribe
begin
  if (m_Analysis <> nil) then _ScriptStringFree(@m_Analysis);

  ZeroMemory(@ScriptControl, SizeOf(ScriptControl));
  ZeroMemory(@ScriptState, SizeOf(ScriptState));
  _ScriptApplyDigitSubstitution(nil, @ScriptControl, @ScriptState);

  if (FFontNode = nil) then
  begin
    Result:= E_FAIL;
    Exit;
  end;

  Result := _ScriptStringAnalyse(IfThen(Assigned(FFontNode.Font), FFontNode.Font.GetDC, 0),
                                 FwszBuffer,
                                 lstrlenW(FwszBuffer) + 1,  // nil is also analyzed.
                                 lstrlenW(FwszBuffer) * 3 div 2 + 16,
                                 -1,
                                 SSA_BREAK or SSA_GLYPHS or SSA_FALLBACK or SSA_LINK,
                                 0,
                                 @ScriptControl,
                                 @ScriptState,
                                 nil,
                                 nil,
                                 nil,
                                 @m_Analysis);
  if SUCCEEDED(Result) then FAnalyseRequired := False;  // Analysis is up-to-date
end;

function Tz3DUniBuffer.GetTextSize: Integer; { return lstrlenW( FwszBuffer ); }
begin
  Result:= lstrlenW(FwszBuffer);
end;

function Tz3DUniBuffer.GetChar(i: Integer): WideChar; // No param checking
begin
  Result:= FwszBuffer[i];
end;

procedure Tz3DUniBuffer.SetChar(i: Integer; ch: WideChar);
begin
  // This version of operator[] is called only
  // if we are asking for write access, so
  // re-analysis is required.
  FAnalyseRequired := True;
  FwszBuffer[i]:= ch;
end;

procedure Tz3DUniBuffer.Clear;
begin
  FwszBuffer^ := #0;
  FAnalyseRequired := True;
end;

// Inserts the char at specified index.
// If nIndex == -1, insert to the end.

function Tz3DUniBuffer.InsertChar(nIndex: Integer; wChar: WideChar): Boolean;
var
  dest, stop, src: PWideChar;
begin
  Assert(nIndex >= 0);
  Result:= False;

  if (nIndex < 0) or (nIndex > lstrlenW(FwszBuffer)) then Exit;  // invalid index

  // Check for maximum length allowed
  if (TextSize + 1 >= z3D_MAX_EDITBOXLENGTH) then Exit;

  if (lstrlenW(FwszBuffer) + 1 >= FBufferSize) then
  begin
    if not SetBufferSize(-1) then Exit;  // out of memory
  end;

  Assert(FBufferSize >= 2);

//  MoveMemory(FwszBuffer + nIndex + 1, FwszBuffer + nIndex, SizeOf(WideChar) * (lstrlenW(FwszBuffer) - nIndex + 1));
  // Shift the characters after the index, start by copying the null terminator
  dest := FwszBuffer + lstrlenW(FwszBuffer)+1;
  //todo: new! replace lstrlenW
  stop := FwszBuffer + nIndex;
  src := dest - 1;

  while (dest > stop) do
  begin
    dest^ := src^;
    Dec(dest); Dec(src);
  end;

  // Set new character
  FwszBuffer[nIndex] := wChar;
  FAnalyseRequired := True;

  Result:= True;
end;

// Removes the char at specified index.
// If nIndex == -1, remove the last char.

function Tz3DUniBuffer.RemoveChar(nIndex: Integer): Boolean;
begin
  if (lstrlenW(FwszBuffer)=0) or (nIndex < 0) or (nIndex >= lstrlenW(FwszBuffer)) then
  begin
    Result:= False;  // Invalid index
    Exit;
  end;

  MoveMemory(FwszBuffer + nIndex, FwszBuffer + nIndex + 1, SizeOf(WideChar) * (lstrlenW(FwszBuffer) - nIndex));
  FAnalyseRequired := True;
  Result:= True;
end;

// Inserts the first nCount characters of the string pStr at specified index.
// If nCount == -1, the entire string is inserted.
// If nIndex == -1, insert to the end.

function Tz3DUniBuffer.InsertString(nIndex: Integer; const pStr: PWideChar; nCount: Integer = -1): Boolean;
begin
  Assert(nIndex >= 0);
  Result:= False;

  if (nIndex > lstrlenW(FwszBuffer)) then Exit; // invalid index

  if (-1 = nCount) then nCount := lstrlenW(pStr);

  // Check for maximum length allowed
  if (TextSize + nCount >= z3D_MAX_EDITBOXLENGTH) then Exit;

  if (lstrlenW(FwszBuffer) + nCount >= FBufferSize) then 
  begin
    if not SetBufferSize(lstrlenW(FwszBuffer) + nCount + 1) then Exit; // out of memory
  end;

  MoveMemory(FwszBuffer + nIndex + nCount, FwszBuffer + nIndex, SizeOf(WideChar) * (lstrlenW(FwszBuffer) - nIndex + 1));
  CopyMemory(FwszBuffer + nIndex, pStr, nCount * SizeOf(WideChar));
  FAnalyseRequired := True;

  Result:= True;
end;

procedure Tz3DUniBuffer.SetText(wszText: PWideChar);
var
  nRequired: Integer;
begin
  Assert(wszText <> nil);

  nRequired := lstrlenW(wszText) + 1;

  // Check for maximum length allowed
  if (nRequired >= z3D_MAX_EDITBOXLENGTH) then
    raise EOutOfMemory.Create('Tz3DUniBuffer.SetText - max length reached'); // Result:= False;
  {begin
    Result:= False;
    Exit;
  end;}

  while (BufferSize < nRequired) do
    if not SetBufferSize(-1) then Break;
  // Check again in case out of memory occurred inside while loop.
  if (BufferSize >= nRequired) then
  begin
    StringCchCopy(FwszBuffer, BufferSize, wszText);
    FAnalyseRequired := True;
    // Result:= True;
  end else
    raise EOutOfMemory.Create('Tz3DUniBuffer.Grow'); // Result:= False;
end;

function Tz3DUniBuffer.CPtoX(nCP: Integer; bTrail: BOOL;
  out pX: Integer): HRESULT;
begin
  // Assert(pX <> nil);
  pX := 0;  // Default

  Result := S_OK;
  if FAnalyseRequired then Result := Analyse;

  if SUCCEEDED(Result) then
    Result := _ScriptStringCPtoX(m_Analysis, nCP, bTrail, pX);
end;

function Tz3DUniBuffer.XtoCP(nX: Integer; out pCP: Integer; out pnTrail: LongBool): HRESULT;
begin
  // assert( pCP && pnTrail );
  pCP := 0; pnTrail := False;  // Default

  Result := S_OK;
  if FAnalyseRequired then Result := Analyse;

  if SUCCEEDED(Result) then
    Result := _ScriptStringXtoCP(m_Analysis, nX, @pCP, @pnTrail);

  // If the coordinate falls outside the text region, we
  // can get character positions that don't exist.  We must
  // filter them here and convert them to those that do exist.
  if (pCP = -1) and (pnTrail = TRUE) then
  begin
    pCP := 0; pnTrail := False;
  end else
  if (pCP > lstrlenW(FwszBuffer)) and (pnTrail = False) then
  begin
    pCP := lstrlenW(FwszBuffer); pnTrail := True;
  end;
end;

type
  TScriptLogAttrArray = array[0..MaxInt div SizeOf(TScriptLogAttr)-1] of TScriptLogAttr;
  PScriptLogAttrArray = ^TScriptLogAttrArray;

procedure Tz3DUniBuffer.GetPriorItemPos(nCP: Integer; out pPrior: Integer);
var
  pLogAttr: PScriptLogAttrArray;
  nInitial: Integer;
  i: Integer;
begin
  pPrior := nCP;  // Default is the char itself

  if FAnalyseRequired then
    if FAILED(Analyse) then Exit;

  pLogAttr := PScriptLogAttrArray(_ScriptString_pLogAttr(m_Analysis));
  if (pLogAttr = nil) then Exit;

  if (_ScriptString_pcOutChars(m_Analysis) = nil) then Exit;

  nInitial := _ScriptString_pcOutChars(m_Analysis)^;
  if (nCP - 1 < nInitial) then nInitial := nCP - 1;

  for i := nInitial downto 1 do
    if (fWordStop in pLogAttr[i]) or   // Either the fWordStop flag is set
       (fWhiteSpace in pLogAttr[i]) or  // Or the previous char is whitespace but this isn't.
       (fWhiteSpace in pLogAttr[i-1]) then
    begin
      pPrior := i;
      Exit;
    end;
  // We have reached index 0.  0 is always a break point, so simply return it.
  pPrior := 0;
end;

procedure Tz3DUniBuffer.GetNextItemPos(nCP: Integer; out pPrior: Integer);
var
  pLogAttr: PScriptLogAttrArray;
  nInitial: Integer;
  i: Integer;
begin
  pPrior := nCP;  // Default is the char itself

  if FAnalyseRequired then
    if FAILED(Analyse) then Exit;

  pLogAttr := PScriptLogAttrArray(_ScriptString_pLogAttr(m_Analysis));
  if (pLogAttr = nil) then Exit;

  if (_ScriptString_pcOutChars(m_Analysis) = nil) then Exit;

  nInitial := _ScriptString_pcOutChars(m_Analysis)^;
  if (nCP + 1 < nInitial) then nInitial := nCP + 1;

  for i := nInitial to _ScriptString_pcOutChars(m_Analysis)^ - 2 do
  begin
    if (fWordStop in pLogAttr[i]) then      // Either the fWordStop flag is set
    begin
      pPrior := i;
      Exit;
    end
    else
    if (fWhiteSpace in pLogAttr[i]) and // Or this whitespace but the next char isn't.
       (fWhiteSpace in pLogAttr[i+1]) then
    begin
      pPrior := i+1;  // The next char is a word stop
      Exit;
    end;
  end;
  // We have reached the end. It's always a word stop, so simply return it.
  pPrior := _ScriptString_pcOutChars(m_Analysis)^ - 1;
end;

{ Tz3DEdit }

constructor Tz3DEdit.Create(const pDialog: Iz3DDialog);
begin
  inherited;
  m_Buffer:= Tz3DUniBuffer.Create;

  m_Type := z3dctEdit;
  FDialog := pDialog;

  FBorder := 5;  // Default border width
  FSpacing := 4;  // Default spacing

  FCaretOn := True;
  m_dfBlink := GetCaretBlinkTime * 0.001;
  m_dfLastBlink := z3DCore_GetGlobalTimer.AbsoluteTime;
  s_bHideCaret := False;
  FFirstVisible := 0;
  m_TextColor := D3DCOLOR_ARGB(255, 16, 16, 16);
  m_SelTextColor := D3DCOLOR_ARGB(255, 255, 255, 255);
  m_SelBkColor := D3DCOLOR_ARGB(255, 40, 50, 92);
  m_CaretColor := D3DCOLOR_ARGB(255, 0, 0, 0);
  FSelStart := 0;
  FCaret := 0;
  FInsertMode := True;

  FMouseDrag := False;
end;

destructor Tz3DEdit.Destroy;
begin
  FreeAndNil(m_Buffer);
  inherited;
end;

function Tz3DEdit.GetBorder: Integer;
begin
  Result:= FBorder;
end;

function Tz3DEdit.GetCaretColor: TD3DColor;
begin
  Result:= m_CaretColor;
end;

function Tz3DEdit.GetSelBkColor: TD3DColor;
begin
  Result:= m_SelBkColor;
end;

function Tz3DEdit.GetSelTextColor: TD3DColor;
begin
  Result:= m_SelTextColor;
end;

function Tz3DEdit.GetSpacing: Integer;
begin
  Result:= FSpacing;
end;

function Tz3DEdit.GetTextColor: TD3DColor;
begin
  Result:= m_TextColor;
end;

procedure Tz3DEdit.SetSelBkColor(const Value: TD3DColor);
begin
  m_SelBkColor:= Value;
end;

procedure Tz3DEdit.SetSelTextColor(const Value: TD3DColor);
begin
  m_SelTextColor:= Value;
end;

procedure Tz3DEdit.SetCaretColor(const Value: TD3DColor);
begin
  m_CaretColor:= Value;
end;

procedure Tz3DEdit.PlaceCaret(nCP: Integer);
var
  nX1st, nX, nX2: Integer;
  nXNewLeft: Integer;
  nCPNew1st: Integer;
  nNewTrail: LongBool;
  nXNew1st: Integer;
begin
  Assert((nCP >= 0) and (nCP <= m_Buffer.TextSize));
  FCaret := nCP;

  // Obtain the X offset of the character.
  m_Buffer.CPtoX(FFirstVisible, False, nX1st);  // 1st visible char
  m_Buffer.CPtoX(nCP, False, nX);  // LEAD
  // If nCP is the NULL terminator, get the leading edge instead of trailing.
  if (nCP = m_Buffer.TextSize) then nX2 := nX
  else m_Buffer.CPtoX(nCP, True, nX2);  // TRAIL

  // If the left edge of the char is smaller than the left edge of the 1st visible char,
  // we need to scroll left until this char is visible.
  if (nX < nX1st) then
  begin
    // Simply make the first visible character the char at the new caret position.
    FFirstVisible := nCP;
  end else
  // If the right of the character is bigger than the offset of the control's
  // right edge, we need to scroll right to this character.
  if (nX2 > nX1st + RectWidth(FText)) then
  begin
    // Compute the X of the new left-most pixel
    nXNewLeft := nX2 - RectWidth(FText);

    // Compute the char position of this character
    m_Buffer.XtoCP(nXNewLeft, nCPNew1st, nNewTrail);

    // If this coordinate is not on a character border,
    // start from the next character so that the caret
    // position does not fall outside the text rectangle.
    m_Buffer.CPtoX(nCPNew1st, False, nXNew1st);
    if (nXNew1st < nXNewLeft) then Inc(nCPNew1st);

    FFirstVisible := nCPNew1st;
  end;
end;

procedure Tz3DEdit.ClearText;
begin
  m_Buffer.Clear;
  FFirstVisible := 0;
  PlaceCaret(0);
  FSelStart := 0;
end;

procedure Tz3DEdit.SetText(wszText: PWideChar; bSelected: Boolean);
begin
  Assert(wszText <> nil);

  m_Buffer.SetText(wszText);
  FFirstVisible := 0;
  // Move the caret to the end of the text
  PlaceCaret(m_Buffer.TextSize);
  FSelStart := IfThen(bSelected, 0, FCaret);
end;

function Tz3DEdit.GetTextCopy(strDest: PWideChar; bufferCount: LongWord): HRESULT;
begin
  Assert(Assigned(strDest));
  StringCchCopy(strDest, bufferCount, m_Buffer.Buffer);
  Result:= S_OK;
end;

procedure Tz3DEdit.DeleteSelectionText;
var
  nFirst, nLast: Integer;
  i: Integer;
begin
  nFirst := Min(FCaret, FSelStart);
  nLast := Max(FCaret, FSelStart);
  // Update caret and selection
  PlaceCaret(nFirst);
  FSelStart := FCaret;
  // Remove the characters
  for i := nFirst to nLast - 1 do m_Buffer.RemoveChar(nFirst);
end;

procedure Tz3DEdit.UpdateRects;
begin
  inherited;

  // Update the text rectangle
  FText := FBoundingBox;
  // First inflate by FBorder to compute render rects
  InflateRect(FText, -FBorder, -FBorder);

  // Update the render rectangles
  FRender[0] := FText;
  SetRect(FRender[1], FBoundingBox.left, FBoundingBox.top, FText.left, FText.top);
  SetRect(FRender[2], FText.left, FBoundingBox.top, FText.right, FText.top);
  SetRect(FRender[3], FText.right, FBoundingBox.top, FBoundingBox.right, FText.top);
  SetRect(FRender[4], FBoundingBox.left, FText.top, FText.left, FText.bottom);
  SetRect(FRender[5], FText.right, FText.top, FBoundingBox.right, FText.bottom);
  SetRect(FRender[6], FBoundingBox.left, FText.bottom, FText.left, FBoundingBox.bottom);
  SetRect(FRender[7], FText.left, FText.bottom, FText.right, FBoundingBox.bottom);
  SetRect(FRender[8], FText.right, FText.bottom, FBoundingBox.right, FBoundingBox.bottom);

  // Inflate further by FSpacing
  InflateRect(FText, -FSpacing, -FSpacing);
end;

procedure Tz3DEdit.CopyToClipboard;
var
  hBlock: HGLOBAL;
  pwszText: PWideChar;
  nFirst, nLast: Integer;
begin
  // Copy the selection text to the clipboard
  if (FCaret <> FSelStart) and OpenClipboard(0) then
  begin
    EmptyClipboard;

    hBlock := GlobalAlloc(GMEM_MOVEABLE, SizeOf(WideChar) * (m_Buffer.TextSize + 1));
    if (hBlock <> 0) then
    begin
      pwszText := GlobalLock(hBlock);
      if (pwszText <> nil) then
      begin
        nFirst := Min(FCaret, FSelStart);
        nLast := Max(FCaret, FSelStart);
        if (nLast - nFirst > 0) then
          CopyMemory(pwszText, m_Buffer.Buffer + nFirst, (nLast - nFirst) * SizeOf(WideChar));
        pwszText[nLast - nFirst] := #0;  // Terminate it
        GlobalUnlock(hBlock);
      end;
      SetClipboardData(CF_UNICODETEXT, hBlock);
    end;
    CloseClipboard;
    // We must not free the object until CloseClipboard is called.
    if (hBlock <> 0) then GlobalFree(hBlock);
  end;
end;

procedure Tz3DEdit.PasteFromClipboard;
var
  handle: THandle;
  pwszText: PWideChar;
begin
  DeleteSelectionText;

  if OpenClipboard(0) then
  begin
    handle := GetClipboardData( CF_UNICODETEXT);
    if (handle <> 0) then
    begin
      // Convert the ANSI string to Unicode, then
      // insert to our buffer.
      pwszText := GlobalLock(handle);
      if (pwszText <> nil) then
      begin
        // Copy all characters up to null.
        if m_Buffer.InsertString(FCaret, pwszText) then
          PlaceCaret(FCaret + lstrlenW(pwszText));
        FSelStart := FCaret;
        GlobalUnlock(handle);
      end;
    end;
    CloseClipboard;
  end;
end;

function Tz3DEdit.HandleKeyboard(uMsg: LongWord; wParam: WPARAM;
  lParam: LPARAM): Boolean;
var
  bHandled: Boolean;
begin
  Result:= False;
  if (not FEnabled or not FVisible) then Exit;

  bHandled := False;

  case uMsg of
    WM_KEYDOWN:
    begin
      case wParam of
        VK_TAB: ;
          // We don't process Tab in case keyboard input is enabled and the user
          // wishes to Tab to other controls.
        //todo: is it as designed?

        VK_HOME:
        begin
          PlaceCaret(0);
          if (GetKeyState(VK_SHIFT) >= 0) then
          begin
            // Shift is not down. Update selection
            // start along with the caret.
            FSelStart := FCaret;
          end;
          ResetCaretBlink;
          bHandled := True;
        end;

        VK_END:
        begin
          PlaceCaret(m_Buffer.TextSize);
          if (GetKeyState(VK_SHIFT) >= 0) then
              // Shift is not down. Update selection
              // start along with the caret.
              FSelStart := FCaret;
          ResetCaretBlink;
          bHandled := True;
        end;

        VK_INSERT:
        begin
          if (GetKeyState(VK_CONTROL) < 0) then
          begin
            // Control Insert. Copy to clipboard
            CopyToClipboard;
          end else
          if (GetKeyState(VK_SHIFT) < 0) then 
          begin
            // Shift Insert. Paste from clipboard
            PasteFromClipboard();
          end else
          begin
            // Toggle caret insert mode
            FInsertMode := not FInsertMode;
          end;
        end;

        VK_DELETE:
        begin
          // Check if there is a text selection.
          if (FCaret <> FSelStart) then
          begin
            DeleteSelectionText;
            FDialog.SendEvent(z3dceEditChange, True, Self);
          end else
          begin
            // Deleting one character
            if (m_Buffer.RemoveChar(FCaret)) then
              FDialog.SendEvent(z3dceEditChange, True, Self);
          end;
          ResetCaretBlink;
          bHandled := True;
        end;

        VK_LEFT:
        begin
          if (GetKeyState(VK_CONTROL) < 0) then
          begin
            // Control is down. Move the caret to a new item
            // instead of a character.
            m_Buffer.GetPriorItemPos(FCaret, FCaret);
            PlaceCaret(FCaret);
          end else
          if (FCaret > 0) then PlaceCaret( FCaret - 1);
          if (GetKeyState(VK_SHIFT) >= 0) then
            // Shift is not down. Update selection
            // start along with the caret.
            FSelStart := FCaret;
          ResetCaretBlink;
          bHandled := True;
        end;

        VK_RIGHT:
        begin
          if (GetKeyState(VK_CONTROL) < 0) then
          begin
            // Control is down. Move the caret to a new item
            // instead of a character.
            m_Buffer.GetNextItemPos(FCaret, FCaret);
            PlaceCaret(FCaret);
          end else
          if (FCaret < m_Buffer.TextSize) then PlaceCaret(FCaret + 1);
          if (GetKeyState( VK_SHIFT ) >= 0) then
            // Shift is not down. Update selection
            // start along with the caret.
            FSelStart := FCaret;
          ResetCaretBlink;
          bHandled := True;
        end;

      VK_UP, VK_DOWN:
        // Trap up and down arrows so that the dialog
        // does not switch focus to another control.
        bHandled := true;

      else
        bHandled := wParam <> VK_ESCAPE;  // Let the application handle Esc.
      end;
    end;
  end;
  Result:= bHandled;
end;

function Tz3DEdit.HandleMouse(uMsg: LongWord; pt: TPoint;
  wParam: WPARAM; lParam: LPARAM): Boolean;
var
  nCP, nX1st: Integer;
  nTrail: LongBool;
begin
  Result:= True;
  if (not FEnabled or not FVisible) then
  begin
    Result:= False;
    Exit;
  end;

  case uMsg of
    WM_LBUTTONDOWN,
    WM_LBUTTONDBLCLK:
    begin
      if (not FHasFocus) then FDialog.RequestFocus(Self);

      if not ContainsPoint(pt) then
      begin
        Result:= False;
        Exit;
      end;

      FMouseDrag := True;
      SetCapture(z3DCore_GetHWND);
      // Determine the character corresponding to the coordinates.
      m_Buffer.CPtoX(FFirstVisible, False, nX1st);  // X offset of the 1st visible char
      if SUCCEEDED(m_Buffer.XtoCP(pt.x - FText.left + nX1st, nCP, nTrail)) then
      begin
        // Cap at the NULL character.
        if nTrail and (nCP < m_Buffer.TextSize)
          then PlaceCaret(nCP + 1)
          else PlaceCaret(nCP);
        FSelStart := FCaret;
        ResetCaretBlink;
      end;
      // Result:= True;
      Exit;
    end;

    WM_LBUTTONUP:
    begin
      ReleaseCapture;
      FMouseDrag := False;
    end;

    WM_MOUSEMOVE:
      if (FMouseDrag) then
      begin
        // Determine the character corresponding to the coordinates.
        m_Buffer.CPtoX(FFirstVisible, False, nX1st);  // X offset of the 1st visible char
        if SUCCEEDED(m_Buffer.XtoCP(pt.x - FText.left + nX1st, nCP, nTrail)) then
        begin
          // Cap at the NULL character.
          if nTrail and (nCP < m_Buffer.TextSize)
          then PlaceCaret(nCP + 1)
          else PlaceCaret(nCP);
        end;
      end;
  end;

  Result:= false;
end;

procedure Tz3DEdit.OnFocusIn;
begin
  inherited;
  ResetCaretBlink;
end;

function Tz3DEdit.MsgProc(uMsg: LongWord; wParam: WPARAM;
  lParam: LPARAM): Boolean;
begin
  if (not FEnabled or not FVisible) then
  begin
    Result:= False;
    Exit;
  end;

  case uMsg of
    // Make sure that while editing, the keyup and keydown messages associated with
    // WM_CHAR messages don't go to any non-focused controls or cameras
    WM_KEYUP,
    WM_KEYDOWN:
    begin
      Result:= True;
      Exit;
    end;

    WM_CHAR:
    begin
      case (wParam) of
        // Backspace
        VK_BACK:
        begin
          // If there's a selection, treat this
          // like a delete key.
          if (FCaret <> FSelStart) then
          begin
            DeleteSelectionText;
            FDialog.SendEvent(z3dceEditChange, True, Self);
          end else
          if (FCaret > 0) then
          begin
            // Move the caret, then delete the char.
            PlaceCaret(FCaret - 1);
            FSelStart := FCaret;
            m_Buffer.RemoveChar(FCaret);
            FDialog.SendEvent(z3dceEditChange, True, Self);
          end;
          ResetCaretBlink;
        end;

        24,        // Ctrl-X Cut
        VK_CANCEL: // Ctrl-C Copy
        begin
          CopyToClipboard;

          // If the key is Ctrl-X, delete the selection too.
          if (wParam = 24) then
          begin
            DeleteSelectionText;
            FDialog.SendEvent(z3dceEditChange, True, Self);
          end;
        end;

        // Ctrl-V Paste
        22:
        begin
          PasteFromClipboard;
          FDialog.SendEvent(z3dceEditChange, True, Self);
        end;

        // Ctrl-A Select All
        1:
        begin
          if (FSelStart = FCaret) then
          begin
            FSelStart := 0;
            PlaceCaret(m_Buffer.TextSize);
          end;
        end;

        VK_RETURN:
          // Invoke the callback when the user presses Enter.
          FDialog.SendEvent(z3dceEditString, True, Self);

        // Junk characters we don't want in the string
        26,  // Ctrl Z
        2,   // Ctrl B
        14,  // Ctrl N
        19,  // Ctrl S
        4,   // Ctrl D
        6,   // Ctrl F
        7,   // Ctrl G
        10,  // Ctrl J
        11,  // Ctrl K
        12,  // Ctrl L
        17,  // Ctrl Q
        23,  // Ctrl W
        5,   // Ctrl E
        18,  // Ctrl R
        20,  // Ctrl T
        25,  // Ctrl Y
        21,  // Ctrl U
        9,   // Ctrl I
        15,  // Ctrl O
        16,  // Ctrl P
        27,  // Ctrl [
        29,  // Ctrl ]
        28:  // Ctrl \
          {Do Nothing};

      else {case}
        // If there's a selection and the user
        // starts to type, the selection should
        // be deleted.
        if (FCaret <> FSelStart) then DeleteSelectionText;

        // If we are in overwrite mode and there is already
        // a char at the caret's position, simply replace it.
        // Otherwise, we insert the char as normal.
        if not FInsertMode and (FCaret < m_Buffer.TextSize) then
        begin
          m_Buffer[FCaret] := WideChar(wParam);
          PlaceCaret(FCaret + 1);
          FSelStart := FCaret;
        end else
        begin
          // Insert the char
          if m_Buffer.InsertChar(FCaret, WideChar(wParam)) then
          begin
            PlaceCaret(FCaret + 1);
            FSelStart := FCaret;
          end;
        end;
        ResetCaretBlink;
        FDialog.SendEvent(z3dceEditChange, True, Self);
      end;
      Result:= True;
      Exit;
    end;
  end;
  Result:= False;
end;

procedure Tz3DEdit.Render;
var
  nSelStartX, nCaretX: Integer ;  // Left and right X cordinates of the selection region
  pDisplay: Iz3DDisplay;
  e: Integer;
  nXFirst: Integer;
  rcSelection: TRect;  // Make this available for rendering selected text
  nSelLeftX, nSelRightX: Integer;
  nTemp: Integer;
  nFirstToRender: Integer;
  nNumChatToRender: Integer;
  rcCaret: TRect;
  nRightEdgeX: Integer;
begin
  if not FVisible then Exit;

  nSelStartX := 0; nCaretX := 0;  // Left and right X cordinates of the selection region

  pDisplay := GetDisplay(0);
  if (pDisplay <> nil) then
  begin
    m_Buffer.FontNode := FDialog.GetFont(pDisplay.Font);
    PlaceCaret(FCaret);  // Call PlaceCaret now that we have the font info (node),
                           // so that scrolling can be handled.
  end;

  // Render the control graphics
  for e := 0 to 8 do
  begin
    pDisplay := m_Displays[e];
    pDisplay.TextureColor.Blend(z3dcsNormal);

    FDialog.DrawSprite(pDisplay, FRender[e]);
  end;

  //
  // Compute the X coordinates of the first visible character.
  //
  m_Buffer.CPtoX(FFirstVisible, FALSE, nXFirst );

  //
  // Compute the X coordinates of the selection rectangle
  //
  {hr := }m_Buffer.CPtoX(FCaret, False, nCaretX);
  if (FCaret <> FSelStart)
  then {hr := }m_Buffer.CPtoX(FSelStart, False, nSelStartX)
  else nSelStartX := nCaretX;

  //
  // Render the selection rectangle
  //
  if (FCaret <> FSelStart) then
  begin
    nSelLeftX := nCaretX; nSelRightX := nSelStartX;
    // Swap if left is bigger than right
    if (nSelLeftX > nSelRightX) then
    begin
      nTemp := nSelLeftX;
      nSelLeftX := nSelRightX;
      nSelRightX := nTemp;
    end;

    SetRect(rcSelection, nSelLeftX, FText.top, nSelRightX, FText.bottom);
    OffsetRect(rcSelection, FText.left - nXFirst, 0);
    IntersectRect(rcSelection, FText, rcSelection);
    FDialog.DrawRect(rcSelection, m_SelBkColor);
  end;

  //
  // Render the text
  //
  // Display 0 for text
  m_Displays[0].FontColor.Current := D3DXColorFromDWord(m_TextColor);
  FDialog.DrawText(m_Buffer.Buffer + FFirstVisible, m_Displays[0], FText);

  // Render the selected text
  if (FCaret <> FSelStart) then
  begin
    nFirstToRender := Max(FFirstVisible, Min( FSelStart, FCaret));
    nNumChatToRender := Max(FSelStart, FCaret) - nFirstToRender;
    m_Displays[0].FontColor.Current := D3DXColorFromDWord(m_SelTextColor);
    FDialog.DrawText(m_Buffer.Buffer + nFirstToRender,
                       m_Displays[0], rcSelection, False, nNumChatToRender);
  end;

  //
  // Blink the caret
  //
  if (z3DCore_GetGlobalTimer.AbsoluteTime - m_dfLastBlink >= m_dfBlink) then
  begin
    FCaretOn := not FCaretOn;
    m_dfLastBlink := z3DCore_GetGlobalTimer.AbsoluteTime;
  end;

  //
  // Render the caret if this control has the focus
  //
  if (FHasFocus and FCaretOn and not s_bHideCaret) then
  begin
    // Start the rectangle with insert mode caret
    rcCaret := Rect(FText.left - nXFirst + nCaretX - 1, FText.top,
                    FText.left - nXFirst + nCaretX + 1, FText.bottom);

    // If we are in overwrite mode, adjust the caret rectangle
    // to fill the entire character.
    if (not FInsertMode) then
    begin
      // Obtain the right edge X coord of the current character
      m_Buffer.CPtoX(FCaret, True, nRightEdgeX);
      rcCaret.right := FText.left - nXFirst + nRightEdgeX;
    end;

    FDialog.DrawRect(rcCaret, m_CaretColor);
  end;
end;

function IN_FLOAT_CHARSET(c: WideChar): Boolean;
begin
  Result:= (c = '-') or (c = '.') or (c >= '0') or (c <= '9');
end;

procedure Tz3DEdit.ParseFloatArray(pNumbers: PSingle; nCount: Integer);
{$IFDEF FPC}
begin // this function is not used anyway
end;
#else

var
  nWritten: Integer;  // Number of floats written
  {const }pToken, pEnd: PWideChar;
  wszToken: array [0..59] of WideChar;
  nTokenLen: Integer;
begin
  nWritten := 0;  // Number of floats written

  pToken := m_Buffer.Buffer;
  while (nWritten < nCount) and (pToken^ <> #0) do
  begin
    // Skip leading spaces
    while (pToken^ = ' ') do Inc(pToken);

    if (pToken^ = #0) then Break;

    // Locate the end of number
    pEnd := pToken;
    while IN_FLOAT_CHARSET(pEnd^) do Inc(pEnd);

    // Copy the token to our buffer
    nTokenLen := Min(SizeOf(wszToken) div SizeOf(wszToken[0]) - 1, Integer(pEnd - pToken));
    StringCchCopy(wszToken, nTokenLen, pToken);
    #ifdef  COMPILER6_UP

    pNumbers^ := StrToFloatDef(wszToken, 0);
    #else

    try
      pNumbers^ := StrToFloat(wszToken);
    except
      pNumbers^ := 0;
    end;
    #endif

    Inc(nWritten);
    Inc(pNumbers);
    pToken := pEnd;
  end;
end;
#endif


procedure Tz3DEdit.SetTextFloatArray(pNumbers: PSingle; nCount: Integer);
var
  wszBuffer: array[0..511] of WideChar{ = 0};
  wszTmp:array[0..63] of WideChar;
  i: Integer;
begin
  if (pNumbers = nil) then Exit;

  for i := 0 to nCount - 1 do
  begin
    //StringCchFormat(wszTmp, 64, '%.4f ', [pNumbers[i]]);
    StringCchFormat(wszTmp, 64, PWideChar(WideString('%.4f ')), [pNumbers^]); Inc(pNumbers);
    StringCchCat(wszBuffer, 512, wszTmp);
  end;

  // Don't want the last space
  if (nCount > 0) and (lstrlenW(wszBuffer) > 0)
  then wszBuffer[lstrlenW(wszBuffer)-1] := #0;

  SetText(wszBuffer);
end;

function Tz3DEdit.CanHaveFocus: Boolean;
begin
  Result:= (FVisible and FEnabled);
end;


function Tz3DEdit.GetText: PWideChar;
begin
  Result:= m_Buffer.Buffer;
end;

function Tz3DEdit.GetTextLength: Integer;
begin
  Result:= m_Buffer.TextSize; // Returns text length in chars excluding nil.
end;

procedure Tz3DEdit.ResetCaretBlink;
begin
  FCaretOn := True;
  m_dfLastBlink := z3DCore_GetGlobalTimer.AbsoluteTime;
end;


// Text color
procedure Tz3DEdit.SetTextColor(Color: TD3DColor);
begin
  m_TextColor := Color;
end;

procedure Tz3DEdit.SetBorderWidth(nBorder: Integer);
begin
  FBorder := nBorder;
  UpdateRects; // Border of the window
end;


procedure Tz3DEdit.SetSpacing(nSpacing: Integer);
begin
  FSpacing := nSpacing;
  UpdateRects;
end;

procedure Tz3DEdit.SetText_p(wszText: PWideChar);
begin
  SetText(wszText, False);
end;

var
  s_hDllImm32: THandle;  // IMM32 DLL handle
  s_hDllVer: THandle;    // Version DLL handle
  s_hImcDef: HIMC;       // Default input context

// Empty implementation of the IMM32 API
type
  HIMCC = HIMC;
  
  // tagINPUTCONTEXT - from Windows 98/Me: Windows DDK
  tagINPUTCONTEXT = record
    hWnd:   HWND;
    fOpen:   BOOL;
    ptStatusWndPos:  TPOINT;
    ptSoftKbdPos:  TPOINT;
    fdwConversion:  DWORD;
    fdwSentence:  DWORD;
    (* union {
        LOGFONTA  A;
        LOGFONTW  W;
    } lfFont; *)
    W: TLogFontW;
    cfCompForm: COMPOSITIONFORM;
    cfCandForm: array[0..3] of CANDIDATEFORM;
    hCompStr:  HIMCC;
    hCandInfo:  HIMCC;
    hGuideLine:  HIMCC;
    hPrivate:  HIMCC;
    dwNumMsgBuf: DWORD;
    hMsgBuf:  HIMCC;
    fdwInit:  DWORD;
    dwReserve: array[0..2] of DWORD;
  end;
  EXTERNAL
  TInputContext = tagINPUTCONTEXT;
  PInputContext = ^TInputContext;

  
function Dummy_ImmLockIMC(imc: HIMC): PINPUTCONTEXT; stdcall;  begin Result:= nil; end;
function Dummy_ImmUnlockIMC(imc: HIMC): BOOL; stdcall;         begin Result:= FALSE; end;
function Dummy_ImmLockIMCC(imcc: HIMCC): Pointer; stdcall;     begin Result:= nil; end;
function Dummy_ImmUnlockIMCC(imcc: HIMCC): BOOL; stdcall;      begin Result:= FALSE; end;
function Dummy_ImmDisableTextFrameService(d: DWORD): BOOL; stdcall; begin Result:= TRUE; end;
function Dummy_ImmGetCompositionStringW(hImc: HIMC; dWord1: DWORD; lpBuf: pointer; dwBufLen: DWORD): Longint; stdcall; begin Result:= IMM_ERROR_GENERAL; end;
function Dummy_ImmGetCandidateListW(hImc: HIMC; deIndex: DWORD; lpCandidateList: PCandidateList; dwBufLen: DWORD): DWORD; stdcall; begin Result:= 0; end;
function Dummy_ImmGetContext(hWnd: HWND): HIMC; stdcall; begin Result:= 0; end;
function Dummy_ImmReleaseContext(hWnd: HWND; hImc: HIMC): Boolean; stdcall; begin Result:= FALSE; end;
function Dummy_ImmAssociateContext(hWnd: HWND; hImc: HIMC): HIMC; stdcall; begin Result:= 0; end;
function Dummy_ImmGetOpenStatus(hImc: HIMC): Boolean; stdcall; begin Result:= False; end;
function Dummy_ImmSetOpenStatus(hImc: HIMC; fOpen: Boolean): Boolean; stdcall; begin Result:= False; end;
function Dummy_ImmGetConversionStatus(hImc: HIMC; var Conversion, Sentence: DWORD): Boolean; stdcall; begin Result:= False; end;
function Dummy_ImmGetDefaultIMEWnd(hWnd: HWND): HWND; stdcall; begin Result:= 0; end;
function Dummy_ImmGetIMEFileNameA(hKl: HKL; PAnsiChar: PAnsiChar; uBufLen: UINT): UINT; stdcall; begin Result:= 0; end;
function Dummy_ImmGetVirtualKey(hWnd: HWND): UINT; stdcall; begin Result:= 0; end;
function Dummy_ImmNotifyIME(hImc: HIMC; dwAction, dwIndex, dwValue: DWORD): Boolean; stdcall; begin Result:= FALSE; end;
function Dummy_ImmSetConversionStatus(hImc: HIMC; Conversion, Sentence: DWORD): Boolean; stdcall; begin Result:= FALSE; end;
function Dummy_ImmSimulateHotKey(hWnd: HWND; dWord: DWORD): Boolean; stdcall; begin Result:= FALSE; end;
function Dummy_ImmIsIME(hKl: HKL): Boolean; stdcall;begin Result:= FALSE; end;

// Traditional Chinese IME
function Dummy_GetReadingString(himc: HIMC; u: UINT; w: PWideChar; i: PInteger; b: PBOOL; pu: PUINT): LongWord; begin Result:= 0; end;
function Dummy_ShowReadingWindow(imc: HIMC; b: BOOL): BOOL; begin Result:= FALSE; end;

// Verion library imports
function Dummy_VerQueryValueA(const p: Pointer; s: PAnsiChar; pp: PPointer; i: PUINT): BOOL; stdcall; begin Result:= False; end;
function Dummy_GetFileVersionInfoA(s: PChar; d1, d2: DWORD; p: Pointer): DWORD; stdcall; begin Result:= iFalse; end;
function Dummy_GetFileVersionInfoSizeA(s: PChar; var d: DWORD): DWORD; stdcall; begin Result:= 0; end;

var
  // Function pointers: IMM32
  _ImmLockIMC: function (imc: HIMC): PINPUTCONTEXT; stdcall = Dummy_ImmLockIMC;
  _ImmUnlockIMC: function (imc: HIMC): BOOL; stdcall = Dummy_ImmUnlockIMC;
  _ImmLockIMCC: function (imcc: HIMCC): Pointer; stdcall = Dummy_ImmLockIMCC;
  _ImmUnlockIMCC: function (imcc: HIMCC): BOOL; stdcall = Dummy_ImmUnlockIMCC;
  _ImmDisableTextFrameService: function (d: DWORD): BOOL; stdcall = Dummy_ImmDisableTextFrameService;
  _ImmGetCompositionStringW: function (hImc: HIMC; dWord1: DWORD; lpBuf: pointer; dwBufLen: DWORD): Longint; stdcall = Dummy_ImmGetCompositionStringW;
  _ImmGetCandidateListW: function (hImc: HIMC; deIndex: DWORD; lpCandidateList: PCandidateList; dwBufLen: DWORD): DWORD; stdcall = Dummy_ImmGetCandidateListW;
  _ImmGetContext: function (hWnd: HWND): HIMC; stdcall = Dummy_ImmGetContext;
  _ImmReleaseContext: function (hWnd: HWND; hImc: HIMC): Boolean; stdcall = Dummy_ImmReleaseContext;
  _ImmAssociateContext: function (hWnd: HWND; hImc: HIMC): HIMC; stdcall = Dummy_ImmAssociateContext;
  _ImmGetOpenStatus: function (hImc: HIMC): Boolean; stdcall = Dummy_ImmGetOpenStatus;
  _ImmSetOpenStatus: function (hImc: HIMC; fOpen: Boolean): Boolean; stdcall = Dummy_ImmSetOpenStatus;
  _ImmGetConversionStatus: function (hImc: HIMC; var Conversion, Sentence: DWORD): Boolean; stdcall = Dummy_ImmGetConversionStatus;
  _ImmGetDefaultIMEWnd: function (hWnd: HWND): HWND; stdcall = Dummy_ImmGetDefaultIMEWnd;
  _ImmGetIMEFileNameA: function (hKl: HKL; PAnsiChar: PAnsiChar; uBufLen: UINT): UINT; stdcall = Dummy_ImmGetIMEFileNameA;
  _ImmGetVirtualKey: function (hWnd: HWND): UINT; stdcall = Dummy_ImmGetVirtualKey;
  _ImmNotifyIME: function (hImc: HIMC; dwAction, dwIndex, dwValue: DWORD): Boolean; stdcall = Dummy_ImmNotifyIME;
  _ImmSetConversionStatus: function (hImc: HIMC; Conversion, Sentence: DWORD): Boolean; stdcall = Dummy_ImmSetConversionStatus;
  _ImmSimulateHotKey: function (hWnd: HWND; dWord: DWORD): Boolean; stdcall = Dummy_ImmSimulateHotKey;
  _ImmIsIME: function (hKl: HKL): Boolean; stdcall = Dummy_ImmIsIME;

  // Function pointers: Traditional Chinese IME
  _GetReadingString: function (himc: HIMC; u: UINT; w: PWideChar; i: PInteger; b: PBOOL; pu: PUINT): LongWord = Dummy_GetReadingString;
  _ShowReadingWindow: function (imc: HIMC; b: BOOL): BOOL = Dummy_ShowReadingWindow;

  // Function pointers: Verion library imports
  _VerQueryValueA: function (const p: Pointer; s: PAnsiChar; pp: PPointer; i: PUINT): BOOL; stdcall = Dummy_VerQueryValueA;
  _GetFileVersionInfoA: function (s: PChar; d1, d2: DWORD; p: Pointer): DWORD; stdcall = Dummy_GetFileVersionInfoA;
  _GetFileVersionInfoSizeA: function (s: PChar; var d: DWORD): DWORD; stdcall = Dummy_GetFileVersionInfoSizeA;

var
  // Application-wide data
  s_hklCurrent: HKL;             // Current keyboard layout of the process
  s_bVerticalCand: Boolean;      // Indicates that the candidates are listed vertically
  s_aszIndicator: array[Low(TIndicatorEnum)..High(TIndicatorEnum), 0..2] of WideChar = (
    ('E','n', #0),
    (#$7B80, #0, #0),
    (#$7E41, #0, #0),
    (#$AC00, #0, #0),
    (#$3042, #0, #0)); // String to draw to indicate current input locale
  {$IFDEF FPC}
  s_wszCurrIndicator: PWideChar;
  #else

  s_wszCurrIndicator: PWideChar = @s_aszIndicator[Low(TIndicatorEnum)]; // Points to an indicator string that corresponds to current input locale
  #endif

  s_bInsertOnType: Boolean;      // Insert the character as soon as a key is pressed (Korean behavior)
  s_hDllIme: THandle{HINSTANCE}; // Instance handle of the current IME module
  s_ImeState: TImeState;         // IME global state
  s_bEnableImeSystem: Boolean;   // Whether the IME system is active
  s_ptCompString: TPoint;        // Composition string position. Updated every frame.
  s_nCompCaret: Integer;         // Caret position of the composition string
  s_nFirstTargetConv: Integer;   // Index of the first target converted char in comp string.  If none, -1.
  s_CompString: Iz3DUniBuffer;      // Buffer to hold the composition string (we fix its length)
  s_abCompStringAttr: array[0..MAX_COMPSTRING_SIZE-1] of Byte;
  s_adwCompStringClause: array[0..MAX_COMPSTRING_SIZE-1] of DWORD;
  s_wszReadingString: array[0..31] of WideChar; // Used only with horizontal reading window (why?)
  s_CandList: TCandList;  // Data relevant to the candidate list
  s_bShowReadingWindow: Boolean; // Indicates whether reading window is visible
  s_bHorizontalReading: Boolean; // Indicates whether the reading window is vertical or horizontal
  s_bChineseIME: BOOL;
  s_Locale: array of TInputLocale; // Array of loaded keyboard layout on system
#ifdef  DEBUG

  FIMEStaticMsgProcCalled: Boolean = False;
#endif



const
  // IME constants
  CHT_IMEFILENAME1    = 'TINTLGNT.IME'; // New Phonetic
  CHT_IMEFILENAME2    = 'CINTLGNT.IME'; // New Chang Jie
  CHT_IMEFILENAME3    = 'MSTCIPHA.IME'; // Phonetic 5.1
  CHS_IMEFILENAME1    = 'PINTLGNT.IME'; // MSPY1.5/2/3
  CHS_IMEFILENAME2    = 'MSSCIPYA.IME'; // MSPY3 for OfficeXP

  LANG_CHT            = (SUBLANG_CHINESE_TRADITIONAL shl 10) or LANG_CHINESE; // MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL);
  LANG_CHS            = (SUBLANG_CHINESE_SIMPLIFIED  shl 10) or LANG_CHINESE; // MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED);
  _CHT_HKL            = HKL($E0080404); // New Phonetic
  _CHT_HKL2           = HKL($E0090404); // New Chang Jie
  _CHS_HKL            = HKL($E00E0804); // MSPY

{#define MAKEIMEVERSION( major, minor ) \
    ( (DWORD)( ( (BYTE)( major ) << 24 ) | ( (BYTE)( minor ) << 16 ) ) )}
function MAKEIMEVERSION(major, minor: Byte): DWORD;
begin
  Result:= (major shl 24) or (minor shl 16);
end;

const
  IMEID_CHT_VER42 = LANG_CHT or (4 shl 24 or 2 shl 16); // 4, 2 ) )	// New(Phonetic/ChanJie)IME98  : 4.2.x.x // Win98
  IMEID_CHT_VER43 = LANG_CHT or (4 shl 24 or 3 shl 16); // 4, 3 ) )	// New(Phonetic/ChanJie)IME98a : 4.3.x.x // Win2k
  IMEID_CHT_VER44 = LANG_CHT or (4 shl 24 or 4 shl 16); // 4, 4 ) )	// New ChanJie IME98b          : 4.4.x.x // WinXP
  IMEID_CHT_VER50 = LANG_CHT or (5 shl 24 or 0 shl 16); // 5, 0 ) )	// New(Phonetic/ChanJie)IME5.0 : 5.0.x.x // WinME
  IMEID_CHT_VER51 = LANG_CHT or (5 shl 24 or 1 shl 16); // 5, 1 ) )	// New(Phonetic/ChanJie)IME5.1 : 5.1.x.x // IME2002(w/OfficeXP)
  IMEID_CHT_VER52 = LANG_CHT or (5 shl 24 or 2 shl 16); // 5, 2 ) )	// New(Phonetic/ChanJie)IME5.2 : 5.2.x.x // IME2002a(w/Whistler)
  IMEID_CHT_VER60 = LANG_CHT or (6 shl 24 or 0 shl 16); // 6, 0 ) )	// New(Phonetic/ChanJie)IME6.0 : 6.0.x.x // IME XP(w/WinXP SP1)
  IMEID_CHS_VER41	= LANG_CHS or (4 shl 24 or 1 shl 16); // 4, 1 ) )	// MSPY1.5	// SCIME97 or MSPY1.5 (w/Win98, Office97)
  IMEID_CHS_VER42	= LANG_CHS or (4 shl 24 or 2 shl 16); // 4, 2 ) )	// MSPY2	// Win2k/WinME
  IMEID_CHS_VER53	= LANG_CHS or (5 shl 24 or 3 shl 16); // 5, 3 ) )	// MSPY3	// WinXP


{ Tz3DIMEEditBox }


constructor Tz3DIMEEditBox.Create(const pDialog: Iz3DDialog);
begin
  inherited;
  Tz3DIMEEditBox.Initialize; // ensure static vars are properly init'ed first
  _ImmDisableTextFrameService(DWORD(-1));  // Disable TSF for the current process

  m_Type := z3dctIMEEdit;
  FDialog := pDialog;

  s_bEnableImeSystem := True;
  FIndicatorWidth := 0;
  m_ReadingColor := D3DCOLOR_ARGB(188, 255, 255, 255);
  m_ReadingWinColor := D3DCOLOR_ARGB(128, 0, 0, 0);
  m_ReadingSelColor := D3DCOLOR_ARGB(255, 255, 0, 0);
  m_ReadingSelBkColor := D3DCOLOR_ARGB(128, 80, 80, 80);
  m_CandidateColor := D3DCOLOR_ARGB(255, 200, 200, 200);
  m_CandidateWinColor := D3DCOLOR_ARGB(128, 0, 0, 0);
  m_CandidateSelColor := D3DCOLOR_ARGB(255, 255, 255, 255);
  m_CandidateSelBkColor := D3DCOLOR_ARGB(128, 158, 158, 158);
  m_CompColor := D3DCOLOR_ARGB(255, 200, 200, 255);
  m_CompWinColor := D3DCOLOR_ARGB(198, 0, 0, 0);
  m_CompCaretColor := D3DCOLOR_ARGB(255, 255, 255, 255);
  m_CompTargetColor := D3DCOLOR_ARGB(255, 255, 255, 255);
  m_CompTargetBkColor := D3DCOLOR_ARGB(255, 150, 150, 150);
  m_CompTargetNonColor := D3DCOLOR_ARGB(255, 255, 255, 0);
  m_CompTargetNonBkColor := D3DCOLOR_ARGB(255, 150, 150, 150);
  m_IndicatorImeColor := D3DCOLOR_ARGB(255, 255, 255, 255);
  m_IndicatorEngColor := D3DCOLOR_ARGB(255, 0, 0, 0);
  m_IndicatorBkColor := D3DCOLOR_ARGB(255, 128, 128, 128);
end;

destructor Tz3DIMEEditBox.Destroy;
begin
  inherited;
end;

class procedure Tz3DIMEEditBox.SendKey(nVirtKey: Byte);
begin
  keybd_event(nVirtKey, 0, 0,               0);
  keybd_event(nVirtKey, 0, KEYEVENTF_KEYUP, 0);
end;

class function Tz3DIMEEditBox.StaticOnCreateDevice: HRESULT;
begin
  s_hImcDef := _ImmGetContext(z3DCore_GetHWND);
  _ImmReleaseContext(z3DCore_GetHWND, s_hImcDef);

  Result:= S_OK;
end;

procedure Tz3DIMEEditBox.UpdateRects;
var
  nWidth: Integer;
begin
  nWidth := FWidth;
  Dec(FWidth, FIndicatorWidth + FBorder * 2); // Make room for the indicator button
  inherited;
  FWidth := nWidth;  // Restore

  // Compute the indicator button rectangle
  SetRect(FIndicator, FBoundingBox.right, FBoundingBox.top, FLeft + FWidth, FBoundingBox.bottom);
// InflateRect( &FIndicator, -FBorder, -FBorder );
  FBoundingBox.right := FBoundingBox.left + FWidth;
end;

//    MAKELCID            - construct the locale id from a language id and a sort id.
//#define MAKELCID(lgid, srtid)  ((DWORD)((((DWORD)((WORD  )(srtid))) << 16) |  \
//                                         ((DWORD)((WORD  )(lgid)))))
function MAKELCID(lgid, srtid: Word): DWORD;
begin
  Result:= (srtid shl 16) or lgid;
end;

//    MAKELANGID    - construct language id from a primary language id and
//                    a sublanguage id.
//#define MAKELANGID(p, s)       ((((WORD  )(s)) << 10) | (WORD  )(p))
function MAKELANGID(p, s: Word): Word;
begin
  Result:= (s shl 10) or p;
end;

const
  NORM_IGNORECASE      			= $00000001;     {* ignore case *}
//  NORM_IGNORENONSPACE  			= $00000002;     {* ignore diacritics *}
//  NORM_IGNORESYMBOLS   			= $00000004;     {* ignore symbols *}


//	GetImeId( UINT uIndex )
//		returns
//	returned value:
//	0: In the following cases
//		- Non Chinese IME input locale
//		- Older Chinese IME
//		- Other error cases
//
//	Othewise:
//      When uIndex is 0 (default)
//			bit 31-24:	Major version
//			bit 23-16:	Minor version
//			bit 15-0:	Language ID
//		When uIndex is 1
//			pVerFixedInfo->dwFileVersionLS
//
//	Use IMEID_VER and IMEID_LANG macro to extract version and language information.
//	

// We define the locale-invariant ID ourselves since it doesn't exist prior to WinXP
// For more information, see the CompareString() reference.
const
  // LCID_INVARIANT = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT)
  LCID_INVARIANT = (SORT_DEFAULT shl 16) or (SUBLANG_ENGLISH_US shl 10) or LANG_ENGLISH;

var
  GetImeId_hklPrev: HKL = 0;
  dwID: array[0..1] of DWORD = (0, 0);

class function Tz3DIMEEditBox.GetImeId(uIndex: LongWord): DWORD;
var
  dwVerSize: DWORD;
  dwVerHandle: DWORD;
  lpVerBuffer: Pointer;
  lpVerData: Pointer;
  cbVerData: LongWord;
  szTmp: array[0..1023] of Char;
  dwVer: DWORD;
begin
  if (uIndex >= SizeOf(dwID) div SizeOf(dwID[0])) then
  begin
    Result:= 0;
    Exit;
  end;

  if (GetImeId_hklPrev = s_hklCurrent) then
  begin
    Result:= dwID[uIndex];
    Exit;
  end;

  GetImeId_hklPrev := s_hklCurrent;  // Save for the next invocation

  // Check if we are using an older Chinese IME
  if not ( (s_hklCurrent = _CHT_HKL) or (s_hklCurrent = _CHT_HKL2) or (s_hklCurrent = _CHS_HKL) ) then
  begin
    dwID[1] := 0;
    dwID[0] := 0;
    Result:= dwID[uIndex];
    Exit;
  end;

  // Obtain the IME file name
  if _ImmGetIMEFileNameA(s_hklCurrent, szTmp, (SizeOf(szTmp) div SizeOf(szTmp[0])) - 1 ) = 0 then
  begin
    dwID[1] := 0;
    dwID[0] := 0;
    Result:= dwID[uIndex];
    Exit;
  end;

  // Check for IME that doesn't implement reading string API
  if (@_GetReadingString = nil) then
  begin
    if (CompareStringA(LCID_INVARIANT, NORM_IGNORECASE, szTmp, -1, CHT_IMEFILENAME1, -1) <> CSTR_EQUAL) and
       (CompareStringA(LCID_INVARIANT, NORM_IGNORECASE, szTmp, -1, CHT_IMEFILENAME2, -1) <> CSTR_EQUAL) and
       (CompareStringA(LCID_INVARIANT, NORM_IGNORECASE, szTmp, -1, CHT_IMEFILENAME3, -1) <> CSTR_EQUAL) and
       (CompareStringA(LCID_INVARIANT, NORM_IGNORECASE, szTmp, -1, CHS_IMEFILENAME1, -1) <> CSTR_EQUAL) and
       (CompareStringA(LCID_INVARIANT, NORM_IGNORECASE, szTmp, -1, CHS_IMEFILENAME2, -1) <> CSTR_EQUAL) then
    begin
      dwID[1] := 0;
      dwID[0] := 0;
      Result:= dwID[uIndex];
      Exit;
    end;
  end;

  dwVerSize := _GetFileVersionInfoSizeA(szTmp, dwVerHandle);
  if (dwVerSize <> 0) then
  begin
    lpVerBuffer := HeapAlloc(GetProcessHeap, 0, dwVerSize);
    if (lpVerBuffer <> nil) then
    begin
      if _GetFileVersionInfoA(szTmp, dwVerHandle, dwVerSize, lpVerBuffer) <> 0 then
      begin
        if _VerQueryValueA(lpVerBuffer, '\', @lpVerData, @cbVerData) then
        begin
          dwVer := PVSFixedFileInfo(lpVerData).dwFileVersionMS;
          dwVer := (dwVer and $00ff0000) shl 8 or (dwVer and $000000ff) shl 16;
          if (@_GetReadingString <> nil)
              or
             ((GetLanguage = LANG_CHT) and
               ((dwVer = MAKEIMEVERSION(4, 2)) or
                (dwVer = MAKEIMEVERSION(4, 3)) or
                (dwVer = MAKEIMEVERSION(4, 4)) or
                (dwVer = MAKEIMEVERSION(5, 0)) or
                (dwVer = MAKEIMEVERSION(5, 1)) or
                (dwVer = MAKEIMEVERSION(5, 2)) or
                (dwVer = MAKEIMEVERSION(6, 0))))
              or
             ((GetLanguage = LANG_CHS) and
              ((dwVer = MAKEIMEVERSION(4, 1)) or
               (dwVer = MAKEIMEVERSION(4, 2)) or
               (dwVer = MAKEIMEVERSION(5, 3))))
            then
          begin
            dwID[0] := dwVer or GetLanguage;
            dwID[1] := PVSFixedFileInfo(lpVerData).dwFileVersionLS;
          end;
        end;
      end;
      HeapFree(GetProcessHeap, 0, lpVerBuffer);
    end;
  end;

  Result:= dwID[uIndex];
end;


{*---------------------------------------------------------------------*
Name            _ltowlower - translates wide-characters to lower-case
Usage           wchar_t _ltowlower(wchar_t c);
Prototype in    _ltowlower is a function that converts a wide-character c
                to its lower-case value according to the current locale
Return value    returns the converted value of c, on success, and
                nothing on failure.
*---------------------------------------------------------------------*}
function towlower(ch: WideChar): WideChar;
begin
  CharLowerBuffW(@ch, 1);
  Result:= ch;
  // LCMapString(locale->handle, LCMAP_LOWERCASE, (LPCSTR) &ch, 1, (LPTSTR)&result, sizeof(result));
end;

var
  CheckInputLocale_hklPrev: HKL = 0;
class procedure Tz3DIMEEditBox.CheckInputLocale;
var
  wszLang: array[0..4] of WideChar;
begin
  // static HKL hklPrev = 0;
  s_hklCurrent := GetKeyboardLayout(0);
  if (CheckInputLocale_hklPrev = s_hklCurrent) then Exit;

  CheckInputLocale_hklPrev := s_hklCurrent;
  case GetPrimaryLanguage of
    // Simplified Chinese
    LANG_CHINESE:
    begin
      s_bVerticalCand := True;
      case GetSubLanguage of
        SUBLANG_CHINESE_SIMPLIFIED:
        begin
          s_wszCurrIndicator := s_aszIndicator[INDICATOR_CHS];
          s_bVerticalCand := (GetImeId = 0);
        end;
        SUBLANG_CHINESE_TRADITIONAL:
          s_wszCurrIndicator := s_aszIndicator[INDICATOR_CHT];
      else {case}
        // unsupported sub-language
        s_wszCurrIndicator := s_aszIndicator[INDICATOR_NON_IME];
      end;
    end;

    // Korean
    LANG_KOREAN:
    begin
      s_wszCurrIndicator := s_aszIndicator[INDICATOR_KOREAN];
      s_bVerticalCand := False;
    end;

    // Japanese
    LANG_JAPANESE:
    begin
      s_wszCurrIndicator := s_aszIndicator[INDICATOR_JAPANESE];
      s_bVerticalCand := True;
    end;

  else {case GetPrimaryLanguage}
    // A non-IME language.  Obtain the language abbreviation
    // and store it for rendering the indicator later.
    s_wszCurrIndicator := s_aszIndicator[INDICATOR_NON_IME];
  end;

  // If non-IME, use the language abbreviation.
  if (s_wszCurrIndicator = @s_aszIndicator[INDICATOR_NON_IME]) then
  begin
    GetLocaleInfoW(MAKELCID(LOWORD(s_hklCurrent), SORT_DEFAULT), LOCALE_SABBREVLANGNAME, wszLang, 5);
    s_wszCurrIndicator[0] := wszLang[0];
    s_wszCurrIndicator[1] := towlower(wszLang[1]);
  end;
end;

class procedure Tz3DIMEEditBox.CheckToggleState;
var
  bIme: Boolean;
  hImc: Imm.HIMC;
  dwConvMode, dwSentMode: DWORD;
begin
  CheckInputLocale;
  bIme := _ImmIsIME(s_hklCurrent);
  s_bChineseIME := (GetPrimaryLanguage = LANG_CHINESE) and bIme;

  hImc := _ImmGetContext(z3DCore_GetHWND);
  if (0 <> hImc) then
  begin
    if (s_bChineseIME) then
    begin
      _ImmGetConversionStatus(hImc, dwConvMode, dwSentMode);
      if (dwConvMode and IME_CMODE_NATIVE <> 0)
        then s_ImeState := IMEUI_STATE_ON
        else s_ImeState := IMEUI_STATE_ENGLISH;
    end else
    begin
      if (bIme and _ImmGetOpenStatus(hImc))
        then s_ImeState := IMEUI_STATE_ON
        else s_ImeState := IMEUI_STATE_OFF;
    end;
    _ImmReleaseContext(z3DCore_GetHWND, hImc);
  end
  else
    s_ImeState := IMEUI_STATE_OFF;
end;

// Enable/disable the entire IME system.  When disabled, the default IME handling
// kicks in.
class procedure Tz3DIMEEditBox.EnableImeSystem(bEnable: Boolean);
begin
  s_bEnableImeSystem := bEnable;
end;

// Sets up IME-specific APIs for the IME edit controls.  This is called every time
// the input locale changes.
class procedure Tz3DIMEEditBox.SetupImeApi;
var
  szImeFile: array[0..MAX_PATH] of Char;
begin
  _GetReadingString := nil;
  _ShowReadingWindow := nil;
  if (_ImmGetIMEFileNameA(s_hklCurrent, szImeFile, SizeOf(szImeFile) div SizeOf(szImeFile[0]) - 1) = 0)
  then Exit;

  if (s_hDllIme <> 0) then FreeLibrary(s_hDllIme);
  s_hDllIme := LoadLibraryA(szImeFile);
  if (s_hDllIme = 0) then Exit;

  _GetReadingString := GetProcAddress(s_hDllIme, 'GetReadingString');
  _ShowReadingWindow := GetProcAddress(s_hDllIme, 'ShowReadingWindow');
end;

// Resets the composition string.
class procedure Tz3DIMEEditBox.ResetCompositionString;
begin
  s_nCompCaret := 0;
  s_CompString.SetText('');
  ZeroMemory(@s_abCompStringAttr, SizeOf(s_abCompStringAttr));
end;

// Truncate composition string by sending keystrokes to the window.
procedure Tz3DIMEEditBox.TruncateCompString(bUseBackSpace: Boolean;
  iNewStrLen: Integer);
var
  cc: Integer;
  i: Integer;
begin
  if not s_bInsertOnType then Exit;

  cc := lstrlenW(s_CompString.Buffer);
  Assert((iNewStrLen = 0) or (iNewStrLen >= cc));
  
  // Send right arrow keystrokes to move the caret
  //   to the end of the composition string.
  for i := 0 to (cc - s_nCompCaret) - 1 do
    SendMessage(z3DCore_GetHWND, WM_KEYDOWN, VK_RIGHT, 0);
  SendMessage(z3DCore_GetHWND, WM_KEYUP, VK_RIGHT, 0);

  if (bUseBackSpace or FInsertMode) then iNewStrLen := 0;

  // The caller sets bUseBackSpace to false if there's possibility of sending
  // new composition string to the app right after this function call.
  //
  // If the app is in overwriting mode and new comp string is
  // shorter than current one, delete previous comp string
  // till it's same long as the new one. Then move caret to the beginning of comp string.
  // New comp string will overwrite old one.
  if (iNewStrLen < cc) then
  begin
    for i := 0 to (cc - iNewStrLen) - 1 do 
    begin
      SendMessage(z3DCore_GetHWND, WM_KEYDOWN, VK_BACK, 0);  // Backspace character
      SendMessageW(z3DCore_GetHWND, WM_CHAR, VK_BACK, 0);
    end;
    SendMessage(z3DCore_GetHWND, WM_KEYUP, VK_BACK, 0);
  end else
    iNewStrLen := cc;

  // Move the caret to the beginning by sending left keystrokes
  for i := 0 to iNewStrLen - 1 do
    SendMessage(z3DCore_GetHWND, WM_KEYDOWN, VK_LEFT, 0);
  SendMessage(z3DCore_GetHWND, WM_KEYUP, VK_LEFT, 0);
end;

// Sends the current composition string to the application by sending keystroke
// messages.
procedure Tz3DIMEEditBox.SendCompString;
var
  i: Integer;
begin
  for i := 0 to lstrlenW(s_CompString.Buffer) - 1 do
    MsgProc(WM_CHAR, WPARAM(s_CompString[i]), 0);
end;

// Outputs current composition string then cleans up the composition task.
var
  bProcessing: Boolean = False;

procedure Tz3DIMEEditBox.FinalizeString(bSend: Boolean);
var
  hImc: Imm.HIMC;
  lLength: Longint;
begin
  hImc := _ImmGetContext(z3DCore_GetHWND);
  if (hImc = 0) then Exit;

  if bProcessing then    // avoid infinite recursion
  begin
    z3DTraceDX(UnitName, $FFFF, 0, 'Cz3DIMEEditBox::FinalizeString: Reentrant detected!'#10, False);
    _ImmReleaseContext(z3DCore_GetHWND, hImc);
    Exit;
  end;
  bProcessing := True;

  if not s_bInsertOnType and bSend then
  begin
    // Send composition string to app.
    lLength := lstrlenW(s_CompString.Buffer);
    // In case of CHT IME, don't send the trailing double byte space, if it exists.
    if (GetLanguage = LANG_CHT)
       and (s_CompString[lLength - 1] = #$3000) then
    begin
      s_CompString[lLength - 1] := #0;
    end;
    SendCompString;
  end;

  ResetCompositionString;
  // Clear composition string in IME
  _ImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_CANCEL, 0);
  // the following line is necessary as Korean IME doesn't close cand list
  // when comp string is cancelled.
  _ImmNotifyIME(hImc, NI_CLOSECANDIDATE, 0, 0);
  _ImmReleaseContext(z3DCore_GetHWND, hImc);
  bProcessing := False;
end;

// Determine whether the reading window should be vertical or horizontal.
class procedure Tz3DIMEEditBox.GetReadingWindowOrientation(dwId: DWORD);
var
  wszRegPath: array[0..MAX_PATH-1] of WideChar;
  hKey: Windows.HKEY;
  dwVer: DWORD;
  lRc: Longint;
  dwSize, dwMapping, dwType: DWORD;
begin
  s_bHorizontalReading := (s_hklCurrent = _CHS_HKL) or (s_hklCurrent = _CHT_HKL2) or (dwId = 0);
  if not s_bHorizontalReading and ((dwId and $0000FFFF) = LANG_CHT) then
  begin
    dwVer := dwId and $FFFF0000;
    StringCchCopy(wszRegPath, MAX_PATH, 'software\microsoft\windows\currentversion\');
    if (dwVer >= MAKEIMEVERSION(5, 1))
      then StringCchCat(wszRegPath, MAX_PATH, 'MSTCIPH')
      else StringCchCat(wszRegPath, MAX_PATH, 'TINTLGNT');
    lRc := RegOpenKeyExW(HKEY_CURRENT_USER, wszRegPath, 0, KEY_READ, hKey);
    if (lRc = ERROR_SUCCESS) then
    begin
      dwSize := SizeOf(DWORD);
      lRc := RegQueryValueExW(hKey, 'Keyboard Mapping', nil, @dwType, @dwMapping, @dwSize);
      if (lRc = ERROR_SUCCESS) then
      begin
        if ( (dwVer <= MAKEIMEVERSION(5, 0)) and ( (dwMapping = $22) or (dwMapping = $23) ) )
             or
           ( ( (dwVer = MAKEIMEVERSION(5, 1)) or (dwVer = MAKEIMEVERSION(5, 2) ) and
             ( (dwMapping >= $22) and (dwMapping <= $24) ) ) )
          then
        begin
          s_bHorizontalReading := True;
        end;
      end;
      RegCloseKey(hKey);
    end;
  end;
end;

// Obtain the reading string upon WM_IME_NOTIFY/INM_PRIVATE notification.
class procedure Tz3DIMEEditBox.GetPrivateReadingString;
var
  dwId: DWORD;
  hImc: Imm.HIMC;
  dwReadingStrLen: DWORD;
  dwErr: Integer;
  pwszReadingStringBuffer: PWideChar;  // Buffer for when the IME supports GetReadingString()
  wstr: PWideChar;
  bUnicodeIme: Boolean;  // Whether the IME context component is Unicode.
  lpIC: PInputContext;
  uMaxUiLen: LongWord;
  bVertical: BOOL;
  p: PByte;
  nOffset: Integer;
  osi: TOSVersionInfoW;
  nTcharSize: Integer;
  i: Integer;
  pch: PChar;
  j: DWORD;
  wszCodePage: array[0..7] of WideChar;
  uCodePage: LongWord;  // Default code page
begin
  dwId := GetImeId;
  if (dwId = 0) then
  begin
    s_bShowReadingWindow := False;
    Exit;
  end;

  hImc := _ImmGetContext(z3DCore_GetHWND);
  if (hImc = 0) then
  begin
    s_bShowReadingWindow := False;
    Exit;
  end;


  dwReadingStrLen := 0;
  dwErr := 0;
  pwszReadingStringBuffer := nil;  // Buffer for when the IME supports GetReadingString()
  wstr := nil;
  bUnicodeIme := False;  // Whether the IME context component is Unicode.
  lpIC := nil;

  if (@_GetReadingString <> nil) then
  begin            
    // Obtain the reading string size
    dwReadingStrLen := _GetReadingString(hImc, 0, nil, @dwErr, @bVertical, @uMaxUiLen);
    if (dwReadingStrLen <> 0) then
    begin
      pwszReadingStringBuffer := HeapAlloc(GetProcessHeap, 0, SizeOf(WideChar) * dwReadingStrLen);
      wstr := pwszReadingStringBuffer;
      if (pwszReadingStringBuffer = nil) then
      begin
        // Out of memory. Exit.
        _ImmReleaseContext(z3DCore_GetHWND, hImc);
        Exit;
      end;

      // Obtain the reading string
      dwReadingStrLen := _GetReadingString(hImc, dwReadingStrLen, wstr, @dwErr, @bVertical, @uMaxUiLen);
    end;

    s_bHorizontalReading := not bVertical;
    bUnicodeIme := True;
  end else
  begin
    // IMEs that doesn't implement Reading String API

    lpIC := _ImmLockIMC(hImc);

    // p := nil; // - never used
    case dwId of
      IMEID_CHT_VER42, // New(Phonetic/ChanJie)IME98  : 4.2.x.x // Win98
      IMEID_CHT_VER43, // New(Phonetic/ChanJie)IME98a : 4.3.x.x // WinMe, Win2k
      IMEID_CHT_VER44: // New ChanJie IME98b          : 4.4.x.x // WinXP
      begin
        // p = *(LPBYTE *)((LPBYTE)_ImmLockIMCC( lpIC->hPrivate ) + 24 );
        p:= PByte(PPointer(Longword(_ImmLockIMCC(lpIC^.hPrivate)) + 24)^);
        if (p <> nil) then
        begin
          dwReadingStrLen := PDWORD(Longword(p) + 7 * 4 + 32 * 4)^;
          dwErr := PDWORD(Longword(p) + 8 * 4 + 32 * 4)^;
          wstr := PWideChar(Longword(p) + 56);
          bUnicodeIme := True;
        end;
      end;

      IMEID_CHT_VER50: // 5.0.x.x // WinME
      begin
        // p = *(LPBYTE *)( (LPBYTE)_ImmLockIMCC( lpIC->hPrivate ) + 3 * 4 );
        p:= PByte(PPointer(Longword(_ImmLockIMCC(lpIC^.hPrivate)) + 3 * 4)^);
        if (p <> nil) then
        begin
          p := PByte(PPointer(Longword(p) + 1*4 + 5*4 + 4*2)^);
          if (p <> nil) then
          begin
            dwReadingStrLen := PDWORD(Longword(p) + 1*4 + (16*2+2*4) + 5*4 + 16)^;
            dwErr := PDWORD(Longword(p) + 1*4 + (16*2+2*4) + 5*4 + 16 + 1*4)^;
            wstr := PWideChar(Longword(p) + 1*4 + (16*2+2*4) + 5*4);
            bUnicodeIme := False;
          end;
        end;
      end;

      IMEID_CHT_VER51, // 5.1.x.x // IME2002(w/OfficeXP)
      IMEID_CHT_VER52, // 5.2.x.x // (w/whistler)
      IMEID_CHS_VER53: // 5.3.x.x // SCIME2k or MSPY3 (w/OfficeXP and Whistler)
      begin
        // p = *(LPBYTE *)( (LPBYTE)_ImmLockIMCC( lpIC->hPrivate ) + 4 );
        p:= PByte(PPointer(Longword(_ImmLockIMCC(lpIC^.hPrivate)) + 4)^);
        if (p <> nil) then
        begin
          p := PByte(PPointer(Longword(p) + 1*4 + 5*4)^);
          if (p <> nil) then
          begin                               
            dwReadingStrLen := PDWORD(Longword(p) + 1*4 + (16*2+2*4) + 5*4 + 16 * 2)^;
            dwErr := PDWORD(Longword(p) + 1*4 + (16*2+2*4) + 5*4 + 16 * 2 + 1*4)^;
            wstr := PWideChar(Longword(p) + 1*4 + (16*2+2*4) + 5*4);
            bUnicodeIme := True;
          end;
        end;
      end;

      // the code tested only with Win 98 SE (MSPY 1.5/ ver 4.1.0.21)
      IMEID_CHS_VER41:
      begin
        nOffset := IfThen((GetImeId(1) >= $00000002), 8, 7);
        // p = *(LPBYTE *)( (LPBYTE)_ImmLockIMCC( lpIC->hPrivate ) + nOffset * 4 );
        p:= PByte(PPointer(Integer(_ImmLockIMCC(lpIC^.hPrivate)) + nOffset * 4)^);
        if (p <> nil) then
        begin
          dwReadingStrLen := PDWORD(Longword(p) + 7*4 + 16*2*4)^;
          dwErr := PDWORD(Longword(p) + 8*4 + 16*2*4)^;
          dwErr := Min(dwErr, Integer(dwReadingStrLen));
          wstr := PWideChar(Longword(p) + 6*4 + 16*2*1);
          bUnicodeIme := True;
        end;
      end;

      IMEID_CHS_VER42: // 4.2.x.x // SCIME98 or MSPY2 (w/Office2k, Win2k, WinME, etc)
      begin
        osi.dwOSVersionInfoSize := SizeOf(TOSVersionInfoW);
        {$IFDEF FPC}
        GetVersionExW(osi);
        #else

        GetVersionExW(POSVersionInfo(@osi)^); //todo: Bug in all Delphi versions
        #endif


        nTcharSize := IfThen((osi.dwPlatformId = VER_PLATFORM_WIN32_NT), SizeOf(WideChar), SizeOf(Char));
        // p = *(LPBYTE *)((LPBYTE)_ImmLockIMCC( lpIC->hPrivate ) + 1*4 + 1*4 + 6*4);
        p:= PByte(PPointer(Longword(_ImmLockIMCC(lpIC^.hPrivate)) + 1*4 + 1*4 + 6*4)^);
        if (p <> nil) then
        begin
          dwReadingStrLen := PDWORD(Integer(p) + 1*4 + (16*2+2*4) + 5*4 + 16 * nTcharSize)^;
          dwErr := PDWORD(Integer(p) + 1*4 + (16*2+2*4) + 5*4 + 16 * nTcharSize + 1*4)^;
          wstr := PWideChar(Longword(p) + 1*4 + (16*2+2*4) + 5*4);
          bUnicodeIme := (osi.dwPlatformId = VER_PLATFORM_WIN32_NT);
        end;
      end;
    end; // case
  end;

  // Copy the reading string to the candidate list first
  s_CandList.awszCandidate[0][0] := #0;
  s_CandList.awszCandidate[1][0] := #0;
  s_CandList.awszCandidate[2][0] := #0;
  s_CandList.awszCandidate[3][0] := #0;
  s_CandList.dwCount := dwReadingStrLen;
  s_CandList.dwSelection := DWORD(-1); // do not select any char
  if bUnicodeIme then
  begin
    for i := 0 to dwReadingStrLen - 1 do // dwlen > 0, if known IME
    begin
      if (dwErr <= i) and (s_CandList.dwSelection = DWORD(-1)) then 
      begin
        // select error char
        s_CandList.dwSelection := i;
      end;

      s_CandList.awszCandidate[i][0] := wstr[i];
      s_CandList.awszCandidate[i][1] := #0;
    end;
    s_CandList.awszCandidate[dwReadingStrLen][0] := #0; //todo: check if this conversion is correct [dwReadingStrLen]==[i]
  end else
  begin
    pch := PChar(wstr);
    i := 0;
    // for i = 0, j = 0; i < dwReadingStrLen; ++i, ++j ) // dwlen > 0, if known IME
    for j := 0 to dwReadingStrLen - 1 do // dwlen > 0, if known IME
    begin
      if (dwErr <= i) and (s_CandList.dwSelection = DWORD(-1)) then
      begin
        s_CandList.dwSelection := j;
      end;
      // Obtain the current code page
      uCodePage := CP_ACP;  // Default code page
      if (GetLocaleInfoW(MAKELCID(GetLanguage, SORT_DEFAULT ),
                         LOCALE_IDEFAULTANSICODEPAGE,
                         wszCodePage,
                         SizeOf(wszCodePage) div SizeOf(wszCodePage[0])) <> 0) then
      begin
        #ifdef  FPC

        uCodePage := StrToInt(WideCharToString(wszCodePage)); // wcstoul(wszCodePage, nil, 0);
        #else

        uCodePage := StrToInt(wszCodePage); // wcstoul(wszCodePage, nil, 0);
        #endif

      end;
      MultiByteToWideChar(uCodePage, 0, pch + i,
                          IfThen(Boolean(IsDBCSLeadByteEx(uCodePage, Byte(pch[i]))), 2, 1),
                          s_CandList.awszCandidate[j], 1);
      if IsDBCSLeadByteEx(uCodePage, Byte(pch[i])) then Inc(i);
      Inc(i);
    end;
    s_CandList.awszCandidate[dwReadingStrLen][0] := #0;  //todo: check if this conversion is correct [dwReadingStrLen]==[j]
    s_CandList.dwCount := dwReadingStrLen;
  end;
  if (@_GetReadingString = nil) then
  begin
    _ImmUnlockIMCC(lpIC.hPrivate);
    _ImmUnlockIMC(hImc);
    GetReadingWindowOrientation(dwId);
  end;
  _ImmReleaseContext(z3DCore_GetHWND, hImc);

  if (pwszReadingStringBuffer <> nil) then
    HeapFree(GetProcessHeap, 0, pwszReadingStringBuffer);

  // Copy the string to the reading string buffer
  s_bShowReadingWindow := (s_CandList.dwCount > 0);
  if (s_bHorizontalReading) then
  begin
    s_CandList.nReadingError := -1;
    s_wszReadingString[0] := #0;
    for i := 0 to s_CandList.dwCount - 1 do
    begin
      if (s_CandList.dwSelection = DWORD(i)) then
        s_CandList.nReadingError := lstrlenW(s_wszReadingString);
      StringCchCat(s_wszReadingString, 32, s_CandList.awszCandidate[i]);
    end;
  end;

  s_CandList.dwPageSize := MAX_CANDLIST;
end;

// This function is used only briefly in CHT IME handling,
// so accelerator isn't processed.
procedure Tz3DIMEEditBox.PumpMessage;
var
  msg: TMSG;
begin
  while PeekMessageW(msg, 0, 0, 0, PM_NOREMOVE) do
  begin
    if (not GetMessageW(msg, 0, 0, 0)) then
    begin
      PostQuitMessage(msg.wParam);
      Exit;
    end;
    TranslateMessage(msg);
    DispatchMessageA(msg);
  end;
end;

procedure Tz3DIMEEditBox.OnFocusIn;
var
  hImc: Imm.HIMC;
begin
  inherited; // Tz3DEdit::OnFocusIn();

  if s_bEnableImeSystem then
  begin
    _ImmAssociateContext(z3DCore_GetHWND, s_hImcDef);
    CheckToggleState;
  end else
    _ImmAssociateContext(z3DCore_GetHWND, 0);

  //
  // Set up the IME global state according to the current instance state
  //
  hImc := _ImmGetContext(z3DCore_GetHWND);
  if (hImc <> 0) then
  begin
    if not s_bEnableImeSystem then s_ImeState := IMEUI_STATE_OFF;

    _ImmReleaseContext(z3DCore_GetHWND, hImc);
    CheckToggleState;
  end;
end;

procedure Tz3DIMEEditBox.OnFocusOut;
begin
  inherited; // Tz3DEdit::OnFocusOut();

  FinalizeString(False);  // Don't send the comp string as to match RichEdit behavior

  _ImmAssociateContext(z3DCore_GetHWND, 0);
end;

//Clootie: Delphi7 bug in Windows.pas
function GetKeyboardLayoutList(nBuff: Integer; List: Pointer): UINT; stdcall; external user32 name 'GetKeyboardLayoutList';

//#define PRIMARYLANGID(lgid)    ((WORD  )(lgid) & 0x3ff)
function PRIMARYLANGID(lgid: DWORD): Word;
begin
  Result:= (lgid and $3ff);
end;

//#define SUBLANGID(lgid)        ((WORD  )(lgid) >> 10)
function SUBLANGID(lgid: DWORD): Word;
begin
  Result:= (lgid shr 10);
end;

const
  WM_INPUTLANGCHANGE              = $0051;

class function Tz3DIMEEditBox.StaticMsgProc(uMsg: LongWord;
  wParam: WPARAM; lParam: LPARAM): BOOL;
type
  PHKLarray = ^THKLarray;
  THKLarray = array[0..MaxInt div SizeOf(Windows.HKL)-1] of Windows.HKL;
var
  hImc: Imm.HIMC;
  cKL: LongWord;
  phKL: PHKLarray; // ^Windows.HKL;
  i: LongWord;
  Locale: TInputLocale;
  bBreak: Boolean;
  e, l: Integer;
  wszDesc: array[0..127] of WideChar;
  uLang: LongWord;
begin
  Result:= False;
  if not s_bEnableImeSystem then Exit;

{$IFDEF DEBUG}
  FIMEStaticMsgProcCalled := True;
#endif


  case uMsg of
    WM_ACTIVATEAPP:
      if (wParam <> 0) then
      begin
        // Populate s_Locale with the list of keyboard layouts.
        cKL := GetKeyboardLayoutList(0, nil);
        s_Locale:= nil; // RemoveAll;
        GetMem(phKL, SizeOf(HKL)*cKL);
        if (phKL <> nil) then //Clootie: This is aloways TRUE in Delphi (overwise exception will be raized)
        begin
          GetKeyboardLayoutList(cKL, phKL);
          for i := 0 to cKL-1 do
          begin
            // Filter out East Asian languages that are not IME.
            if ( (PRIMARYLANGID(LOWORD(phKL[i])) = LANG_CHINESE) or
                 (PRIMARYLANGID(LOWORD(phKL[i])) = LANG_JAPANESE) or
                 (PRIMARYLANGID(LOWORD(phKL[i])) = LANG_KOREAN)
                ) and
               not _ImmIsIME(phKL[i])
            then Continue;

            // If this language is already in the list, don't add it again.
            bBreak := False;
            for e := 0 to Length(s_Locale) - 1 do
              if (LOWORD(s_Locale[e].m_hKL) = LOWORD(phKL[i])) then
              begin
                bBreak := True;
                Break;
              end;

            if not bBreak then
            begin
              Locale.m_hKL := phKL[i];
              wszDesc[0] := #0;
              case PRIMARYLANGID(LOWORD(phKL[i])) of
                // Simplified Chinese
                LANG_CHINESE:
                  case SUBLANGID(LOWORD(phKL[i])) of
                    SUBLANG_CHINESE_SIMPLIFIED:  StringCchCopy(Locale.FLangAbb, 3, s_aszIndicator[INDICATOR_CHS]);
                    SUBLANG_CHINESE_TRADITIONAL: StringCchCopy(Locale.FLangAbb, 3, s_aszIndicator[INDICATOR_CHT]);
                  else // unsupported sub-language
                    GetLocaleInfoW(MAKELCID(LOWORD(phKL[i]), SORT_DEFAULT), LOCALE_SABBREVLANGNAME, wszDesc, 128);
                    Locale.FLangAbb[0] := wszDesc[0];
                    Locale.FLangAbb[1] := towlower(wszDesc[1]);
                    Locale.FLangAbb[2] := #0;
                  end;

                // Korean
                LANG_KOREAN: StringCchCopy(Locale.FLangAbb, 3, s_aszIndicator[INDICATOR_KOREAN]);

                // Japanese
                LANG_JAPANESE: StringCchCopy(Locale.FLangAbb, 3, s_aszIndicator[INDICATOR_JAPANESE]);

              else
                // A non-IME language.  Obtain the language abbreviation
                // and store it for rendering the indicator later.
                GetLocaleInfoW(MAKELCID(LOWORD(phKL[i]), SORT_DEFAULT), LOCALE_SABBREVLANGNAME, wszDesc, 128);
                Locale.FLangAbb[0] := wszDesc[0];
                Locale.FLangAbb[1] := towlower(wszDesc[1]);
                Locale.FLangAbb[2] := #0;
              end;

              GetLocaleInfoW(MAKELCID(LOWORD(phKL[i]), SORT_DEFAULT), LOCALE_SLANGUAGE, wszDesc, 128);
              StringCchCopy(Locale.FLang, 64, wszDesc);
              Locale.FLang[SizeOf(Locale.FLang) div SizeOf(Locale.FLang[0]) - 1] := #0;

              // s_Locale.Add(Locale);
              l:= Length(s_Locale);
              SetLength(s_Locale, l+1);
              s_Locale[l]:= Locale;
            end;
          end;
          FreeMem(phKL);
        end;
      end;

    WM_INPUTLANGCHANGE:
    begin
      z3DTraceDX(UnitName, $FFFF, 0, 'WM_INPUTLANGCHANGE'#10, False);
      begin
        uLang := GetPrimaryLanguage;
        CheckToggleState;
        if (uLang <> GetPrimaryLanguage) then
        begin
          // Korean IME always inserts on keystroke.  Other IMEs do not.
          s_bInsertOnType := (GetPrimaryLanguage = LANG_KOREAN);
        end;

        // IME changed.  Setup the new IME.
        SetupImeApi;
        if (@_ShowReadingWindow <> nil) then
        begin
          hImc := _ImmGetContext(z3DCore_GetHWND);
          if (hImc <> 0) then
          begin
            _ShowReadingWindow(hImc, False);
            _ImmReleaseContext(z3DCore_GetHWND, hImc);
          end;
        end;
      end;
      Result:= True;
      Exit;
    end;

    WM_IME_SETCONTEXT:
    begin
      z3DTraceDX(UnitName, $FFFF, 0, 'WM_IME_SETCONTEXT'#10, False);
      //
      // We don't want anything to display, so we have to clear this
      //
      // lParam := 0; // - never used
      Result:= False;
      Exit;
    end;

      // Handle WM_IME_STARTCOMPOSITION here since
      // we do not want the default IME handler to see
      // this when our fullscreen app is running.
    WM_IME_STARTCOMPOSITION:
    begin
      z3DTraceDX(UnitName, $FFFF, 0, 'WM_IME_STARTCOMPOSITION'#10, False);
      ResetCompositionString;
      // Since the composition string has its own caret, we don't render
      // the edit control's own caret to avoid double carets on screen.
      s_bHideCaret := True;
      Result:= True;
      Exit;
    end;

    WM_IME_COMPOSITION:
    begin
      z3DTraceDX(UnitName, $FFFF, 0, 'WM_IME_COMPOSITION'#10, False);
      Result:= False;
      Exit;
    end;
  end;

  Result:= False;
end;

function Tz3DIMEEditBox.HandleMouse(uMsg: LongWord; pt: TPoint;
  wParam: WPARAM; lParam: LPARAM): Boolean;
var
  pFont: Pz3DFontNode;
  nCompStrWidth: Integer;
  nCharBodyHit, nCharHit: Integer;
  nTrail: LongBool;
  hImc: Imm.HIMC;
  nClauseClicked: Integer;
  nClauseSelected: Integer;
  nVirtKey: Byte;
  nSendCount: Integer;
  nRow: Integer;
  nNumToHit: Integer;
  nStrike: Integer;
  nCandidate: Integer;
  nEntryStart: Integer;
  i: LongWord;
label
  label_LANG_CHINESE;
begin
  Result:= True;
  if (not FEnabled or not FVisible) then
  begin
    Result:= False;
    Exit;
  end;

  case uMsg of
    WM_LBUTTONDOWN,
    WM_LBUTTONDBLCLK:
    begin
      pFont := FDialog.GetFont(m_Displays[9].Font);

      // Check if this click is on top of the composition string
      s_CompString.CPtoX(s_CompString.TextSize, False, nCompStrWidth);

      if (s_ptCompString.x <= pt.x) and
         (s_ptCompString.y <= pt.y) and
         (s_ptCompString.x + nCompStrWidth > pt.x) and
         (s_ptCompString.y + pFont.Height > pt.y) then
      begin
        // Determine the character clicked on.
        s_CompString.XtoCP(pt.x - s_ptCompString.x, nCharBodyHit, nTrail);
        if nTrail and (nCharBodyHit < s_CompString.TextSize)
        then nCharHit := nCharBodyHit + 1
        else nCharHit := nCharBodyHit;

        // Now generate keypress events to move the comp string cursor
        // to the click point.  First, if the candidate window is displayed,
        // send Esc to close it.
        hImc := _ImmGetContext(z3DCore_GetHWND);
        if (hImc = 0) then Exit;

        _ImmNotifyIME(hImc, NI_CLOSECANDIDATE, 0, 0);
        _ImmReleaseContext(z3DCore_GetHWND, hImc);

        if (GetPrimaryLanguage = LANG_JAPANESE) then
        begin
          // For Japanese, there are two cases.  If s_nFirstTargetConv is
          // -1, the comp string hasn't been converted yet, and we use
          // s_nCompCaret.  For any other value of s_nFirstTargetConv,
          // the string has been converted, so we use clause information.

          if (s_nFirstTargetConv <> -1) then
          begin
            nClauseClicked := 0;
            while (s_adwCompStringClause[nClauseClicked + 1] <= LongWord(nCharBodyHit))
            do Inc(nClauseClicked);

            nClauseSelected := 0;
            while (s_adwCompStringClause[nClauseSelected + 1] <= LongWord(s_nFirstTargetConv))
            do Inc(nClauseSelected);

            nVirtKey := Byte(IfThen(nClauseClicked > nClauseSelected, VK_RIGHT, VK_LEFT));
            nSendCount := Abs(nClauseClicked - nClauseSelected);
            // while ( nSendCount-- > 0 )
            while (nSendCount > 0 ) do
            begin
              Dec(nSendCount);
              SendKey(nVirtKey);
            end;
            Exit;
          end;

          // Not converted case. Fall thru to Chinese case.
          goto label_LANG_CHINESE; //Clootie: this is due to awfull usage of switch statement in C++
        end else
        if (GetPrimaryLanguage = LANG_CHINESE) then
        begin
          label_LANG_CHINESE:

          // For Chinese, use s_nCompCaret.
          nVirtKey := Byte(IfThen(nCharHit > s_nCompCaret, VK_RIGHT, VK_LEFT));
          nSendCount := Abs(nCharHit - s_nCompCaret);
          while (nSendCount > 0) do
          begin
            Dec(nSendCount);
            SendKey(nVirtKey);
          end;
        end;

        Exit;
      end;

      // Check if the click is on top of the candidate window
      if (s_CandList.bShowWindow and PtInRect(s_CandList.rcCandidate, pt)) then
      begin
        if (s_bVerticalCand) then
        begin
          // Vertical candidate window

          // Compute the row the click is on
          nRow := (pt.y - s_CandList.rcCandidate.top) div pFont.Height;

          if (LongWord(nRow) < s_CandList.dwCount) then
          begin
            // nRow is a valid entry.
            // Now emulate keystrokes to select the candidate at this row.
            case GetPrimaryLanguage of
              LANG_CHINESE,
              LANG_KOREAN:
                // For Chinese and Korean, simply send the number keystroke.
                SendKey(Ord('0') + nRow + 1);

              LANG_JAPANESE:
              begin
                // For Japanese, move the selection to the target row,
                // then send Right, then send Left.

                if (LongWord(nRow) > s_CandList.dwSelection)
                  then nVirtKey := VK_DOWN
                  else nVirtKey := VK_UP;

                nNumToHit := Abs(nRow - Integer(s_CandList.dwSelection));
                for nStrike := 0 to nNumToHit - 1 do SendKey(nVirtKey);

                // Do this to close the candidate window without ending composition.
                SendKey(VK_RIGHT);
                SendKey(VK_LEFT);
              end;
            end; {case}
          end
        end else
        begin
          // Horizontal candidate window

          // Determine which the character the click has hit.
          s_CandList.HoriCand.XtoCP(pt.x - s_CandList.rcCandidate.left, nCharHit, nTrail);

          // Determine which candidate string the character belongs to.
          nCandidate := s_CandList.dwCount - 1;

          nEntryStart := 0;
          for i := 0 to s_CandList.dwCount - 1 do
          begin
            if (nCharHit >= nEntryStart) then
            begin
              // Haven't found it.
              Inc(nEntryStart, lstrlenW(s_CandList.awszCandidate[i] ) + 1);  // plus space separator
            end else
            begin
              // Found it.  This entry starts at the right side of the click point,
              // so the char belongs to the previous entry.
              nCandidate := i - 1;
              Break;
            end;
          end;

          // Now emulate keystrokes to select the candidate entry.
          case GetPrimaryLanguage of
            LANG_CHINESE,
            LANG_KOREAN:
              // For Chinese and Korean, simply send the number keystroke.
              SendKey(Ord('0') + nCandidate + 1);
          end;
        end;

        Exit;
      end;
    end;
  end;

  // If we didn't care for the msg, let the parent process it.
  Result:= inherited {Cz3DEdit::}HandleMouse(uMsg, pt, wParam, lParam);
end;

var
  lAlt:   DWORD = $80000000;
  lCtrl:  DWORD = $80000000;
  lShift: DWORD = $80000000;

function Tz3DIMEEditBox.MsgProc(uMsg: LongWord; wParam: WPARAM;
  lParam: LPARAM): Boolean;
var
  trappedData: Boolean;
  trapped: {$IFDEF FPC}System.#endif
PBoolean;
  hImc: Imm.HIMC;
  lRet: Longint;  // Returned count in CHARACTERS
  wszCompStr: array[0..MAX_COMPSTRING_SIZE-1] of WideChar;
  i, j: Integer;
  nCount: Integer;
  lpCandList: PCandidateList;
  dwLenRequired: DWORD;
  nPageTopIndex: Integer;
  pwsz: PWideChar;
  pwszNewCand: PWideChar;
  wszCand: array[0..255] of WideChar;
  wszEntry: array[0..31] of WideChar;
  dwId: DWORD;
begin
  // Result:= True; // - never used
  if (not FEnabled or not FVisible) then
  begin
    Result:= False;
    Exit;
  end;

#ifdef  DEBUG

  Assert(FIMEStaticMsgProcCalled, 'To fix, call Tz3DGUIController.MsgProc() first');
#endif


  trapped := @trappedData;

  trapped^ := False;
  if (not s_bEnableImeSystem) then
  begin
    Result:= inherited {Cz3DEdit::}MsgProc(uMsg, wParam, lParam);
    Exit;
  end;

  case uMsg of
    //
    //  IME Handling
    //
    WM_IME_COMPOSITION:
    begin
      z3DTraceDX(UnitName, $FFFF, 0, 'WM_IME_COMPOSITION'#10, False);

      trapped^ := True;
      hImc := _ImmGetContext(z3DCore_GetHWND);
      if (0 <> hImc) then
      begin
        // Get the caret position in composition string
        if (lParam and GCS_CURSORPOS <> 0) then
        begin
          s_nCompCaret := _ImmGetCompositionStringW(hImc, GCS_CURSORPOS, nil, 0);
          if (s_nCompCaret < 0) then s_nCompCaret := 0; // On error, set caret to pos 0.
        end;

        // ResultStr must be processed before composition string.
        //
        // This is because for some IMEs, such as CHT, pressing Enter
        // to complete the composition sends WM_IME_COMPOSITION with both
        // GCS_RESULTSTR and GCS_COMPSTR.  Retrieving the result string
        // gives the correct string, while retrieving the comp string
        // (GCS_COMPSTR) gives empty string.  GCS_RESULTSTR should be
        // handled first so that the application receives the string.  Then
        // GCS_COMPSTR can be handled to clear the comp string buffer.

        if (lParam and GCS_RESULTSTR <> 0) then
        begin
          z3DTraceDX(UnitName, $FFFF, 0, '  GCS_RESULTSTR'#10, False);
          lRet := _ImmGetCompositionStringW(hImc, GCS_RESULTSTR, @wszCompStr, SizeOf(wszCompStr));
          if (lRet > 0) then
          begin
            lRet:= lRet div SizeOf(WideChar);
            wszCompStr[lRet] := #0;  // Force terminate
            TruncateCompString(False, lstrlenW(wszCompStr));
            s_CompString.SetText(wszCompStr);
            SendCompString;
            ResetCompositionString;
          end;
        end;

        //
        // Reads in the composition string.
        //
        if (lParam and GCS_COMPSTR <> 0) then
        begin
          z3DTraceDX(UnitName, $FFFF, 0, '  GCS_COMPSTR'#10, False);
          //////////////////////////////////////////////////////
          // Retrieve the latest user-selected IME candidates
          lRet := _ImmGetCompositionStringW(hImc, GCS_COMPSTR, @wszCompStr, SizeOf(wszCompStr));
          if (lRet > 0) then
          begin
            lRet:= lRet div SizeOf(WideChar);  // Convert size in byte to size in char
            wszCompStr[lRet] := #0;  // Force terminate
            //
            // Remove the whole of the string
            //
            TruncateCompString(False, lstrlenW(wszCompStr));

            s_CompString.SetText(wszCompStr);

            // Older CHT IME uses composition string for reading string
            if (GetLanguage = LANG_CHT) and not (GetImeId <> 0) then
            begin
              if lstrlenW(s_CompString.Buffer) <> 0 then
              begin
                s_CandList.dwCount := 4;             // Maximum possible length for reading string is 4
                s_CandList.dwSelection := DWORD(-1); // don't select any candidate

                // Copy the reading string to the candidate list
                for i := 3 downto 0 do
                begin
                  if (i > lstrlenW(s_CompString.Buffer) - 1) then
                    s_CandList.awszCandidate[i][0] := #0  // Doesn't exist
                  else
                  begin
                    s_CandList.awszCandidate[i][0] := s_CompString[i];
                    s_CandList.awszCandidate[i][1] := #0;
                  end;
                end;
                s_CandList.dwPageSize := MAX_CANDLIST;
                // Clear comp string after we are done copying
                ZeroMemory(s_CompString.Buffer, 4 * SizeOf(WideChar));
                s_bShowReadingWindow := True;
                GetReadingWindowOrientation(0);
                if (s_bHorizontalReading) then
                begin
                  s_CandList.nReadingError := -1;  // Clear error

                  // Create a string that consists of the current
                  // reading string.  Since horizontal reading window
                  // is used, we take advantage of this by rendering
                  // one string instead of several.
                  //
                  // Copy the reading string from the candidate list
                  // to the reading string buffer.
                  s_wszReadingString[0] := #0;
                  for i := 0 to s_CandList.dwCount - 1 do
                  begin
                    if (s_CandList.dwSelection = DWORD(i)) then
                      s_CandList.nReadingError := lstrlenW(s_wszReadingString);
                    StringCchCat(s_wszReadingString, 32, s_CandList.awszCandidate[i]);
                  end;
                end;
              end else
              begin
                s_CandList.dwCount := 0;
                s_bShowReadingWindow := False;
              end;
            end;

            if (s_bInsertOnType) then
            begin
              // Send composition string to the edit control
              SendCompString;
              // Restore the caret to the correct location.
              // It's at the end right now, so compute the number
              // of times left arrow should be pressed to
              // send it to the original position.
              nCount := lstrlenW(s_CompString.Buffer + s_nCompCaret);
              // Send left keystrokes
              for i := 0 to nCount - 1 do
                SendMessage(z3DCore_GetHWND, WM_KEYDOWN, VK_LEFT, 0);
              SendMessage(z3DCore_GetHWND, WM_KEYUP, VK_LEFT, 0);
            end;
          end;

          ResetCaretBlink;
        end;

        // Retrieve comp string attributes
        if (lParam and GCS_COMPATTR <> 0) then
        begin
          lRet := _ImmGetCompositionStringW(hImc, GCS_COMPATTR, @s_abCompStringAttr, SizeOf(s_abCompStringAttr));
          if (lRet > 0) then s_abCompStringAttr[lRet] := 0;  // ??? Is this needed for attributes?
        end;

        // Retrieve clause information
        if (lParam and GCS_COMPCLAUSE <> 0) then
        begin
          lRet := _ImmGetCompositionStringW(hImc, GCS_COMPCLAUSE, @s_adwCompStringClause, SizeOf(s_adwCompStringClause));
          s_adwCompStringClause[lRet div SizeOf(DWORD)] := 0;  // Terminate
        end;

        _ImmReleaseContext(z3DCore_GetHWND, hImc);
      end;
    end; {:WM_IME_COMPOSITION:}

    WM_IME_ENDCOMPOSITION:
    begin
      z3DTraceDX(UnitName, $FFFF, 0, 'WM_IME_ENDCOMPOSITION'#10, False);
      TruncateCompString;
      ResetCompositionString;
      // We can show the edit control's caret again.
      s_bHideCaret := False;
      // Hide reading window
      s_bShowReadingWindow := False;
    end;

    WM_IME_NOTIFY:
    begin
      z3DTraceDX(UnitName, $FFFF, 0, PWideChar(WideString('WM_IME_NOTIFY ') + IntToStr(wParam) + #10), False);

      case wParam of
        IMN_SETCONVERSIONMODE,
        IMN_SETOPENSTATUS:
        begin
          if (wParam = IMN_SETCONVERSIONMODE)
          then z3DTraceDX(UnitName, $FFFF, 0, '  IMN_SETCONVERSIONMODE'#10, False)
          else z3DTraceDX(UnitName, $FFFF, 0, '  IMN_SETOPENSTATUS'#10, False);
          CheckToggleState;
        end;

        IMN_OPENCANDIDATE,
        IMN_CHANGECANDIDATE:
        begin
          if (wParam = IMN_CHANGECANDIDATE)
          then z3DTraceDX(UnitName, $FFFF, 0, '  IMN_CHANGECANDIDATE'#10, False)
          else z3DTraceDX(UnitName, $FFFF, 0, '  IMN_OPENCANDIDATE'#10, False);

          s_CandList.bShowWindow := True;
          trapped^ := True;
          hImc := _ImmGetContext(z3DCore_GetHWND);
          if (hImc <> 0) then
          begin
            lpCandList := nil;

            s_bShowReadingWindow := False;
            // Retrieve the candidate list
            dwLenRequired := _ImmGetCandidateListW(hImc, 0, nil, 0);
            if (dwLenRequired <> 0) then
            begin
              lpCandList := PCandidateList(HeapAlloc(GetProcessHeap, 0, dwLenRequired));
              {dwLenRequired := }_ImmGetCandidateListW(hImc, 0, lpCandList, dwLenRequired);
            end;

            if (lpCandList <> nil) then
            begin
              // Update candidate list data
              s_CandList.dwSelection := lpCandList.dwSelection;
              s_CandList.dwCount := lpCandList.dwCount;

              // nPageTopIndex := 0; // - never used
              s_CandList.dwPageSize := DWORD(Min(lpCandList.dwPageSize, MAX_CANDLIST));
              if (GetPrimaryLanguage = LANG_JAPANESE) then
              begin
                // Japanese IME organizes its candidate list a little
                // differently from the other IMEs.
                nPageTopIndex := (s_CandList.dwSelection div s_CandList.dwPageSize) * s_CandList.dwPageSize;
              end
              else
                nPageTopIndex := lpCandList.dwPageStart;

              // Make selection index relative to first entry of page
              s_CandList.dwSelection := IfThen((GetLanguage = LANG_CHS) and (GetImeId = 0),
                                          -1, Integer(s_CandList.dwSelection) - nPageTopIndex);

              ZeroMemory(@s_CandList.awszCandidate, SizeOf(s_CandList.awszCandidate));
              {for i := nPageTopIndex, j := 0;
                  (DWORD)i < lpCandList->dwCount && j < s_CandList.dwPageSize;
                  i++, j++ )}
              i := nPageTopIndex; j := 0;
              while (i < Integer(lpCandList.dwCount)) and (j < Integer(s_CandList.dwPageSize)) do
              begin
                // Initialize the candidate list strings
                pwsz := s_CandList.awszCandidate[j];
                // For every candidate string entry,
                // write [index] + Space + [String] if vertical,
                // write [index] + [String] + Space if horizontal.
                pwsz^:= WideChar(Ord('0') + ( (j + 1) mod 10)); Inc(pwsz); // Index displayed is 1 based

                if (s_bVerticalCand) then
                begin
                  pwsz^ := ' ';
                  Inc(pwsz);
                end;

                pwszNewCand := PWideChar(PChar{PByte}(lpCandList) + lpCandList.dwOffset[i]);
                while (pwszNewCand^ <> #0) do
                begin
                  pwsz^ := pwszNewCand^;
                  Inc(pwsz);
                  Inc(pwszNewCand);
                end;

                if (not s_bVerticalCand) then
                begin
                  pwsz^ := ' ';
                  Inc(pwsz);
                end;
                pwsz^ := #0;  // Terminate

                Inc(i); Inc(j);
              end;

              // Make dwCount in s_CandList be number of valid entries in the page.
              s_CandList.dwCount := lpCandList.dwCount - lpCandList.dwPageStart;
              if (s_CandList.dwCount > lpCandList.dwPageSize)
              then s_CandList.dwCount := lpCandList.dwPageSize;

              HeapFree(GetProcessHeap, 0, lpCandList);
              _ImmReleaseContext(z3DCore_GetHWND, hImc);

              // Korean and old Chinese IME can't have selection.
              // User must use the number hotkey or Enter to select
              // a candidate.
              if (GetPrimaryLanguage = LANG_KOREAN) or
                 (GetLanguage = LANG_CHT) and (GetImeId = 0) then
              begin
                s_CandList.dwSelection := DWORD(-1);
              end;

              // Initialize s_CandList.HoriCand if we have a
              // horizontal candidate window.
              if (not s_bVerticalCand) then
              begin
                ZeroMemory(@wszCand, SizeOf(wszCand));

                s_CandList.nFirstSelected := 0;
                s_CandList.nHoriSelectedLen := 0;
                for i := 0 to MAX_CANDLIST - 1 do
                begin
                  if (s_CandList.awszCandidate[i][0] = #0) then Break;

                  StringCchFormat(wszEntry, 32, '%s ', [s_CandList.awszCandidate[i]]);
                  // If this is the selected entry, mark its char position.
                  if (Integer(s_CandList.dwSelection) = i) then
                  begin
                    s_CandList.nFirstSelected := lstrlenW(wszCand);
                    s_CandList.nHoriSelectedLen := lstrlenW(wszEntry) - 1;  // Minus space
                  end;
                  StringCchCat(wszCand, 256, wszEntry);
                end;
                wszCand[lstrlenW(wszCand) - 1] := #0;  // Remove the last space
                s_CandList.HoriCand.SetText(wszCand);
              end;
            end;
          end;
        end;

        IMN_CLOSECANDIDATE:
        begin
          z3DTraceDX(UnitName, $FFFF, 0, '  IMN_CLOSECANDIDATE'#10, False);
          s_CandList.bShowWindow := False;
          if not s_bShowReadingWindow then
          begin
            s_CandList.dwCount := 0;
            ZeroMemory(@s_CandList.awszCandidate, SizeOf(s_CandList.awszCandidate));
          end;
          trapped^ := True;
        end;

        IMN_PRIVATE:
        begin
          z3DTraceDX(UnitName, $FFFF, 0, '  IMN_PRIVATE'#10, False);
          if not s_CandList.bShowWindow then GetPrivateReadingString;

          // Trap some messages to hide reading window
          dwId := GetImeId;
          case dwId of
            IMEID_CHT_VER42,
            IMEID_CHT_VER43,
            IMEID_CHT_VER44,
            IMEID_CHS_VER41,
            IMEID_CHS_VER42:
              if (lParam = 1) or (lParam = 2) then
              begin
                trapped^ := True;
              end;

            IMEID_CHT_VER50,
            IMEID_CHT_VER51,
            IMEID_CHT_VER52,
            IMEID_CHT_VER60,
            IMEID_CHS_VER53:
              if (lParam = 16) or (lParam = 17) or (lParam = 26) or (lParam = 27) or (lParam = 28) then
              begin
                trapped^ := True;
              end;
          end;
        end;

      else {case}
          trapped^ := True;
      end;
    end;

    // fix for #15386 - When Text Service Framework is installed in Win2K, Alt+Shift and Ctrl+Shift combination (to switch
    // input locale / keyboard layout) doesn't send WM_KEYUP message for the key that is released first. We need to check
    // if these keys are actually up whenever we receive key up message for other keys.
    WM_KEYUP,
    WM_SYSKEYUP,
    WM_KEYDOWN,
    WM_SYSKEYDOWN:
    begin
      if (uMsg = WM_KEYUP) or (uMsg = WM_SYSKEYUP) then
      begin
        // if ( !( lAlt & 0x80000000 ) && wParam != VK_MENU && ( GetAsyncKeyState( VK_MENU ) & 0x8000 ) == 0 )
        if (lAlt and $80000000 = 0) and (wParam <> VK_MENU) and (GetAsyncKeyState(VK_MENU) and $8000 = 0) then
        begin
          PostMessageW(GetFocus, WM_KEYUP, VK_MENU, (lAlt and $01ff0000) or $C0000001);
        end
        // else if ( !( lCtrl & 0x80000000 ) && wParam != VK_CONTROL && ( GetAsyncKeyState( VK_CONTROL ) & 0x8000 ) == 0 )
        else if (lCtrl and $80000000 = 0) and (wParam <> VK_CONTROL) and (GetAsyncKeyState(VK_CONTROL) and $8000 = 0) then
        begin
          PostMessageW(GetFocus, WM_KEYUP, VK_CONTROL, (lCtrl and $01ff0000 ) or $C0000001);
        end
        // else if ( !( lShift & 0x80000000 ) && wParam != VK_SHIFT && ( GetAsyncKeyState( VK_SHIFT ) & 0x8000 ) == 0 )
        else if (lShift and $80000000 = 0) and (wParam <> VK_SHIFT) and (GetAsyncKeyState(VK_SHIFT) and $8000 = 0) then
        begin
          PostMessageW(GetFocus, WM_KEYUP, VK_SHIFT, (lShift and $01ff0000) or $C0000001);
        end;
      end;
    // fall through WM_KEYDOWN / WM_SYSKEYDOWN
   {WM_KEYDOWN, WM_SYSKEYDOWN:}
      case wParam of
        VK_MENU:    lAlt := lParam;
        VK_SHIFT:   lShift := lParam;
        VK_CONTROL: lCtrl := lParam;
      end;
      //break;
      // Fall through to default case
      // so we invoke the parent.
      Result:= inherited {Cz3DEdit::}MsgProc(uMsg, wParam, lParam);
      Exit;
    end;

    else
      // Let the parent handle the message that we
      // don't handle.
      Result:= inherited {Cz3DEdit::}MsgProc(uMsg, wParam, lParam);
      Exit;
  end; // case

  Result:= trapped^;
end;

procedure Tz3DIMEEditBox.RenderCandidateReadingWindow(bReading: Boolean);
var
  rc: TRect;
  nNumEntries: LongWord;
  TextColor, TextBkColor, SelTextColor, SelBkColor: TD3DColor;
  nX, nXFirst, nXComp: Integer;
  nWidthRequired: Integer;
  nHeightRequired: Integer;
  nSingleLineHeight: Integer;
  i: LongWord;
  bHasPosition: Boolean;
  nXCompTrail: Integer;
  nXLeft, nXRight: Integer;
begin
  nNumEntries := IfThen(bReading, 4, MAX_CANDLIST);
  m_Buffer.CPtoX(FCaret, False, nX);
  m_Buffer.CPtoX(FFirstVisible, False, nXFirst);

  if bReading then
  begin
    TextColor := m_ReadingColor;
    TextBkColor := m_ReadingWinColor;
    SelTextColor := m_ReadingSelColor;
    SelBkColor := m_ReadingSelBkColor;
  end else
  begin
    TextColor := m_CandidateColor;
    TextBkColor := m_CandidateWinColor;
    SelTextColor := m_CandidateSelColor;
    SelBkColor := m_CandidateSelBkColor;
  end;

  // For Japanese IME, align the window with the first target converted character.
  // For all other IMEs, align with the caret.  This is because the caret
  // does not move for Japanese IME.
  if (GetLanguage = LANG_CHT) and (GetImeId = 0) then nXComp := 0
  else
  if (GetPrimaryLanguage = LANG_JAPANESE) then
    s_CompString.CPtoX(s_nFirstTargetConv, False, nXComp)
  else
    s_CompString.CPtoX(s_nCompCaret, False, nXComp);

  // Compute the size of the candidate window
  nWidthRequired := 0;
  // nHeightRequired := 0; // - never used
  nSingleLineHeight := 0;

  if (s_bVerticalCand and not bReading) or
     (not s_bHorizontalReading and bReading) then
  begin
    // Vertical window
    for i := 0 to nNumEntries - 1 do
    begin
      if (s_CandList.awszCandidate[i][0] = #0) then Break;

      SetRect(rc, 0, 0, 0, 0);
      FDialog.CalcTextRect(s_CandList.awszCandidate[i], m_Displays[1], @rc);
      nWidthRequired := Max(nWidthRequired, rc.right - rc.left);
      nSingleLineHeight := Max(nSingleLineHeight, rc.bottom - rc.top);
    end;
    nHeightRequired := nSingleLineHeight * Integer(nNumEntries);
  end else
  begin
    // Horizontal window
    SetRect(rc, 0, 0, 0, 0);
    if (bReading) then
      FDialog.CalcTextRect(s_wszReadingString, m_Displays[1], @rc)
    else
      FDialog.CalcTextRect(s_CandList.HoriCand.Buffer, m_Displays[1], @rc);
    nWidthRequired := rc.right - rc.left;
    nHeightRequired := rc.bottom - rc.top;
    nSingleLineHeight := nHeightRequired;
  end;

  // Now that we have the dimension, calculate the location for the candidate window.
  // We attempt to fit the window in this order:
  // bottom, top, right, left.

  bHasPosition := False;

  // Bottom
  SetRect(rc, s_ptCompString.x + nXComp, s_ptCompString.y + FText.bottom - FText.top,
              s_ptCompString.x + nXComp + nWidthRequired, s_ptCompString.y + FText.bottom - FText.top + nHeightRequired);
  // if the right edge is cut off, move it left.
  if (rc.right > FDialog.Width) then
  begin
    Dec(rc.left, rc.right - FDialog.Width);
    rc.right := FDialog.Width;
  end;
  if (rc.bottom <= FDialog.Height) then bHasPosition := True;

  // Top
  if not bHasPosition then
  begin
    SetRect(rc, s_ptCompString.x + nXComp, s_ptCompString.y - nHeightRequired,
                s_ptCompString.x + nXComp + nWidthRequired, s_ptCompString.y);
    // if the right edge is cut off, move it left.
    if (rc.right > FDialog.Width) then
    begin
      Dec(rc.left, rc.right - FDialog.Width);
      rc.right := FDialog.Width;
    end;
    if (rc.top >= 0) then bHasPosition := True;
  end;

  // Right
  if not bHasPosition then
  begin
    s_CompString.CPtoX(s_nCompCaret, True, nXCompTrail);
    SetRect(rc, s_ptCompString.x + nXCompTrail, 0,
                s_ptCompString.x + nXCompTrail + nWidthRequired, nHeightRequired);
    if (rc.right <= FDialog.Width) then bHasPosition := True;
  end;

  // Left
  if not bHasPosition then
  begin
    SetRect(rc, s_ptCompString.x + nXComp - nWidthRequired, 0,
                s_ptCompString.x + nXComp, nHeightRequired);
    if (rc.right >= 0) then bHasPosition := True;
  end;

  if not bHasPosition then
  begin
    // The dialog is too small for the candidate window.
    // Fall back to render at 0, 0.  Some part of the window
    // will be cut off.
    rc.left := 0;
    rc.right := nWidthRequired;
  end;

  // If we are rendering the candidate window, save the position
  // so that mouse clicks are checked properly.
  if not bReading then s_CandList.rcCandidate := rc;

  // Render the elements
  FDialog.DrawRect(rc, TextBkColor);
  if (s_bVerticalCand and not bReading) or
     (not s_bHorizontalReading and bReading) then
  begin
    // Vertical candidate window
    for i := 0 to nNumEntries - 1 do
    begin
      // Here we are rendering one line at a time
      rc.bottom := rc.top + nSingleLineHeight;
      // Use a different color for the selected string
      if (s_CandList.dwSelection = i) then
      begin
        FDialog.DrawRect(rc, SelBkColor);
        m_Displays[1].FontColor.Current := D3DXColorFromDWord(SelTextColor);
      end else
        m_Displays[1].FontColor.Current := D3DXColorFromDWord(TextColor);

      FDialog.DrawText(s_CandList.awszCandidate[i], m_Displays[1], rc);

      Inc(rc.top, nSingleLineHeight);
    end;
  end else
  begin
    // Horizontal candidate window
    m_Displays[1].FontColor.Current := D3DXColorFromDWord(TextColor);
    if bReading then
      FDialog.DrawText(s_wszReadingString, m_Displays[1], rc)
    else
      FDialog.DrawText(s_CandList.HoriCand.Buffer, m_Displays[1], rc);

    // Render the selected entry differently
    if not bReading then
    begin
      s_CandList.HoriCand.CPtoX(s_CandList.nFirstSelected, False, nXLeft);
      s_CandList.HoriCand.CPtoX(s_CandList.nFirstSelected + s_CandList.nHoriSelectedLen, False, nXRight);

      rc.right := rc.left + nXRight;
      Inc(rc.left, nXLeft);
      FDialog.DrawRect(rc, SelBkColor);
      m_Displays[1].FontColor.Current := D3DXColorFromDWord(SelTextColor);
      FDialog.DrawText(s_CandList.HoriCand.Buffer + s_CandList.nFirstSelected,
                         m_Displays[1], rc, False, s_CandList.nHoriSelectedLen);
    end;
  end;
end;

procedure Tz3DIMEEditBox.RenderComposition();
var
  rcCaret, rcFirst: TRect;
  nX, nXFirst: Integer;
  pDisplay: Iz3DDisplay;
  rc: TRect;
  TextColor: TD3DColor;
  pwszComp: PWideChar;
  nCharLeft: Integer;
  nLastInLine: Integer;
  bTrail: LongBool;
  nNumCharToDraw: Integer;
  nCharFirst: Integer;
  pAttr: PByte;
  pcComp: PWideChar;
  bkColor: TD3DColor;
  nXLeft, nXRight: Integer;
  rcTarget: TRect;
begin
  rcCaret := Rect(0, 0, 0, 0);
  m_Buffer.CPtoX(FCaret, False, nX);
  m_Buffer.CPtoX(FFirstVisible, False, nXFirst);
  pDisplay := m_Displays[1];

  // Get the required width
  rc := Rect(FText.left + nX - nXFirst, FText.top,
             FText.left + nX - nXFirst, FText.bottom);
  FDialog.CalcTextRect(s_CompString.Buffer, pDisplay, @rc);

  // If the composition string is too long to fit within
  // the text area, move it to below the current line.
  // This matches the behavior of the default IME.
  if (rc.right > FText.right) then
    OffsetRect(rc, FText.left - rc.left, rc.bottom - rc.top);

  // Save the rectangle position for processing highlighted text.
  rcFirst := rc;

  // Update s_ptCompString for RenderCandidateReadingWindow().
  s_ptCompString.x := rc.left; s_ptCompString.y := rc.top;

  TextColor := m_CompColor;
  // Render the window and string.
  // If the string is too long, we must wrap the line.
  pDisplay.FontColor.Current := D3DXColorFromDWord(TextColor);
  pwszComp := s_CompString.Buffer;
  nCharLeft := s_CompString.TextSize;
  while True do
  begin
    // Find the last character that can be drawn on the same line.
    s_CompString.XtoCP(FText.right - rc.left, nLastInLine, bTrail);
    nNumCharToDraw := Min(nCharLeft, nLastInLine);
    FDialog.CalcTextRect(pwszComp, pDisplay, @rc, nNumCharToDraw);

    // Draw the background
    // For Korean IME, blink the composition window background as if it
    // is a cursor.
    if (GetPrimaryLanguage = LANG_KOREAN) then
    begin
      if FCaretOn then
      begin
        FDialog.DrawRect(rc, m_CompWinColor);
      end else
      begin
        // Not drawing composition string background. We
        // use the editbox's text color for composition
        // string text.
        TextColor := m_Displays[0].FontColor.States[z3dcsNormal];
      end;
    end else
    begin
      // Non-Korean IME. Always draw composition background.
      FDialog.DrawRect(rc, m_CompWinColor);
    end;

    // Draw the text
    pDisplay.FontColor.Current := D3DXColorFromDWord(TextColor);
    FDialog.DrawText(pwszComp, pDisplay, rc, False, nNumCharToDraw);

    // Advance pointer and counter
    Dec(nCharLeft, nNumCharToDraw);
    Inc(pwszComp, nNumCharToDraw);
    if (nCharLeft <= 0) then Break;

    // Advance rectangle coordinates to beginning of next line
    OffsetRect(rc, FText.left - rc.left, rc.bottom - rc.top);
  end;

  // Load the rect for the first line again.
  rc := rcFirst;

  // Inspect each character in the comp string.
  // For target-converted and target-non-converted characters,
  // we display a different background color so they appear highlighted.
  //nCharFirst := 0;
  nXFirst := 0;
  s_nFirstTargetConv := -1;
//  for pcComp := s_CompString.GetBuffer, pAttr := s_abCompStringAttr;
//        *pcComp != L'\0'; ++pcComp, ++pAttr )
  pcComp := s_CompString.Buffer;
  pAttr := @s_abCompStringAttr;
  bkColor:= 0;
  while (pcComp^ <> #0) do
  begin
    // Render a different background for this character
    s_CompString.CPtoX(Integer(pcComp - s_CompString.Buffer), False, nXLeft);
    s_CompString.CPtoX(Integer(pcComp - s_CompString.Buffer), True, nXRight);

    // Check if this character is off the right edge and should
    // be wrapped to the next line.
    if (nXRight - nXFirst > FText.right - rc.left) then
    begin
      // Advance rectangle coordinates to beginning of next line
      OffsetRect(rc, FText.left - rc.left, rc.bottom - rc.top);

      // Update the line's first character information
      nCharFirst := Integer(pcComp - s_CompString.Buffer);
      s_CompString.CPtoX(nCharFirst, False, nXFirst);
    end;

    // If the caret is on this character, save the coordinates
    // for drawing the caret later.
    if (s_nCompCaret = Integer(pcComp - s_CompString.Buffer)) then
    begin
      rcCaret := rc;
      Inc(rcCaret.left, nXLeft - nXFirst - 1);
      rcCaret.right := rcCaret.left + 2;
    end;

    // Set up color based on the character attribute
    if (pAttr^ = ATTR_TARGET_CONVERTED) then
    begin
      pDisplay.FontColor.Current := D3DXColorFromDWord(m_CompTargetColor);
      bkColor := m_CompTargetBkColor;
    end else
    if (pAttr^ = ATTR_TARGET_NOTCONVERTED) then
    begin
      pDisplay.FontColor.Current := D3DXColorFromDWord(m_CompTargetNonColor);
      bkColor := m_CompTargetNonBkColor;
    end else
    begin
      Inc(pcComp); Inc(pAttr);
      Continue;
    end;

    rcTarget := Rect(rc.left + nXLeft - nXFirst, rc.top, rc.left + nXRight - nXFirst, rc.bottom);
    FDialog.DrawRect(rcTarget, bkColor);
    FDialog.DrawText(pcComp, pDisplay, rcTarget, False, 1);

    // Record the first target converted character's index
    if (-1 = s_nFirstTargetConv) then
      s_nFirstTargetConv := Integer(pAttr) - Integer(@s_abCompStringAttr);

    Inc(pcComp); Inc(pAttr);
  end;

  // Render the composition caret
  if FCaretOn then
  begin
    // If the caret is at the very end, its position would not have
    // been computed in the above loop.  We compute it here.
    if (s_nCompCaret = s_CompString.TextSize) then
    begin
      s_CompString.CPtoX(s_nCompCaret, False, nX);
      rcCaret := rc;
      Inc(rcCaret.left, nX - nXFirst - 1);
      rcCaret.right := rcCaret.left + 2;
    end;

    FDialog.DrawRect(rcCaret, m_CompCaretColor);
  end;
end;

procedure Tz3DIMEEditBox.RenderIndicator;
var
  pDisplay: Iz3DDisplay;
  rc: TRect;
  rcCalc: TRect;
  pwszIndicator: PWideChar;
begin
  pDisplay := m_Displays[9];
  pDisplay.TextureColor.Blend(z3dcsNormal);

  FDialog.DrawSprite(pDisplay, FIndicator);
  rc := FIndicator;
  InflateRect(rc, -FSpacing, -FSpacing);
  if (s_ImeState = IMEUI_STATE_ON) and s_bEnableImeSystem
    then pDisplay.FontColor.Current := D3DXColorFromDWord(m_IndicatorImeColor)
    else pDisplay.FontColor.Current := D3DXColorFromDWord(m_IndicatorEngColor);
  rcCalc := Rect(0, 0, 0, 0);
  // If IME system is off, draw English indicator.
  if s_bEnableImeSystem
  then pwszIndicator := s_wszCurrIndicator
  else pwszIndicator := s_aszIndicator[Low(TIndicatorEnum)];

  FDialog.CalcTextRect(pwszIndicator, pDisplay, @rcCalc);
  FDialog.DrawText(pwszIndicator, pDisplay, rc);
end;

procedure Tz3DIMEEditBox.Render;
var
  i: TIndicatorEnum;
  rc: TRect;
  pDisplay: Iz3DDisplay;
begin
  if not FVisible then Exit;

  // If we have not computed the indicator symbol width,
  // do it.
  if (FIndicatorWidth = 0) then
  begin
    for i := INDICATOR_NON_IME to INDICATOR_JAPANESE do
    begin
      rc := Rect(0, 0, 0, 0);
      FDialog.CalcTextRect(@s_aszIndicator[i], m_Displays[9], @rc);
      FIndicatorWidth := Max(FIndicatorWidth, rc.right - rc.left);
    end;
    // Update the rectangles now that we have the indicator's width
    UpdateRects;
  end;

  // Let the parent render first (edit control)
  inherited {Cz3DEdit::}Render;

  pDisplay := GetDisplay(1);
  if (pDisplay <> nil) then
  begin
    s_CompString.FontNode := FDialog.GetFont(pDisplay.Font);
    s_CandList.HoriCand.FontNode := FDialog.GetFont(pDisplay.Font);
  end;

  //
  // Now render the IME elements
  //
  if FHasFocus then
  begin
    // Render the input locale indicator
    RenderIndicator;

    // Display the composition string.
    // This method should also update s_ptCompString
    // for RenderCandidateReadingWindow.
    RenderComposition;

    // Display the reading/candidate window. RenderCandidateReadingWindow()
    // uses s_ptCompString to position itself.  s_ptCompString must have
    // been filled in by RenderComposition().
    if s_bShowReadingWindow then
      // Reading window
      RenderCandidateReadingWindow(True)
    else
    if s_CandList.bShowWindow then
      // Candidate list window
      RenderCandidateReadingWindow(False);
  end;
end;

class procedure Tz3DIMEEditBox.Initialize;
var
  wszPath: array[0..MAX_PATH] of WideChar;
  temp: FARPROC;
begin
  if (s_hDllImm32 <> 0) then Exit; // Only need to do once
  
  s_CompString.SetBufferSize(MAX_COMPSTRING_SIZE);

  if (GetSystemDirectoryW(wszPath, MAX_PATH+1) = 0) then Exit;
  StringCchCat(wszPath, MAX_PATH, IMM32_DLLNAME);
  s_hDllImm32 := LoadLibraryW(wszPath);
  if (s_hDllImm32 <> 0) then
  begin
    temp:= GetProcAddress(s_hDllImm32, 'ImmLockIMC'); if (temp<>nil) then _ImmLockIMC:= temp;
    temp:= GetProcAddress(s_hDllImm32, 'ImmUnlockIMC'); if (temp<>nil) then _ImmUnlockIMC:= temp;
    temp:= GetProcAddress(s_hDllImm32, 'ImmLockIMCC'); if (temp<>nil) then _ImmLockIMCC:= temp;
    temp:= GetProcAddress(s_hDllImm32, 'ImmUnlockIMCC'); if (temp<>nil) then _ImmUnlockIMCC:= temp;
    temp:= GetProcAddress(s_hDllImm32, 'ImmDisableTextFrameService'); if (temp<>nil) then _ImmDisableTextFrameService:= temp;
    temp:= GetProcAddress(s_hDllImm32, 'ImmGetCompositionStringW'); if (temp<>nil) then _ImmGetCompositionStringW:= temp;
    temp:= GetProcAddress(s_hDllImm32, 'ImmGetCandidateListW'); if (temp<>nil) then _ImmGetCandidateListW:= temp;
    temp:= GetProcAddress(s_hDllImm32, 'ImmGetContext'); if (temp<>nil) then _ImmGetContext:= temp;
    temp:= GetProcAddress(s_hDllImm32, 'ImmReleaseContext'); if (temp<>nil) then _ImmReleaseContext:= temp;
    temp:= GetProcAddress(s_hDllImm32, 'ImmAssociateContext'); if (temp<>nil) then _ImmAssociateContext:= temp;
    temp:= GetProcAddress(s_hDllImm32, 'ImmGetOpenStatus'); if (temp<>nil) then _ImmGetOpenStatus:= temp;
    temp:= GetProcAddress(s_hDllImm32, 'ImmSetOpenStatus'); if (temp<>nil) then _ImmSetOpenStatus:= temp;
    temp:= GetProcAddress(s_hDllImm32, 'ImmGetConversionStatus'); if (temp<>nil) then _ImmGetConversionStatus:= temp;
    temp:= GetProcAddress(s_hDllImm32, 'ImmGetDefaultIMEWnd'); if (temp<>nil) then _ImmGetDefaultIMEWnd:= temp;
    temp:= GetProcAddress(s_hDllImm32, 'ImmGetIMEFileNameA'); if (temp<>nil) then _ImmGetIMEFileNameA:= temp;
    temp:= GetProcAddress(s_hDllImm32, 'ImmGetVirtualKey'); if (temp<>nil) then _ImmGetVirtualKey:= temp;
    temp:= GetProcAddress(s_hDllImm32, 'ImmNotifyIME'); if (temp<>nil) then _ImmNotifyIME:= temp;
    temp:= GetProcAddress(s_hDllImm32, 'ImmSetConversionStatus'); if (temp<>nil) then _ImmSetConversionStatus:= temp;
    temp:= GetProcAddress(s_hDllImm32, 'ImmSimulateHotKey'); if (temp<>nil) then _ImmSimulateHotKey:= temp;
    temp:= GetProcAddress(s_hDllImm32, 'ImmIsIME'); if (temp<>nil) then _ImmIsIME:= temp;
  end;

  if (GetSystemDirectoryW(wszPath, MAX_PATH+1) = 0) then Exit;
  StringCchCat(wszPath, MAX_PATH, VER_DLLNAME);
  s_hDllVer := LoadLibraryW(wszPath);
  if (s_hDllVer <> 0) then
  begin
    temp:= GetProcAddress(s_hDllVer, 'VerQueryValueA'); if (temp<>nil) then _VerQueryValueA:= temp;
    temp:= GetProcAddress(s_hDllVer, 'GetFileVersionInfoA'); if (temp<>nil) then _GetFileVersionInfoA:= temp;
    temp:= GetProcAddress(s_hDllVer, 'GetFileVersionInfoSizeA'); if (temp<>nil) then _GetFileVersionInfoSizeA:= temp;
  end;
end;

class procedure Tz3DIMEEditBox.Uninitialize;
begin
  if (s_hDllImm32 <> 0) then
  begin
    _ImmLockIMC := Dummy_ImmLockIMC;
    _ImmUnlockIMC := Dummy_ImmUnlockIMC;
    _ImmLockIMCC := Dummy_ImmLockIMCC;
    _ImmUnlockIMCC := Dummy_ImmUnlockIMCC;
    _ImmDisableTextFrameService := Dummy_ImmDisableTextFrameService;
    _ImmGetCompositionStringW := Dummy_ImmGetCompositionStringW;
    _ImmGetCandidateListW := Dummy_ImmGetCandidateListW;
    _ImmGetContext := Dummy_ImmGetContext;
    _ImmReleaseContext := Dummy_ImmReleaseContext;
    _ImmAssociateContext := Dummy_ImmAssociateContext;
    _ImmGetOpenStatus := Dummy_ImmGetOpenStatus;
    _ImmSetOpenStatus := Dummy_ImmSetOpenStatus;
    _ImmGetConversionStatus := Dummy_ImmGetConversionStatus;
    _ImmGetDefaultIMEWnd := Dummy_ImmGetDefaultIMEWnd;
    _ImmGetIMEFileNameA := Dummy_ImmGetIMEFileNameA;
    _ImmGetVirtualKey := Dummy_ImmGetVirtualKey;
    _ImmNotifyIME := Dummy_ImmNotifyIME;
    _ImmSetConversionStatus := Dummy_ImmSetConversionStatus;
    _ImmSimulateHotKey := Dummy_ImmSimulateHotKey;
    _ImmIsIME := Dummy_ImmIsIME;

    FreeLibrary(s_hDllImm32);
    s_hDllImm32 := 0;
  end;

  if (s_hDllIme <> 0) then
  begin
    _GetReadingString := Dummy_GetReadingString;
    _ShowReadingWindow := Dummy_ShowReadingWindow;

    FreeLibrary(s_hDllIme);
    s_hDllIme := 0;
  end;

  if (s_hDllVer <> 0) then
  begin
    _VerQueryValueA := Dummy_VerQueryValueA;
    _GetFileVersionInfoA := Dummy_GetFileVersionInfoA;
    _GetFileVersionInfoSizeA := Dummy_GetFileVersionInfoSizeA;

    FreeLibrary(s_hDllVer);
    s_hDllVer := 0;
  end;
end;

class function Tz3DIMEEditBox.GetLanguage: Word;
begin
  Result:= LOWORD(s_hklCurrent);
end;

class function Tz3DIMEEditBox.GetPrimaryLanguage: Word;
begin
  Result:= PRIMARYLANGID(LOWORD(s_hklCurrent));
end;

class function Tz3DIMEEditBox.GetSubLanguage: Word;
begin
  Result:= SUBLANGID(LOWORD(s_hklCurrent));
end;

{ Tz3DDesktop }

procedure Tz3DDesktop.BringToFront(const ADialog: Iz3DDialog);
begin
  FGUIController.BringToFront(ADialog);
end;

constructor Tz3DDesktop.Create;
begin
  inherited;

  // Link this object to the desired events generated by the z3D Engine
  Notifications:= [z3dlnDevice, z3dlnGUIRender, z3dlnMessages];
  ScenarioLevel:= False;

  FVisible:= True;
  FLogo:= z3DCreateTexture;
  FLogo.FileName:= 'C:\JP\Direct3D\z3D\z3DLogo.dds';
  FLogo.Source:= z3dtsFileName;
  FLogo.ScenarioLevel:= False;
  FLogo.AutoGenerateMipMaps:= False;
  FWallpaper:= z3DCreateTexture;
  FWallpaper.FileName:= 'C:\JP\Direct3D\z3D\Back.dds';
  FWallpaper.Source:= z3dtsFileName;
  FWallpaper.ScenarioLevel:= False;
  FWallpaper.AutoGenerateMipMaps:= False;
  FBlurWallpaper:= False;
  FBlurWallpaperTemp:= z3DCreateRenderTexture;
  FBlurWallpaperTemp.ScenarioLevel:= False;
  FBlurWallpaperTemp.AutoWidthFactor:= 0.125;
  FBlurWallpaperTemp.AutoHeightFactor:= 0.125;
  FBlurWallpaperTemp.Format:= D3DFMT_A8R8G8B8;
  FBlurWallpaperTemp.Enabled:= False;
  FBlurWallpaperFinal:= z3DCreateRenderTexture;
  FBlurWallpaperFinal.ScenarioLevel:= False;
  FBlurWallpaperFinal.AutoWidthFactor:= 0.125;
  FBlurWallpaperFinal.AutoHeightFactor:= 0.125;
  FBlurWallpaperFinal.Format:= D3DFMT_A8R8G8B8;
  FBlurWallpaperFinal.Enabled:= False;
  FThemeSettings:= Tz3DDesktopThemeSettings.Create;
  FGUIController:= Tz3DGUIController.Create(Self);
  FMainMenu:= Tz3DMainMenuDialog.New(Self);
end;

function Tz3DDesktop.GetBlurWallpaper: Boolean;
begin
  Result:= FBlurWallpaper;
end;

function Tz3DDesktop.GetGUIController: Iz3DGUIController;
begin
  Result:= FGUIController;
end;

function Tz3DDesktop.GetProgressDialog: Iz3DProgressDialog;
begin
  Result:= FProgress;
end;

function Tz3DDesktop.GetThemeSettings: Iz3DDesktopThemeSettings;
begin
  Result:= FThemeSettings;
end;

function Tz3DDesktop.GetVisible: Boolean;
begin
  Result:= FVisible;
end;

function Tz3DDesktop.GetWallpaper: Iz3DTexture;
begin
  if BlurWallpaper then Result:= FBlurWallpaperFinal else Result:= FWallpaper;
end;

procedure Tz3DDesktop.SetBlurWallpaper(const Value: Boolean);
begin
  FBlurWallpaper:= Value;
end;

procedure Tz3DDesktop.SetVisible(const Value: Boolean);
begin
  FVisible:= Value;
end;

function Tz3DDesktop.ShowMessage(const AMessage: PWideChar; const AKind: Tz3DMessageDialogKind): Tz3DDialogModalResult;
begin
  Result:= Tz3DMessageDialog.New(Self, AMessage, AKind);
end;

procedure Tz3DDesktop.StartScenario;
var I: Integer;
begin
  if z3DGlobalEngine.Scenario.Enabled then
  begin
    Visible:= False;
    Exit;
  end;
  FProgress:= Tz3DProgressDialog.New(Self);
  StringToWideChar(z3DPROGRESS_INITIALIZING, FProgress.Status, 255);
  for I:= 0 to 10 do z3DCore_ProcessMessages;
  z3DGlobalEngine.Scenario.Enabled:= True;
  Visible:= False;
  Controller.UnregisterDialog(FProgress as Iz3DDialog);
  FProgress:= nil;
end;

procedure Tz3DDesktop.z3DGUIRender;
begin
  inherited;
  if FFirstRender and BlurWallpaper then
  begin
    z3DCore_GetD3DDevice.SetSamplerState(2, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);
    z3DCore_GetD3DDevice.SetSamplerState(2, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);
    z3DCore_GetD3DDevice.SetSamplerState(2, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
    z3DRenderGaussBlur(FWallpaper, FBlurWallpaperTemp);
    z3DRenderGaussBlur(FBlurWallpaperTemp, FBlurWallpaperFinal);
    z3DRenderGaussBlur(FBlurWallpaperFinal, FBlurWallpaperTemp);
    FFirstRender:= False;
  end;
  if Visible and not z3DGlobalEngine.Scenario.Enabled then
  begin
    z3DCore_GetD3DDevice.SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);
    z3DCore_GetD3DDevice.SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);
    z3DCore_GetD3DDevice.SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
    if BlurWallpaper then z3DGlobalEngine.Renderer.Blend([FBlurWallpaperFinal]) else
    z3DGlobalEngine.Renderer.Blend([FWallpaper]);
  end;
  FGUIController.GUIRender;
end;

procedure Tz3DDesktop.RenderEngineLogo;
begin
  if Visible then z3DGlobalEngine.Renderer.AutoBlend(FLogo, 60, 50, nil, 0.9);
end;

procedure Tz3DDesktop.z3DCreateScenarioObjects(const ACaller: Tz3DCreateObjectCaller);
begin
  inherited;
  FGUIController.CreateScenarioObjects(ACaller = z3dcocResetDevice);
  FBlurWallpaperTemp.Enabled:= BlurWallpaper;
  FBlurWallpaperFinal.Enabled:= BlurWallpaper;
  FFirstRender:= True;
end;

procedure Tz3DDesktop.z3DMessage(const AWnd: HWND; const AMsg: Cardinal;
  const AwParam, AlParam: Integer; var ADefault: Boolean;
  var AResult: Integer);
begin
  inherited;
  FGUIController.Message(AWnd, AMsg, AwParam, AlParam, ADefault, AResult);
end;

procedure Tz3DDesktop.z3DDestroyScenarioObjects(const ACaller: Tz3DDestroyObjectCaller);
begin
  inherited;
  FGUIController.DestroyScenarioObjects(ACaller = z3ddocLostDevice);
end;

function Tz3DDesktop.CreateConsoleDialog: Iz3DConsoleDialog;
begin
  Result:= Tz3DConsoleDialog.Create;
  Result.InitDefaultDialog(FGUIController);
end;

function Tz3DDesktop.CreateDialog: Iz3DDialog;
begin
  Result:= Tz3DDialog.Create;
  Result.InitDefaultDialog(FGUIController);
end;

function Tz3DDesktop.CreateMainMenuDialog: Iz3DMainMenuDialog;
begin
  Result:= Tz3DMainMenuDialog.Create;
  Result.InitDefaultDialog(FGUIController);
end;

function Tz3DDesktop.CreateProgressDialog: Iz3DProgressDialog;
begin
  Result:= Tz3DProgressDialog.Create;
  Result.InitDefaultDialog(FGUIController);
end;

{ Tz3DGUIFont }

constructor Tz3DGUIFont.Create;
begin
  inherited;
  FColor:= z3DFloat4(0, 0, 0, 1);
  FFormat:= DT_LEFT or DT_VCENTER;
  StringToWideChar('Tahoma', FName, 255);
  FShadow:= False;
  FSize:= 8;
end;

function Tz3DGUIFont.GetColor: Iz3DFloat4;
begin
  Result:= FColor;
end;

function Tz3DGUIFont.GetFormat: DWORD;
begin
  Result:= FFormat;
end;

function Tz3DGUIFont.GetName: PWideChar;
begin
  Result:= FName;
end;

function Tz3DGUIFont.GetShadow: Boolean;
begin
  Result:= FShadow;
end;

function Tz3DGUIFont.GetSize: Integer;
begin
  Result:= FSize;
end;

procedure Tz3DGUIFont.SetFormat(const Value: DWORD);
begin
  FFormat:= Value;
end;

procedure Tz3DGUIFont.SetShadow(const Value: Boolean);
begin
  FShadow:= Value;
end;

procedure Tz3DGUIFont.SetSize(const Value: Integer);
begin
  FSize:= Value;
end;

{ Tz3DDesktopThemeSettings }

constructor Tz3DDesktopThemeSettings.Create;
begin
  inherited;
  FCheckBoxFont:= Tz3DGUIFont.Create;
  FDefaultFont:= Tz3DGUIFont.Create;
  FRadioButtonFont:= Tz3DGUIFont.Create;
  FCaptionHeight:= 21;
  FDialogColorTL:= z3DFloat4(0.89, 0.83, 0.78, 1);
  FDialogColorTR:= z3DFloat4(0.94, 0.92, 0.88, 1);
  FDialogColorBL:= z3DFloat4(0.75, 0.64, 0.52, 1);
  FDialogColorBR:= z3DFloat4(0.69, 0.55, 0.46, 1);
end;

function Tz3DDesktopThemeSettings.GetCaptionHeight: Integer;
begin
  Result:= FCaptionHeight;
end;

function Tz3DDesktopThemeSettings.GetCheckBoxFont: Iz3DGUIFont;
begin
  Result:= FCheckBoxFont;
end;

function Tz3DDesktopThemeSettings.GetDefaultFont: Iz3DGUIFont;
begin
  Result:= FDefaultFont;
end;

function Tz3DDesktopThemeSettings.GetDialogColorBL: Iz3DFloat4;
begin
  Result:= FDialogColorBL;
end;

function Tz3DDesktopThemeSettings.GetDialogColorBR: Iz3DFloat4;
begin
  Result:= FDialogColorBR;
end;

function Tz3DDesktopThemeSettings.GetDialogColorTL: Iz3DFloat4;
begin
  Result:= FDialogColorTL;
end;

function Tz3DDesktopThemeSettings.GetDialogColorTR: Iz3DFloat4;
begin
  Result:= FDialogColorTR;
end;

function Tz3DDesktopThemeSettings.GetRadioButtonFont: Iz3DGUIFont;
begin
  Result:= FRadioButtonFont;
end;

procedure Tz3DControl.SetDialog(const Value: Iz3DDialog);
begin
  FDialog:= Value;
end;

procedure Tz3DDesktopThemeSettings.SetCaptionHeight(const Value: Integer);
begin
  FCaptionHeight:= Value;
end;

{ Tz3DMessageDialog }

procedure GMessageDialogGUIEvent(const AEvent: Tz3DControlEvent; const AControlID: Integer; const AControl: Iz3DControl;
    const AUserContext: Pointer); stdcall;
begin
  if AEvent <> z3dceButtonClick then Exit;
  case AControlID of
    1:
    begin
      if Tz3DMessageDialog(AUserContext).Kind in [z3dmdkConfirmation, z3dmdkConfirmationCancel] then
      Tz3DMessageDialog(AUserContext).ModalResult:= z3dmdkYes else
      Tz3DMessageDialog(AUserContext).ModalResult:= z3dmdkOk;
    end;
    2: Tz3DMessageDialog(AUserContext).ModalResult:= z3dmdkNo;
    3: Tz3DMessageDialog(AUserContext).ModalResult:= z3dmdkCancel;
  end;
end;

constructor Tz3DMessageDialog.Create;
begin
  inherited;
  FMessageLabel:= Tz3DLabel.Create(Self);
end;

function Tz3DMessageDialog.GetKind: Tz3DMessageDialogKind;
begin
  Result:= FKind;
end;

class function Tz3DMessageDialog.New(const ADesktop: Iz3DDesktop;
  const AMessage: PWideChar; const AKind: Tz3DMessageDialogKind): Tz3DDialogModalResult;
var FDialog: Iz3DMessageDialog;
begin
  FDialog:= Tz3DMessageDialog.Create;
  FDialog.Visible:= False;
  Result:= FDialog.ShowMessage(ADesktop, AMessage, AKind);
end;

procedure Tz3DMessageDialog.SetKind(const Value: Tz3DMessageDialogKind);
begin
  FKind:= Value;
end;

function Tz3DMessageDialog.ShowMessage(const ADesktop: Iz3DDesktop; const AMessage: PWideChar;
  const AKind: Tz3DMessageDialogKind): Tz3DDialogModalResult;
var FWidth, FHeight, FFinalWidth: Integer;
begin
  FKind:= AKind;
  FWidth:= Length(AMessage) * 3;
  FHeight:= 120;
  FFinalWidth:= 300;
  if FWidth > FFinalWidth then
  FFinalWidth:= Max(FFinalWidth, z3DCore_GetState.BackBufferSurfaceDesc.Width div 2);
  while FWidth > FFinalWidth do
  begin
    FWidth:= Max(FFinalWidth, FWidth - z3DCore_GetState.BackBufferSurfaceDesc.Width div 2);
    FHeight:= FHeight + 24;
  end;
  FWidth:= FFinalWidth;
  SetSize(FWidth, FHeight);
  SetLocation(z3DCore_GetState.BackBufferSurfaceDesc.Width div 2 - FWidth div 2,
  z3DCore_GetState.BackBufferSurfaceDesc.Height div 2 - FHeight div 2);
  InitDefaultDialog(ADesktop.Controller);
  SetCallback(GMessageDialogGUIEvent, Pointer(Self));
  FButton1:= Tz3DButton.Create(Self);
  FMessageLabel.Text:= AMessage;
  FMessageLabel.SetLocation(60, ADesktop.ThemeSettings.CaptionHeight+15);
  FMessageLabel.SetSize(FWidth-80, FHeight-30);
  case AKind of
    z3dmdkInformation:
    begin
      StringToWideChar(z3DDIALOG_INFORMATION, Caption, 255);
      StringToWideChar(z3DDIALOG_OK, FButton1.Text, 255);
      FButton1.SetSize(78, 26);
      FButton1.SetLocation(FFinalWidth div 2 - 39, FHeight - 42);
    end;
    z3dmdkWarning:
    begin
      StringToWideChar(z3DDIALOG_WARNING, Caption, 255);
      StringToWideChar(z3DDIALOG_OK, FButton1.Text, 255);
      FButton1.SetSize(78, 26);
      FButton1.SetLocation(FFinalWidth div 2 - 39, FHeight - 42);
    end;
    z3dmdkError:
    begin
      StringToWideChar(z3DDIALOG_ERROR, Caption, 255);
      StringToWideChar(z3DDIALOG_OK, FButton1.Text, 255);
      FButton1.SetSize(78, 26);
      FButton1.SetLocation(FFinalWidth div 2 - 39, FHeight - 42);
    end;
    z3dmdkConfirmation:
    begin
      StringToWideChar(z3DDIALOG_CONFIRMATION, Caption, 255);
      FButton2:= Tz3DButton.Create(Self);
      FButton1.SetSize(78, 26);
      FButton2.SetSize(78, 26);
      FButton1.SetLocation(FFinalWidth div 2 - 39*2 - 5, FHeight - 42);
      FButton2.SetLocation(FFinalWidth div 2 + 5, FHeight - 42);
      StringToWideChar(z3DDIALOG_YES, FButton1.Text, 255);
      StringToWideChar(z3DDIALOG_NO, FButton2.Text, 255);
      AddControl(FButton2);
      FButton2.ID:= 2;
    end;
    z3dmdkConfirmationCancel:
    begin
      StringToWideChar(z3DDIALOG_CONFIRMATION, Caption, 255);
      FButton2:= Tz3DButton.Create(Self);
      FButton3:= Tz3DButton.Create(Self);
      FButton1.SetSize(78, 26);
      FButton2.SetSize(78, 26);
      FButton3.SetSize(78, 26);
      FButton1.SetLocation(FFinalWidth div 2 - 39*3 - 5*2, FHeight - 42);
      FButton2.SetLocation(FFinalWidth div 2 - 39, FHeight - 42);
      FButton3.SetLocation(FFinalWidth div 2 + 39 + 5*2, FHeight - 42);
      StringToWideChar(z3DDIALOG_YES, FButton1.Text, 255);
      StringToWideChar(z3DDIALOG_NO, FButton2.Text, 255);
      StringToWideChar(z3DDIALOG_CANCEL, FButton3.Text, 255);
      AddControl(FButton2);
      AddControl(FButton3);
      FButton2.ID:= 2;
      FButton3.ID:= 3;
    end;
  end;
  FButton1.ID:= 1;
  AddControl(FMessageLabel);
  AddControl(FButton1);
  FMessageLabel.Display[0].TextFormat:= DT_LEFT or DT_TOP or DT_WORDBREAK;
  ShowModal;
  Result:= ModalResult;
  ADesktop.Controller.UnregisterDialog(Self);
end;

{ Tz3DMainMenuDialog }

procedure GMainMenuDialogGUIEvent(const AEvent: Tz3DControlEvent; const AControlID: Integer; const AControl: Iz3DControl;
    const AUserContext: Pointer); stdcall;
var FMsg: PWideChar;
begin
  if AEvent <> z3dceButtonClick then Exit;
  case AControlID of
    1: Tz3DMainMenuDialog(AUserContext).Manager.Desktop.StartScenario;
//    99: z3DGlobalEngine.Device.ShowSettingsDialog;
    100:
    begin
      GetMem(FMsg, 255);
      StringToWideChar(z3DDIALOG_EXITCONFIRMATION, FMsg, 255);
      try
        if Tz3DMainMenuDialog(AUserContext).Manager.Desktop.ShowMessage(FMsg,
        z3dmdkConfirmation) = z3dmdkYes then
        begin
          z3DCore_Shutdown;
          Exit;
        end;
      finally
        FreeMem(FMsg);
      end;
    end;
  end;
end;

constructor Tz3DMainMenuDialog.Create;
begin
  inherited;

  // Link this object to the desired events generated by the z3D Engine
  Notifications:= [z3dlnDevice];
  ScenarioStage:= z3dssCreatingLightingSystem;

  EnableCaption:= False;
  EnableBorder:= False;
  FStartButton:= Tz3DButton.Create(Self);
  FSettingsButton:= Tz3DButton.Create(Self);
  FQuitButton:= Tz3DButton.Create(Self);
  FStartButton.SetSize(300, 44);
  StringToWideChar(Z3DMAINMENU_START, FStartButton.Text, 255);
  FStartButton.ID:= 1;
  FStartButton.EnableBackground:= False;
  FSettingsButton.SetSize(300, 44);
  StringToWideChar(Z3DMAINMENU_SETTINGS, FSettingsButton.Text, 255);
  FSettingsButton.EnableBackground:= False;
  FSettingsButton.ID:= 99;
  FQuitButton.SetSize(300, 44);
  StringToWideChar(Z3DMAINMENU_QUIT, FQuitButton.Text, 255);
  FQuitButton.EnableBackground:= False;
  FQuitButton.ID:= 100;
end;

class function Tz3DMainMenuDialog.New(const ADesktop: Iz3DDesktop): Iz3DMainMenuDialog;
var FDialog: Tz3DMainMenuDialog;
begin
  FDialog:= Tz3DMainMenuDialog.Create;
  FDialog.InitDefaultDialog(ADesktop.Controller);
  FDialog.SetCallback(GMainMenuDialogGUIEvent, Pointer(FDialog));
  FDialog.SetBackgroundColors(z3DD3DColor(z3DFloat4(0, 0, 0, 0.5)));
  FDialog.SetFont(0, 'Trebuchet MS', 24, FW_BOLD);
  FDialog.AddControl(FDialog.FStartButton);
  FDialog.FStartButton.Display[1].FontColor.SetColors(z3DD3DColor(z3DFloat3(0.7, 0.8, 0.6)));
  FDialog.FStartButton.Display[1].FontColor.States[z3dcsMouseOver]:= z3DD3DColor(z3DFloat3(1, 1, 1));
  FDialog.FStartButton.Display[0].TextFormat:= DT_LEFT or DT_VCENTER or DT_SINGLELINE;
  FDialog.FStartButton.Display[1].TextFormat:= DT_LEFT or DT_VCENTER or DT_SINGLELINE;
  FDialog.AddControl(FDialog.FSettingsButton);
  FDialog.FSettingsButton.Display[1].FontColor.SetColors(z3DD3DColor(z3DFloat3(0.8, 0.6, 0.7)));
  FDialog.FSettingsButton.Display[1].FontColor.States[z3dcsMouseOver]:= z3DD3DColor(z3DFloat3(1, 1, 1));
  FDialog.FSettingsButton.Display[0].TextFormat:= DT_LEFT or DT_VCENTER or DT_SINGLELINE;
  FDialog.FSettingsButton.Display[1].TextFormat:= DT_LEFT or DT_VCENTER or DT_SINGLELINE;
  FDialog.AddControl(FDialog.FQuitButton);
  FDialog.FQuitButton.Display[1].FontColor.SetColors(z3DD3DColor(z3DFloat3(0.8, 0.6, 0.7)));
  FDialog.FQuitButton.Display[1].FontColor.States[z3dcsMouseOver]:= z3DD3DColor(z3DFloat3(1, 1, 1));
  FDialog.FQuitButton.Display[0].TextFormat:= DT_LEFT or DT_VCENTER or DT_SINGLELINE;
  FDialog.FQuitButton.Display[1].TextFormat:= DT_LEFT or DT_VCENTER or DT_SINGLELINE;
  FDialog.Show;
  Result:= FDialog;
end;

procedure Tz3DMainMenuDialog.Render;
begin
  inherited;
  Manager.Desktop.RenderEngineLogo;
end;

procedure Tz3DMainMenuDialog.z3DDestroyScenarioObjects(const ACaller: Tz3DDestroyObjectCaller);
begin
  inherited;
  StringToWideChar(z3DMAINMENU_START, FStartButton.Text, 255);
end;

procedure Tz3DMainMenuDialog.z3DCreateScenarioObjects(const ACaller: Tz3DCreateObjectCaller);
begin
  inherited;
  if ACaller = z3dcocResetDevice then
  begin
    SetLocation(0, 0);
    SetSize(z3DCore_GetState.BackBufferSurfaceDesc.Width, z3DCore_GetState.BackBufferSurfaceDesc.Height);
    FStartButton.SetLocation(80, z3DCore_GetState.BackBufferSurfaceDesc.Height-280);
    FSettingsButton.SetLocation(80, z3DCore_GetState.BackBufferSurfaceDesc.Height-240);
    FQuitButton.SetLocation(80, z3DCore_GetState.BackBufferSurfaceDesc.Height-120);
  end;
end;

procedure Tz3DMainMenuDialog.z3DStartScenario(const AStage: Tz3DStartScenarioStage);
begin
  inherited;
  if AStage = z3dssCreatingLightingSystem then
  StringToWideChar(z3DMAINMENU_RESUME, FStartButton.Text, 255);
end;

procedure Tz3DMainMenuDialog.z3DStopScenario;
begin
  inherited;
  StringToWideChar(z3DMAINMENU_START, FStartButton.Text, 255);
end;

{ Tz3DProgressDialog }

constructor Tz3DProgressDialog.Create;
begin
  inherited;
  EnableCaption:= False;
  FLabel:= Tz3DLabel.Create(Self);
  FLabel.SetLocation(10, 8);
  FLabel.SetSize(280, 22);
  FProgress:= Tz3DProgressBar.Create(Self);
  FProgress.SetLocation(10, 30);
  FProgress.SetSize(280, 18);
  FProgress.Value:= 0;
  FCancelButton:= Tz3DButton.Create(Self);
  FCancelButton.SetLocation(208, 60);
  FCancelButton.SetSize(78, 26);
  StringToWideChar(z3DDIALOG_CANCEL, FCancelButton.Text, 255);
  FCancelButton.ID:= 1;
end;

function Tz3DProgressDialog.GetStatus: PWideChar;
begin
  Result:= FLabel.Text;
end;

class function Tz3DProgressDialog.New(const ADesktop: Iz3DDesktop): Iz3DProgressDialog;
var FDialog: Tz3DProgressDialog;
begin
  FDialog:= Tz3DProgressDialog.Create;
  FDialog.InitDefaultDialog(ADesktop.Controller);
  FDialog.AddControl(FDialog.FProgress);
  FDialog.AddControl(FDialog.FLabel);
  FDialog.AddControl(FDialog.FCancelButton);
  FDialog.SetSize(300, 100);
  FDialog.SetLocation(z3DCore_GetState.BackBufferSurfaceDesc.Width div 2 - FDialog.Width div 2,
  z3DCore_GetState.BackBufferSurfaceDesc.Height div 2 - FDialog.Height div 2);
  FDialog.Show;
  Result:= FDialog;
end;

procedure Tz3DProgressDialog.SetProgress(const APosition: Integer);
begin
  if FProgress.Value = APosition then Exit;
  FProgress.Value:= APosition;
  z3DCore_ProcessMessages;
end;

procedure Tz3DProgressDialog.SetStatus(const AStatus: PWideChar);
begin
  if WideCompareStr(FLabel.Text, AStatus) = 0 then Exit;
  FLabel.Text:= AStatus;
  z3DCore_ProcessMessages;
end;

(*initialization
  {$IFDEF FPC}
  s_wszCurrIndicator:= @s_aszIndicator[Low(TIndicatorEnum)];
  #endif

  s_CompString:= Tz3DUniBuffer.Create(0);
  s_CandList.HoriCand:= Tz3DUniBuffer.Create;

finalization
  FreeAndNil(s_CandList.HoriCand);
  FreeAndNil(s_CompString);*)

end.
