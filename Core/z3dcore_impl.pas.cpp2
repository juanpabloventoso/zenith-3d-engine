/*==============================================================================*/ 
/*== Zenith 3D Engine - Developed by Juan Pablo Ventoso                       ==*/ 
/*==============================================================================*/ 
/*== Unit: z3DCore. 3D native controller for the Engine interface             ==*/ 
/*==============================================================================*/ 






        
    

/*==============================================================================*/ 
/*== Common section                                                           ==*/ 
/*==============================================================================*/ 
/*== Common interfaces, classes and types                                     ==*/ 
/*==============================================================================*/ 


    class Tz3DTimer : public Tz3DBase,Iz3DTimer
{
public:

  protected:
      Boolean FTimerStopped; 

      LONGLONG FQPFTicksPerSec; 

      LONGLONG FStopTime; 

      LONGLONG FLastElapsedTime; 

      LONGLONG FBaseTime; 

  protected:
      
Double GetAbsoluteTime ();
 ;
      
Double GetTime ();
 ;
      
Double GetElapsedTime ();
 ;
      
TLargeInteger GetAdjustedCurrentTime ();
 ;
  public:
     
Tz3DTimer ();

     
Reset ();
 ;
     
Start ();
 ;
     
Stop ();
 ;
     
Advance ();
 ;
           
GetTimeValues (/* out */ Double &pfTime ,
/* out */ Double &pfAbsoluteTime ,
/* out */ Single &pfElapsedTime 
);
 ;
      
Boolean GetTimerStopped ();
 ;
  public:
       /** \sa GetAbsoluteTime For reading*/
Double AbsoluteTime; 

       /** \sa GetTime For reading*/
Double Time; 

       /** \sa GetElapsedTime For reading*/
Double ElapsedTime; 

       /** \sa GetTimerStopped For reading*/
Boolean IsStopped; 

 };


    class Tz3DResourceCache : public Tz3DBase,Iz3DResourceCache
{
public:

  protected:
      Tz3DCacheTextureArray m_TextureCache; 
 // array of Tz3DCacheTexture;
      typedef array<Tz3DCacheEffect> m_EffectCache;
      typedef array<Tz3DCacheFont> m_FontCache;
  public:
     
~Tz3DResourceCache ();
 ;
  public:
            
HRESULT CreateTextureFromFile (IDirect3DDevice9 pDevice ,
PWideChar pSrcFile ,
/* out */ IDirect3DTexture9 &ppTexture 
);
 ;
                                              
HRESULT CreateTextureFromFileEx (IDirect3DDEVICE9 pDevice ,
PWideChar pSrcFile ,
LongWord Width ,
LongWord Height ,
LongWord MipLevels ,
DWORD Usage ,
TD3DFormat Format ,
TD3DPool Pool ,
DWORD Filter ,
DWORD MipFilter ,
TD3DColor ColorKey ,
PD3DXImageInfo pSrcInfo ,
PPaletteEntry pPalette ,
/* out */ IDirect3DTexture9 &ppTexture 
);
 ;
             
HRESULT CreateTextureFromResource (IDirect3DDevice9 pDevice ,
HMODULE hSrcModule ,
PWideChar pSrcResource ,
IDirect3DTexture9 ppTexture 
);
 ;
                                                
HRESULT CreateTextureFromResourceEx (IDirect3DDevice9 pDevice ,
HMODULE hSrcModule ,
PWideChar pSrcResource ,
LongWord Width ,
LongWord Height ,
LongWord MipLevels ,
DWORD Usage ,
TD3DFormat Format ,
TD3DPool Pool ,
DWORD Filter ,
DWORD MipFilter ,
TD3DColor ColorKey ,
PD3DXImageInfo pSrcInfo ,
PPaletteEntry pPalette ,
/* out */ IDirect3DTexture9 &ppTexture 
);
 ;
            
HRESULT CreateCubeTextureFromFile (IDirect3DDevice9 pDevice ,
PWideChar pSrcFile ,
/* out */ IDirect3DCubeTexture9 &ppCubeTexture 
);
 ;
                                             
HRESULT CreateCubeTextureFromFileEx (IDirect3DDevice9 pDevice ,
PWideChar pSrcFile ,
LongWord Size ,
LongWord MipLevels ,
DWORD Usage ,
TD3DFormat Format ,
TD3DPool Pool ,
DWORD Filter ,
DWORD MipFilter ,
TD3DColor ColorKey ,
PD3DXImageInfo pSrcInfo ,
PPaletteEntry pPalette ,
/* out */ IDirect3DCubeTexture9 &ppCubeTexture 
);
 ;
              
HRESULT CreateCubeTextureFromResource (IDirect3DDevice9 pDevice ,
HMODULE hSrcModule ,
PWideChar pSrcResource ,
/* out */ IDirect3DCubeTexture9 &ppCubeTexture 
);
 ;
                                               
HRESULT CreateCubeTextureFromResourceEx (IDirect3DDevice9 pDevice ,
HMODULE hSrcModule ,
PWideChar pSrcResource ,
LongWord Size ,
LongWord MipLevels ,
DWORD Usage ,
TD3DFormat Format ,
TD3DPool Pool ,
DWORD Filter ,
DWORD MipFilter ,
TD3DColor ColorKey ,
PD3DXImageInfo pSrcInfo ,
PPaletteEntry pPalette ,
/* out */ IDirect3DCubeTexture9 &ppCubeTexture 
);
 ;
            
HRESULT CreateVolumeTextureFromFile (IDirect3DDevice9 pDevice ,
PWideChar pSrcFile ,
/* out */ IDirect3DVolumeTexture9 &ppVolumeTexture 
);
 ;
                                               
HRESULT CreateVolumeTextureFromFileEx (IDirect3DDevice9 pDevice ,
PWideChar pSrcFile ,
LongWord Width ,
LongWord Height ,
LongWord Depth ,
LongWord MipLevels ,
DWORD Usage ,
TD3DFormat Format ,
TD3DPool Pool ,
DWORD Filter ,
DWORD MipFilter ,
TD3DColor ColorKey ,
PD3DXImageInfo pSrcInfo ,
PPaletteEntry pPalette ,
/* out */ IDirect3DVolumeTexture9 &ppTexture 
);
 ;
              
HRESULT CreateVolumeTextureFromResource (IDirect3DDevice9 pDevice ,
HMODULE hSrcModule ,
PWideChar pSrcResource ,
/* out */ IDirect3DVolumeTexture9 &ppVolumeTexture 
);
 ;
                                                 
HRESULT CreateVolumeTextureFromResourceEx (IDirect3DDevice9 pDevice ,
HMODULE hSrcModule ,
PWideChar pSrcResource ,
LongWord Width ,
LongWord Height ,
LongWord Depth ,
LongWord MipLevels ,
DWORD Usage ,
TD3DFormat Format ,
TD3DPool Pool ,
DWORD Filter ,
DWORD MipFilter ,
TD3DColor ColorKey ,
PD3DXImageInfo pSrcInfo ,
PPaletteEntry pPalette ,
/* out */ IDirect3DVolumeTexture9 &ppVolumeTexture 
);
 ;
                                       
HRESULT CreateFont (IDirect3DDevice9 pDevice ,
LongWord Height ,
LongWord Width ,
LongWord Weight ,
LongWord MipLevels ,
BOOL Italic ,
Byte CharSet ,
Byte OutputPrecision ,
Byte Quality ,
Byte PitchAndFamily ,
PWideChar pFacename ,
/* out */ ID3DXFont &ppFont 
);
 ;
             
HRESULT CreateFontIndirect (IDirect3DDevice9 pDevice ,
const TD3DXFontDescW pDesc ,
/* out */ ID3DXFont &ppFont 
);
 ;
                                 
HRESULT CreateEffectFromFile (IDirect3DDevice9 pDevice ,
PWideChar pSrcFile ,
const PD3DXMacro pDefines ,
ID3DXInclude pInclude ,
DWORD Flags ,
ID3DXEffectPool pPool ,
/* out */ ID3DXEffect &ppEffect ,
PID3DXBuffer ppCompilationErrors 
);
 ;
                                   
HRESULT CreateEffectFromResource (IDirect3DDevice9 pDevice ,
HMODULE hSrcModule ,
PWideChar pSrcResource ,
const PD3DXMacro pDefines ,
ID3DXInclude pInclude ,
DWORD Flags ,
ID3DXEffectPool pPool ,
/* out */ ID3DXEffect &ppEffect ,
PID3DXBuffer ppCompilationErrors 
);
 ;
  public:
       
HResult OnCreateDevice (IDirect3DDevice9 pd3dDevice 
);
 ;
       
HResult OnResetDevice (IDirect3DDevice9 pd3dDevice 
);
 ;
      
HResult OnLostDevice ();
 ;
      
HResult OnDestroyDevice ();
 ;
 };


            
Cardinal WideFormatBuf ( &Buffer ,
Cardinal &BufLen ,
const WideString Format ,
const const *Args 
);
 ;
        
Boolean DynArrayContains (const Pointer DynArray ,
 &Element ,
Integer &ElementSize 
);
 ;

/*==============================================================================*/ 
/*== Dynamic linking                                                          ==*/ 
/*==============================================================================*/ 

   
IDirect3D9 z3DCreateDynamicDirect3D9 (LongWord SDKVersion 
);
 ;

     
PWideChar z3DD3DFormatToString (TD3DFormat format ,
Boolean bWithPrefix 
);
 ;
   
PWideChar z3DTraceD3DDECLUSAGEtoString (TD3DDeclUsage u 
);
 ;
   
PWideChar z3DTraceD3DDECLMETHODtoString (TD3DDeclMethod m 
);
 ;
   
PWideChar z3DTraceD3DDECLTYPEtoString (TD3DDeclType t 
);
 ;

// Get info from monitors
       
HMONITOR z3DMonitorFromWindow (const HWND AWnd ,
const DWORD AFlags 
);
 ;
       
Boolean z3DGetMonitorInfo (const HMONITOR AMonitor ,
Tz3DMonitorInfo &AMonitorInfo 
);
 ;

#ifdef  FPC

   #define D5_OR_FPC

#endif

#ifdef  BORLAND
#ifndef  COMPILER6_UP

     #define D5_OR_FPC

#endif
#endif

#ifdef  D5_OR_FPC

        
WideString WideFormat (const WideString FormatS ,
const const *Args 
);

             
Cardinal WideFormatBuf ( &Buffer ,
Cardinal &BufLen ,
const  FormatBuf ,
const Integer iFormatLength ,
const const *Args 
);
 ; ;
#endif



    class Tz3DDeviceList : public Tz3DBase,Iz3DDeviceList
{
public:

  private:
      IDirect3D9 FD3D; 

      Tz3DCallback_AcceptDevice FAcceptDeviceFunc; 

      Pointer FAcceptDeviceFuncUserContext; 

      Boolean FRequirePostPixelShaderBlending; 

      TD3DFormatArray FDepthStecilPossibleList; 

      TD3DMultiSampleTypeArray FMultiSampleTypeList; 

      TLongWordArray FPresentIntervalList; 

      Boolean FSoftwareVP; 

      Boolean FHardwareVP; 

      Boolean FPureHarewareVP; 

      Boolean FMixedVP; 

      LongWord FMinWidth; 

      LongWord FMaxWidth; 

      LongWord FMinHeight; 

      LongWord FMaxHeight; 

      LongWord FRefreshMin; 

      LongWord FRefreshMax; 

      LongWord FMultisampleQualityMax; 

      Tz3DEnumAdapterInfoArray FAdapterInfoList; 

  protected:
         
HRESULT EnumerateDevices (Iz3DEnumAdapterInfo pAdapterInfo ,
TD3DFormatArray pAdapterFormatList 
);
 ;
           
HRESULT EnumerateDeviceCombos (Iz3DEnumAdapterInfo pAdapterInfo ,
Iz3DEnumDeviceInfo pDeviceInfo ,
TD3DFormatArray pAdapterFormatList 
);
 ;
      
BuildDepthStencilFormatList (PD3DDeviceSettingsCombinations pDeviceCombo 
);
 ;
      
BuildMultiSampleTypeList (PD3DDeviceSettingsCombinations pDeviceCombo 
);
 ;
      
BuildDSMSConflictList (PD3DDeviceSettingsCombinations pDeviceCombo 
);
 ;
        
BuildPresentIntervalList (Iz3DEnumDeviceInfo pDeviceInfo ,
PD3DDeviceSettingsCombinations pDeviceCombo 
);
 ;
     
ClearAdapterInfoList ();
 ;
      
TD3DFormatArray GetPossibleDepthStencilFormats ();
 ;
      
TD3DMultiSampleTypeArray GetPossibleMultisampleTypes ();
 ;
      
TLongWordArray GetPossiblePresentIntervals ();
 ;
      
SetPossibleDepthStencilFormats (TD3DFormatArray a 
);
 ;
      
SetPossibleMultisampleTypes (TD3DMultiSampleTypeArray a 
);
 ;
      
SetPossiblePresentIntervals (TLongWordArray a 
);
 ;
      
SetRequirePostPixelShaderBlending (Boolean bRequire 
);
 ;
      
Boolean GetRequirePostPixelShaderBlending ();
 ;
      
LongWord GetMultisampleQualityMax ();
 ;
      
SetMultisampleQualityMax (LongWord nMax 
);
 ;
  public:
         
Tz3DDeviceList (const Iz3DBase AOwner = nil 
);
 ;
     
~Tz3DDeviceList ();
 ;
         
SetResolutionMinMax (LongWord nMinWidth ,
LongWord nMinHeight ,
LongWord nMaxWidth ,
LongWord nMaxHeight 
);
 ;
       
SetRefreshMinMax (LongWord nMin ,
LongWord nMax 
);
 ;
          
GetPossibleVertexProcessingList (/* out */ Boolean &pbSoftwareVP ,
/* out */ Boolean &pbHardwareVP ,
/* out */ Boolean &pbPureHarewareVP ,
/* out */ Boolean &pbMixedVP 
);
 ;
         
SetPossibleVertexProcessingList (Boolean bSoftwareVP ,
Boolean bHardwareVP ,
Boolean bPureHarewareVP ,
Boolean bMixedVP 
);
 ;
     
ResetPossibleDepthStencilFormats ();
 ;
     
ResetPossibleMultisampleTypes ();
 ;
     
ResetPossiblePresentIntervals ();
 ;
      
Tz3DEnumAdapterInfoArray GetAdapterInfoList ();
 ;
       
Iz3DEnumAdapterInfo GetAdapterInfo (LongWord AdapterOrdinal 
);
 ;
         
Iz3DEnumDeviceInfo GetDeviceInfo (LongWord AdapterOrdinal ,
TD3DDevType DeviceType 
);
 ;
      
Iz3DEnumDeviceInfo GetCurrentDeviceInfo ();
 ;
        
PD3DDeviceSettingsCombinations GetDeviceSettingsCombo (const Tz3DDeviceSettings pDeviceSettings 
);
 ; ;
      
PD3DDeviceSettingsCombinations GetCurrentDeviceSettingsCombo ();
 ; ;
                   
PD3DDeviceSettingsCombinations GetDeviceSettingsCombo (LongWord AdapterOrdinal ,
TD3DDevType DeviceType ,
TD3DFormat AdapterFormat ,
TD3DFormat BackBufferFormat ,
Boolean Windowed 
);
 ; ;
     
CleanupDirect3DInterfaces ();
 ;
                      
HRESULT Enumerate (IDirect3D9 pD3D = nil ,
Tz3DCallback_AcceptDevice AcceptDeviceFunc = nil ,
Pointer pAcceptDeviceFuncUserContext = nil 
);
 ; 
  public:
         /** \sa GetPossibleDepthStencilFormats For reading   \sa SetPossibleDepthStencilFormats For writing */
TD3DFormatArray PossibleDepthStencilFormats; 

         /** \sa GetPossibleMultisampleTypes For reading   \sa SetPossibleMultisampleTypes For writing */
TD3DMultiSampleTypeArray PossibleMultisampleTypes; 

         /** \sa GetPossiblePresentIntervals For reading   \sa SetPossiblePresentIntervals For writing */
TLongWordArray PossiblePresentIntervals; 

         /** \sa GetMultisampleQualityMax For reading   \sa SetMultisampleQualityMax For writing */
LongWord MultisampleQualityMax; 

         /** \sa GetRequirePostPixelShaderBlending For reading   \sa SetRequirePostPixelShaderBlending For writing */
Boolean RequirePostPixelShaderBlending; 

 };


    class Tz3DEnumAdapterInfo : public Tz3DBase,Iz3DEnumAdapterInfo
{
public:

  private:
      LongWord FAdapterOrdinal; 

      TD3DAdapterIdentifier9 FAdapterIdentifier; 

      TDescArray FUniqueDescription; 

      TD3DDisplayModeArray FDisplayModeList; 

      Tz3DDeviceInfoList FDeviceInfoList; 

  protected:
      
PD3DAdapterIdentifier9 GetAdapterIdentifier ();
 ;
      
LongWord GetAdapterOrdinal ();
 ;
      
Pz3DDeviceInfoList GetDeviceInfoList ();
 ;
      
PD3DDisplayModeArray GetDisplayModeList ();
 ;
      
PDescArray GetUniqueDescription ();
 ;
       
SetAdapterIdentifier (const PD3DAdapterIdentifier9 Value 
);
 ;
       
SetAdapterOrdinal (const LongWord Value 
);
 ;
       
SetDeviceInfoList (const Pz3DDeviceInfoList Value 
);
 ;
       
SetDisplayModeList (const PD3DDisplayModeArray Value 
);
 ;
       
SetUniqueDescription (const PDescArray Value 
);
 ;
  public:
     
~Tz3DEnumAdapterInfo ();
 ;
  public:
         /** \sa GetAdapterOrdinal For reading   \sa SetAdapterOrdinal For writing */
LongWord AdapterOrdinal; 

         /** \sa GetAdapterIdentifier For reading   \sa SetAdapterIdentifier For writing */
PD3DAdapterIdentifier9 AdapterIdentifier; 

         /** \sa GetUniqueDescription For reading   \sa SetUniqueDescription For writing */
PDescArray UniqueDescription; 

         /** \sa GetDisplayModeList For reading   \sa SetDisplayModeList For writing */
PD3DDisplayModeArray DisplayModeList; 

         /** \sa GetDeviceInfoList For reading   \sa SetDeviceInfoList For writing */
Pz3DDeviceInfoList DeviceInfoList; 

 };


    class Tz3DEnumDeviceInfo : public Tz3DBase,Iz3DEnumDeviceInfo
{
public:

  private:
      LongWord FAdapterOrdinal; 

      TD3DDevType FDeviceType; 

      TD3DCaps9 FCaps; 

      Tz3DDeviceSettingsComboList FDeviceSettingsComboList; 

  protected:
      
LongWord GetAdapterOrdinal ();
 ;
      
TD3DCaps9 GetCaps ();
 ;
      
Pz3DDeviceSettingsComboList GetDeviceSettingsComboList ();
 ;
      
TD3DDevType GetDeviceType ();
 ;
       
SetAdapterOrdinal (const LongWord Value 
);
 ;
       
SetCaps (const TD3DCaps9 Value 
);
 ;
       
SetDeviceSettingsComboList (const Pz3DDeviceSettingsComboList Value 
);
 ;
       
SetDeviceType (const TD3DDevType Value 
);
 ;
  public:
     
~Tz3DEnumDeviceInfo ();
 ;
  public:
         /** \sa GetAdapterOrdinal For reading   \sa SetAdapterOrdinal For writing */
LongWord AdapterOrdinal; 

         /** \sa GetDeviceType For reading   \sa SetDeviceType For writing */
TD3DDevType DeviceType; 

         /** \sa GetCaps For reading   \sa SetCaps For writing */
TD3DCaps9 Caps; 

         /** \sa GetDeviceSettingsComboList For reading   \sa SetDeviceSettingsComboList For writing */
Pz3DDeviceSettingsComboList DeviceSettingsComboList; 

 };


/*==============================================================================*/ 
/*== Core state                                                               ==*/ 
/*==============================================================================*/ 
/*== This interface holds the general state of the core engine to the user    ==*/ 
/*==============================================================================*/ 



    class Tz3DState : public Tz3DBase,Iz3DState
{
public:

  private:
      
Boolean GetActive ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      /// \sa Direct3D9

HMONITOR GetAdapterMonitor ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetAllowShortcutKeys ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetAllowShortcutKeysWhenFullscreen ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetAllowShortcutKeysWhenWindowed ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetAutoChangeAdapter ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
PD3DSurfaceDesc GetBackBufferSurfaceDesc ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
PD3DCaps9 GetCaps ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetClipCursorWhenFullScreen ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetConstantFrameTime ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Pz3DDeviceSettings GetCurrentDeviceSettings ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Integer GetCurrentFrameNumber ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
IDirect3D9 GetD3D ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
IDirect3DDevice9 GetD3DDevice ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Iz3DDeviceList Getz3DDeviceList ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetDeviceCreateCalled ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetDeviceCreated ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Tz3DCallback_DeviceCreated GetDeviceCreatedFunc ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Tz3DCallback_DeviceDestroyed GetDeviceDestroyedFunc ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetDeviceLost ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Tz3DCallback_DeviceLost GetDeviceLostFunc ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetDeviceObjectsCreated ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetDeviceObjectsReset ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Tz3DCallback_DeviceReset GetDeviceResetFunc ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
PWideChar GetDeviceStats ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean Getz3DInitCalled ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean Getz3DInited ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Single GetElapsedTime ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Integer GetExitCode ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Single GetFPS ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Tz3DCallback_FrameMove GetFrameMoveFunc ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Tz3DCallback_FrameRender GetFrameRenderFunc ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
PWideChar GetFrameStats ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetHandleDefaultHotkeys ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
HWND GetHWNDFocus ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
HWND GetHWNDDeviceFullScreen ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
HWND GetHWNDDeviceWindowed ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetIgnoreSizeChange ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetNotifyOnMouseMove ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetInsideDeviceCallback ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetInsideMainloop ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Tz3DCallback_AcceptDevice GetAcceptDeviceFunc ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Tz3DCallback_Keyboard GetKeyboardFunc ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
HHOOK GetKeyboardHook ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
DWORD GetLastStatsUpdateFrames ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetCursorWatermark ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Double GetLastStatsUpdateTime ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetMaximized ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
HMENU GetMenu ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetMinimized ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Tz3DCallback_ModifyDeviceSettings GetModifyDeviceSettingsFunc ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Tz3DCallback_Mouse GetMouseFunc ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Integer GetOverrideAdapterOrdinal ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetOverrideConstantFrameTime ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Single GetOverrideConstantTimePerFrame ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetOverrideForceHAL ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetOverrideForceHWVP ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetOverrideForcePureHWVP ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetOverrideForceREF ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetOverrideForceSWVP ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetOverrideFullScreen ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Integer GetOverrideHeight ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Integer GetOverrideQuitAfterFrame ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Integer GetOverrideForceVsync ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Integer GetOverrideStartX ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Integer GetOverrideStartY ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Integer GetOverrideWidth ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetOverrideWindowed ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Integer GetPauseRenderingCount ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Integer GetPauseTimeCount ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetRenderingPaused ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetShowCursorWhenFullScreen ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetShowMsgBoxOnError ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetNoStats ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
TFilterKeys GetStartupFilterKeys ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
TStickyKeys GetStartupStickyKeys ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
TToggleKeys GetStartupToggleKeys ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
PWideChar GetStaticFrameStats ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
PWideChar GetFPSStats ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Double GetTime ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Double GetAbsoluteTime ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetTimePaused ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Single GetTimePerFrame ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Tz3DTimerRecordArray GetTimerList ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Pz3DKeysArray GetKeys ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Pz3DMouseButtonsArray GetMouseButtons ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetWindowCreateCalled ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetWindowCreated ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetWindowCreatedWithDefaultPositions ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Tz3DCallback_MsgProc GetWindowMsgFunc ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
PWideChar GetWindowTitle ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetWireframeMode ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
LongWord GetFullScreenBackBufferWidthAtModeChange ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
PWideChar GetCurrentApp ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
LongWord GetFullScreenBackBufferHeightAtModeChange ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
LongWord GetWindowBackBufferWidthAtModeChange ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
LongWord GetWindowBackBufferHeightAtModeChange ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
PWindowPlacement GetWindowedPlacement ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
DWORD GetWindowedStyleAtModeChange ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetTopmostWhileWindowed ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetMinimizedWhileFullscreen ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
HINST GetHInstance ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetAutomation ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetInSizeMove ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Pointer GetAcceptDeviceFuncUserContext ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Pointer GetModifyDeviceSettingsFuncUserContext ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Pointer GetDeviceCreatedFuncUserContext ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Pointer GetDeviceResetFuncUserContext ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Pointer GetDeviceLostFuncUserContext ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Pointer GetDeviceDestroyedFuncUserContext ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Pointer GetFrameMoveFuncUserContext ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Pointer GetFrameRenderFuncUserContext ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Pointer GetKeyboardFuncUserContext ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Pointer GetMouseFuncUserContext ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Pointer GetWindowMsgFuncUserContext ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetCallDefWindowProc ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Boolean GetHandleAltEnter ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
      
Single GetStatsUpdateInterval ();
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetActive (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetAdapterMonitor (const Direct3D9::ONITOR Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetAllowShortcutKeys (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetAllowShortcutKeysWhenFullscreen (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetAllowShortcutKeysWhenWindowed (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetAutoChangeAdapter (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetBackBufferSurfaceDesc (const PD3DSurfaceDesc Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetCaps (const PD3DCaps9 Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetClipCursorWhenFullScreen (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetConstantFrameTime (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetCurrentDeviceSettings (const Pz3DDeviceSettings Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetCurrentFrameNumber (const Integer Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetD3D (const IDirect3D9 Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetD3DDevice (const IDirect3DDevice9 Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
Setz3DDeviceList (const Iz3DDeviceList Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetDeviceCreateCalled (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetDeviceCreated (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
             
SetDeviceCreatedFunc (const Tz3DCallback_DeviceCreated Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
             
SetDeviceDestroyedFunc (const Tz3DCallback_DeviceDestroyed Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetDeviceLost (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetDeviceLostFunc (const Tz3DCallback_DeviceLost Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetDeviceObjectsCreated (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetDeviceObjectsReset (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetDeviceResetFunc (const Tz3DCallback_DeviceReset Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
Setz3DInitCalled (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
Setz3DInited (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetElapsedTime (const Single Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetExitCode (const Integer Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetFPS (const Single Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetFrameMoveFunc (const Tz3DCallback_FrameMove Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetFrameRenderFunc (const Tz3DCallback_FrameRender Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetHandleDefaultHotkeys (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetHWNDFocus (const HWND Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetHWNDDeviceFullScreen (const HWND Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetHWNDDeviceWindowed (const HWND Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetIgnoreSizeChange (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetNotifyOnMouseMove (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetInsideDeviceCallback (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetInsideMainloop (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
             
SetAcceptDeviceFunc (const Tz3DCallback_AcceptDevice Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetKeyboardFunc (const Tz3DCallback_Keyboard Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetKeyboardHook (const HHOOK Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetLastStatsUpdateFrames (const DWORD Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetLastStatsUpdateTime (const Double Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetMaximized (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetMenu (const HMENU Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetMinimized (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
             
SetModifyDeviceSettingsFunc (const Tz3DCallback_ModifyDeviceSettings Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetMouseFunc (const Tz3DCallback_Mouse Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetOverrideAdapterOrdinal (const Integer Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetOverrideConstantFrameTime (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetOverrideConstantTimePerFrame (const Single Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetOverrideForceHAL (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetOverrideForceHWVP (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetOverrideForcePureHWVP (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetOverrideForceREF (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetOverrideForceSWVP (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetOverrideFullScreen (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetOverrideHeight (const Integer Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetOverrideQuitAfterFrame (const Integer Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetOverrideForceVsync (const Integer Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetOverrideRelaunchMCE (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetOverrideStartX (const Integer Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetOverrideStartY (const Integer Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetOverrideWidth (const Integer Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetOverrideWindowed (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetPauseRenderingCount (const Integer Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetPauseTimeCount (const Integer Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetRenderingPaused (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetShowCursorWhenFullScreen (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetShowMsgBoxOnError (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetNoStats (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetStartupFilterKeys (const TFilterKeys Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetStartupStickyKeys (const TStickyKeys Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetStartupToggleKeys (const TToggleKeys Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetTime (const Double Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetAbsoluteTime (const Double Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetTimePaused (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetTimePerFrame (const Single Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetTimerList (const Tz3DTimerRecordArray Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetWindowCreateCalled (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetWindowCreated (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetWindowCreatedWithDefaultPositions (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetWindowMsgFunc (const Tz3DCallback_MsgProc Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetWireframeMode (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetFullScreenBackBufferWidthAtModeChange (const LongWord Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetFullScreenBackBufferHeightAtModeChange (const LongWord Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetWindowBackBufferWidthAtModeChange (const LongWord Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetWindowBackBufferHeightAtModeChange (const LongWord Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetWindowedPlacement (const PWindowPlacement Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetWindowedStyleAtModeChange (const DWORD Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetCursorWatermark (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetTopmostWhileWindowed (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetMinimizedWhileFullscreen (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetHInstance (const HINST Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetAutomation (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetInSizeMove (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetStatsUpdateInterval (const Single Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetAcceptDeviceFuncUserContext (const Pointer Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetModifyDeviceSettingsFuncUserContext (const Pointer Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetDeviceCreatedFuncUserContext (const Pointer Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetDeviceResetFuncUserContext (const Pointer Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetDeviceLostFuncUserContext (const Pointer Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetDeviceDestroyedFuncUserContext (const Pointer Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetFrameMoveFuncUserContext (const Pointer Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetFrameRenderFuncUserContext (const Pointer Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetKeyboardFuncUserContext (const Pointer Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetMouseFuncUserContext (const Pointer Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetWindowMsgFuncUserContext (const Pointer Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetCallDefWindowProc (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
       
SetHandleAltEnter (const Boolean Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
        
AppException (TObject Sender ,
Exception E 
);

       
SetCurrentApp (const PWideChar Value 
);
#ifdef  STATE_ACCESS_INLINE
 #endif
 ;
  public:
         
Tz3DState (const Iz3DBase AOwner = nil 
);
 ;
     
~Tz3DState ();
 ;
     
CreateState ();
 ;
     
DestroyState ();
 ;
  public:
         /** \sa GetD3D For reading   \sa SetD3D For writing */
IDirect3D9 D3D; 

         /** \sa GetD3DDevice For reading   \sa SetD3DDevice For writing */
IDirect3DDevice9 D3DDevice; 

         /** \sa Getz3DDeviceList For reading   \sa Setz3DDeviceList For writing */
Iz3DDeviceList z3DDeviceList; 

         /** \sa GetCurrentDeviceSettings For reading   \sa SetCurrentDeviceSettings For writing */
Pz3DDeviceSettings CurrentDeviceSettings; 

         /** \sa GetBackBufferSurfaceDesc For reading   \sa SetBackBufferSurfaceDesc For writing */
PD3DSurfaceDesc BackBufferSurfaceDesc; 

         /** \sa GetCaps For reading   \sa SetCaps For writing */
PD3DCaps9 Caps; 

         /** \sa GetHWNDFocus For reading   \sa SetHWNDFocus For writing */
HWND HWNDFocus; 

         /** \sa GetHWNDDeviceFullScreen For reading   \sa SetHWNDDeviceFullScreen For writing */
HWND HWNDDeviceFullScreen; 

         /** \sa GetHWNDDeviceWindowed For reading   \sa SetHWNDDeviceWindowed For writing */
HWND HWNDDeviceWindowed; 

         /** \sa GetAdapterMonitor For reading   \sa SetAdapterMonitor For writing */
HMONITOR AdapterMonitor; 

         /** \sa GetMenu For reading   \sa SetMenu For writing */
HMENU Menu; 

         /** \sa GetFullScreenBackBufferWidthAtModeChange For reading   \sa SetFullScreenBackBufferWidthAtModeChange For writing */
LongWord FullScreenBackBufferWidthAtModeChange; 

         /** \sa GetFullScreenBackBufferHeightAtModeChange For reading   \sa SetFullScreenBackBufferHeightAtModeChange For writing */
LongWord FullScreenBackBufferHeightAtModeChange; 

         /** \sa GetWindowBackBufferWidthAtModeChange For reading   \sa SetWindowBackBufferWidthAtModeChange For writing */
LongWord WindowBackBufferWidthAtModeChange; 

         /** \sa GetWindowBackBufferHeightAtModeChange For reading   \sa SetWindowBackBufferHeightAtModeChange For writing */
LongWord WindowBackBufferHeightAtModeChange; 

         /** \sa GetWindowedPlacement For reading   \sa SetWindowedPlacement For writing */
PWindowPlacement WindowedPlacement; 

         /** \sa GetWindowedStyleAtModeChange For reading   \sa SetWindowedStyleAtModeChange For writing */
DWORD WindowedStyleAtModeChange; 

         /** \sa GetTopmostWhileWindowed For reading   \sa SetTopmostWhileWindowed For writing */
Boolean TopmostWhileWindowed; 

         /** \sa GetMinimized For reading   \sa SetMinimized For writing */
Boolean Minimized; 

         /** \sa GetMaximized For reading   \sa SetMaximized For writing */
Boolean Maximized; 

         /** \sa GetMinimizedWhileFullscreen For reading   \sa SetMinimizedWhileFullscreen For writing */
Boolean MinimizedWhileFullscreen; 

         /** \sa GetIgnoreSizeChange For reading   \sa SetIgnoreSizeChange For writing */
Boolean IgnoreSizeChange; 

         /** \sa GetTime For reading   \sa SetTime For writing */
Double Time; 

         /** \sa GetAbsoluteTime For reading   \sa SetAbsoluteTime For writing */
Double AbsoluteTime; 

         /** \sa GetElapsedTime For reading   \sa SetElapsedTime For writing */
Single ElapsedTime; 

         /** \sa GetHInstance For reading   \sa SetHInstance For writing */
HINST HInstance; 

         /** \sa GetLastStatsUpdateTime For reading   \sa SetLastStatsUpdateTime For writing */
Double LastStatsUpdateTime; 

         /** \sa GetLastStatsUpdateFrames For reading   \sa SetLastStatsUpdateFrames For writing */
DWORD LastStatsUpdateFrames; 

         /** \sa GetFPS For reading   \sa SetFPS For writing */
Single FPS; 

         /** \sa GetStatsUpdateInterval For reading   \sa SetStatsUpdateInterval For writing */
Single StatsUpdateInterval; 

         /** \sa GetCurrentFrameNumber For reading   \sa SetCurrentFrameNumber For writing */
Integer CurrentFrameNumber; 

         /** \sa GetKeyboardHook For reading   \sa SetKeyboardHook For writing */
HHOOK KeyboardHook; 

         /** \sa GetAllowShortcutKeysWhenFullscreen For reading   \sa SetAllowShortcutKeysWhenFullscreen For writing */
Boolean AllowShortcutKeysWhenFullscreen; 

         /** \sa GetAllowShortcutKeysWhenWindowed For reading   \sa SetAllowShortcutKeysWhenWindowed For writing */
Boolean AllowShortcutKeysWhenWindowed; 

         /** \sa GetAllowShortcutKeys For reading   \sa SetAllowShortcutKeys For writing */
Boolean AllowShortcutKeys; 

         /** \sa GetCallDefWindowProc For reading   \sa SetCallDefWindowProc For writing */
Boolean CallDefWindowProc; 

         /** \sa GetStartupStickyKeys For reading   \sa SetStartupStickyKeys For writing */
TStickyKeys StartupStickyKeys; 

         /** \sa GetStartupToggleKeys For reading   \sa SetStartupToggleKeys For writing */
TToggleKeys StartupToggleKeys; 

         /** \sa GetStartupFilterKeys For reading   \sa SetStartupFilterKeys For writing */
TFilterKeys StartupFilterKeys; 

         /** \sa GetHandleDefaultHotkeys For reading   \sa SetHandleDefaultHotkeys For writing */
Boolean HandleDefaultHotkeys; 

         /** \sa GetHandleAltEnter For reading   \sa SetHandleAltEnter For writing */
Boolean HandleAltEnter; 

         /** \sa GetShowMsgBoxOnError For reading   \sa SetShowMsgBoxOnError For writing */
Boolean ShowMsgBoxOnError; 

         /** \sa GetNoStats For reading   \sa SetNoStats For writing */
Boolean NoStats; 

         /** \sa GetClipCursorWhenFullScreen For reading   \sa SetClipCursorWhenFullScreen For writing */
Boolean ClipCursorWhenFullScreen; 

         /** \sa GetShowCursorWhenFullScreen For reading   \sa SetShowCursorWhenFullScreen For writing */
Boolean ShowCursorWhenFullScreen; 

         /** \sa GetCursorWatermark For reading   \sa SetCursorWatermark For writing */
Boolean CursorWatermark; 

         /** \sa GetConstantFrameTime For reading   \sa SetConstantFrameTime For writing */
Boolean ConstantFrameTime; 

         /** \sa GetTimePerFrame For reading   \sa SetTimePerFrame For writing */
Single TimePerFrame; 

         /** \sa GetWireframeMode For reading   \sa SetWireframeMode For writing */
Boolean WireframeMode; 

         /** \sa GetAutoChangeAdapter For reading   \sa SetAutoChangeAdapter For writing */
Boolean AutoChangeAdapter; 

         /** \sa GetWindowCreatedWithDefaultPositions For reading   \sa SetWindowCreatedWithDefaultPositions For writing */
Boolean WindowCreatedWithDefaultPositions; 

         /** \sa GetCurrentApp For reading   \sa SetCurrentApp For writing */
PWideChar CurrentApp; 

         /** \sa GetExitCode For reading   \sa SetExitCode For writing */
Integer ExitCode; 

         /** \sa Getz3DInited For reading   \sa Setz3DInited For writing */
Boolean z3DInited; 

         /** \sa GetWindowCreated For reading   \sa SetWindowCreated For writing */
Boolean WindowCreated; 

         /** \sa GetDeviceCreated For reading   \sa SetDeviceCreated For writing */
Boolean DeviceCreated; 

         /** \sa Getz3DInitCalled For reading   \sa Setz3DInitCalled For writing */
Boolean z3DInitCalled; 

         /** \sa GetWindowCreateCalled For reading   \sa SetWindowCreateCalled For writing */
Boolean WindowCreateCalled; 

         /** \sa GetDeviceCreateCalled For reading   \sa SetDeviceCreateCalled For writing */
Boolean DeviceCreateCalled; 

         /** \sa GetInsideDeviceCallback For reading   \sa SetInsideDeviceCallback For writing */
Boolean InsideDeviceCallback; 

         /** \sa GetInsideMainloop For reading   \sa SetInsideMainloop For writing */
Boolean InsideMainloop; 

         /** \sa GetDeviceObjectsCreated For reading   \sa SetDeviceObjectsCreated For writing */
Boolean DeviceObjectsCreated; 

         /** \sa GetDeviceObjectsReset For reading   \sa SetDeviceObjectsReset For writing */
Boolean DeviceObjectsReset; 

         /** \sa GetActive For reading   \sa SetActive For writing */
Boolean Active; 

         /** \sa GetRenderingPaused For reading   \sa SetRenderingPaused For writing */
Boolean RenderingPaused; 

         /** \sa GetTimePaused For reading   \sa SetTimePaused For writing */
Boolean TimePaused; 

         /** \sa GetPauseRenderingCount For reading   \sa SetPauseRenderingCount For writing */
Integer PauseRenderingCount; 

         /** \sa GetPauseTimeCount For reading   \sa SetPauseTimeCount For writing */
Integer PauseTimeCount; 

         /** \sa GetDeviceLost For reading   \sa SetDeviceLost For writing */
Boolean DeviceLost; 

         /** \sa GetNotifyOnMouseMove For reading   \sa SetNotifyOnMouseMove For writing */
Boolean NotifyOnMouseMove; 

         /** \sa GetOverrideAdapterOrdinal For reading   \sa SetOverrideAdapterOrdinal For writing */
Integer OverrideAdapterOrdinal; 

         /** \sa GetOverrideWindowed For reading   \sa SetOverrideWindowed For writing */
Boolean OverrideWindowed; 

         /** \sa GetOverrideFullScreen For reading   \sa SetOverrideFullScreen For writing */
Boolean OverrideFullScreen; 

         /** \sa GetOverrideStartX For reading   \sa SetOverrideStartX For writing */
Integer OverrideStartX; 

         /** \sa GetOverrideStartY For reading   \sa SetOverrideStartY For writing */
Integer OverrideStartY; 

         /** \sa GetOverrideWidth For reading   \sa SetOverrideWidth For writing */
Integer OverrideWidth; 

         /** \sa GetOverrideHeight For reading   \sa SetOverrideHeight For writing */
Integer OverrideHeight; 

         /** \sa GetOverrideForceHAL For reading   \sa SetOverrideForceHAL For writing */
Boolean OverrideForceHAL; 

         /** \sa GetOverrideForceREF For reading   \sa SetOverrideForceREF For writing */
Boolean OverrideForceREF; 

         /** \sa GetOverrideForcePureHWVP For reading   \sa SetOverrideForcePureHWVP For writing */
Boolean OverrideForcePureHWVP; 

         /** \sa GetOverrideForceHWVP For reading   \sa SetOverrideForceHWVP For writing */
Boolean OverrideForceHWVP; 

         /** \sa GetOverrideForceSWVP For reading   \sa SetOverrideForceSWVP For writing */
Boolean OverrideForceSWVP; 

         /** \sa GetOverrideConstantFrameTime For reading   \sa SetOverrideConstantFrameTime For writing */
Boolean OverrideConstantFrameTime; 

         /** \sa GetOverrideConstantTimePerFrame For reading   \sa SetOverrideConstantTimePerFrame For writing */
Single OverrideConstantTimePerFrame; 

         /** \sa GetOverrideQuitAfterFrame For reading   \sa SetOverrideQuitAfterFrame For writing */
Integer OverrideQuitAfterFrame; 

         /** \sa GetOverrideForceVsync For reading   \sa SetOverrideForceVsync For writing */
Integer OverrideForceVsync; 

         /** \sa GetAcceptDeviceFunc For reading   \sa SetAcceptDeviceFunc For writing */
Tz3DCallback_AcceptDevice AcceptDeviceFunc; 

         /** \sa GetModifyDeviceSettingsFunc For reading   \sa SetModifyDeviceSettingsFunc For writing */
Tz3DCallback_ModifyDeviceSettings ModifyDeviceSettingsFunc; 

         /** \sa GetDeviceCreatedFunc For reading   \sa SetDeviceCreatedFunc For writing */
Tz3DCallback_DeviceCreated DeviceCreatedFunc; 

         /** \sa GetDeviceResetFunc For reading   \sa SetDeviceResetFunc For writing */
Tz3DCallback_DeviceReset DeviceResetFunc; 

         /** \sa GetDeviceLostFunc For reading   \sa SetDeviceLostFunc For writing */
Tz3DCallback_DeviceLost DeviceLostFunc; 

         /** \sa GetDeviceDestroyedFunc For reading   \sa SetDeviceDestroyedFunc For writing */
Tz3DCallback_DeviceDestroyed DeviceDestroyedFunc; 

         /** \sa GetFrameMoveFunc For reading   \sa SetFrameMoveFunc For writing */
Tz3DCallback_FrameMove FrameMoveFunc; 

         /** \sa GetFrameRenderFunc For reading   \sa SetFrameRenderFunc For writing */
Tz3DCallback_FrameRender FrameRenderFunc; 

         /** \sa GetKeyboardFunc For reading   \sa SetKeyboardFunc For writing */
Tz3DCallback_Keyboard KeyboardFunc; 

         /** \sa GetMouseFunc For reading   \sa SetMouseFunc For writing */
Tz3DCallback_Mouse MouseFunc; 

         /** \sa GetWindowMsgFunc For reading   \sa SetWindowMsgFunc For writing */
Tz3DCallback_MsgProc WindowMsgFunc; 

         /** \sa GetAutomation For reading   \sa SetAutomation For writing */
Boolean Automation; 

         /** \sa GetInSizeMove For reading   \sa SetInSizeMove For writing */
Boolean InSizeMove; 

         /** \sa GetAcceptDeviceFuncUserContext For reading   \sa SetAcceptDeviceFuncUserContext For writing */
Pointer AcceptDeviceFuncUserContext; 

         /** \sa GetModifyDeviceSettingsFuncUserContext For reading   \sa SetModifyDeviceSettingsFuncUserContext For writing */
Pointer ModifyDeviceSettingsFuncUserContext; 

         /** \sa GetDeviceCreatedFuncUserContext For reading   \sa SetDeviceCreatedFuncUserContext For writing */
Pointer DeviceCreatedFuncUserContext; 

         /** \sa GetDeviceResetFuncUserContext For reading   \sa SetDeviceResetFuncUserContext For writing */
Pointer DeviceResetFuncUserContext; 

         /** \sa GetDeviceLostFuncUserContext For reading   \sa SetDeviceLostFuncUserContext For writing */
Pointer DeviceLostFuncUserContext; 

         /** \sa GetDeviceDestroyedFuncUserContext For reading   \sa SetDeviceDestroyedFuncUserContext For writing */
Pointer DeviceDestroyedFuncUserContext; 

         /** \sa GetFrameMoveFuncUserContext For reading   \sa SetFrameMoveFuncUserContext For writing */
Pointer FrameMoveFuncUserContext; 

         /** \sa GetFrameRenderFuncUserContext For reading   \sa SetFrameRenderFuncUserContext For writing */
Pointer FrameRenderFuncUserContext; 

         /** \sa GetKeyboardFuncUserContext For reading   \sa SetKeyboardFuncUserContext For writing */
Pointer KeyboardFuncUserContext; 

         /** \sa GetMouseFuncUserContext For reading   \sa SetMouseFuncUserContext For writing */
Pointer MouseFuncUserContext; 

         /** \sa GetWindowMsgFuncUserContext For reading   \sa SetWindowMsgFuncUserContext For writing */
Pointer WindowMsgFuncUserContext; 

         /** \sa GetTimerList For reading   \sa SetTimerList For writing */
Tz3DTimerRecordArray TimerList; 

       /** \sa GetKeys For reading*/
Pz3DKeysArray Keys; 

       /** \sa GetMouseButtons For reading*/
Pz3DMouseButtonsArray MouseButtons; 

       /** \sa GetStaticFrameStats For reading*/
PWideChar StaticFrameStats; 

       /** \sa GetFPSStats For reading*/
PWideChar FPSStats; 

       /** \sa GetFrameStats For reading*/
PWideChar FrameStats; 

       /** \sa GetDeviceStats For reading*/
PWideChar DeviceStats; 

       /** \sa GetWindowTitle For reading*/
PWideChar WindowTitle; 

 };


// Wide char extended support

        
z3DCreateWideChar (PWideChar &AWideChar ,
const Integer ASize = 255 
);
 ;
  
PWideChar z3DWideBuffer ();
 ;
   
z3DFreeWideChar (PWideChar &AWideChar 
);
 ;

/*==============================================================================*/ 
/*== Global access functions                                                  ==*/ 
/*==============================================================================*/ 
/*== These functions controls the core state and allows to communicate with   ==*/ 
/*== the core controllers                                                     ==*/ 
/*==============================================================================*/ 

        
z3DTrace (const PWideChar AMessage ,
const Tz3DTraceKind AKind = z3DtkInformation 
);
 ;
             
Boolean z3DTraceCondition (const Boolean ACondition ,
const PWideChar AMessage ,
const Tz3DTraceKind AKind = z3DtkInformation 
);
 ;

                  
HRESULT z3DInit (Boolean bParseCommandLine = True ,
Boolean bHandleDefaultHotkeys = True ,
Boolean bShowMsgBoxOnError = True ,
Boolean bHandleAltEnter = True 
);
 ;
    
z3DCore_Shutdown (Integer nExitCode = 0 
);
 ;

                      (
z3DCore_CreateWindow (const PWideChar strWindowTitle = nil ,
LongWord hInstance = 0 ,
HICON hIcon = 0 ,
HMENU hMenu = 0 ,
Integer x = Integer ,
 CW_USEDEFAULT 
);
 y: Integer = Integer(CW_USEDEFAULT)): HRESULT; ;
         
HRESULT z3DCore_SetWindow (HWND hWndFocus ,
HWND hWndDeviceFullScreen ,
HWND hWndDeviceWindowed ,
Boolean bHandleMessages = True 
);
 ;
         
LRESULT z3DCore_StaticWndProc (Windows::ND hWnd ,
LongWord uMsg ,
WPARAM wParam ,
LPARAM lParam 
);
 ;

  
z3DDisplayErrorMessage (HRESULT hr 
);
  ;
                               
HRESULT z3DCore_CreateDevice (LongWord AdapterOrdinal = D3DADAPTER_DEFAULT ,
Boolean bWindowed = True ,
Integer nSuggestedWidth = 0 ,
Integer nSuggestedHeight = 0 ,
Tz3DCallback_AcceptDevice pCallbackAcceptDevice = nil ,
Tz3DCallback_ModifyDeviceSettings pCallbackModifyDeviceSettings = nil ,
Pointer pUserContext = nil 
);
 ;
            
HRESULT z3DCore_CreateDeviceFromSettings (Pz3DDeviceSettings pDeviceSettings ,
Boolean bPreserveInput = False ,
Boolean bClipWindowToSingleAdapter = True 
);
 ;
   
HRESULT z3DCore_SetDevice (IDirect3DDevice9 pd3dDevice 
);
 ;
     
HRESULT z3DCore_MainLoop (HACCEL hAccel = 0 
);
 ;
          
UINT z3DCore_ProcessMessages (HACCEL hAccel = 0 ,
const Boolean ARender = True 
);
 ;
 
z3DCore_Render3DEnvironment ();
 ;

  
Iz3DDeviceList z3DCore_GetDeviceList ();
 ;
   
LongWord z3DCore_GetStencilBits (TD3DFormat fmt 
);
 ;
   
LongWord z3DCore_GetDepthBits (TD3DFormat fmt 
);
 ;
   
LongWord z3DCore_GetAlphaChannelBits (TD3DFormat fmt 
);
 ;
   
Integer z3DCore_GetColorChannelBits (TD3DFormat fmt 
);
 ;

  
Iz3DResourceCache z3DCore_GetGlobalResourceCache ();
 ;
  
Iz3DTimer z3DCore_GetGlobalTimer ();
 ;
  
Iz3DState z3DCore_GetState ();
 ;
 
z3DCore_FreeState ();
 ;
  
IDirect3D9 z3DCore_GetD3DObject ();
 ;
  
IDirect3DDevice9 z3DCore_GetD3DDevice ();
 ;
  
Tz3DDeviceSettings z3DCore_GetDeviceSettings ();
 ;
  
TD3DPresentParameters z3DCore_GetPresentParameters ();
 ;
  
PD3DSurfaceDesc z3DCore_GetBackBufferSurfaceDesc ();
 ;
  
PD3DCaps9 z3DCore_GetDeviceCaps ();
 ;
  
HINST z3DCore_GetHINSTANCE ();
 ;
  
HWND z3DCore_GetHWND ();
 ;
  
HWND z3DCore_GetHWNDFocus ();
 ;
  
HWND z3DCore_GetHWNDDeviceFullScreen ();
 ;
  
HWND z3DCore_GetHWNDDeviceWindowed ();
 ;
  
TRect z3DCore_GetWindowClientRect ();
 ;
  
TRect z3DCore_GetWindowClientRectAtModeChange ();
 ;
  
TRect z3DCore_GetFullsceenClientRectAtModeChange ();
 ;
  
Double z3DCore_GetTime ();
 ;
  
Single z3DCore_GetElapsedTime ();
 ;
  
Boolean z3DCore_IsWindowed ();
 ;
  
Single z3DCore_GetFPS ();
 ;
  
PWideChar z3DCore_GetWindowTitle ();
 ;
     
PWideChar z3DCore_GetFrameStats (Boolean bIncludeFPS = False 
);
 ;
  
PWideChar z3DCore_GetDeviceStats ();
 ;
  
Boolean z3DCore_IsRenderingPaused ();
 ;
  
Boolean z3DCore_IsTimePaused ();
 ;
  
Boolean z3DCore_IsActive ();
 ;
  
Integer z3DCore_GetExitCode ();
 ;
  
Boolean z3DCore_GetShowMsgBoxOnError ();
 ;
  
Boolean z3DCore_GetHandleDefaultHotkeys ();
 ;
   
Boolean z3DCore_IsKeyDown (Byte vKey 
);
 ;
   
Boolean z3DCore_IsMouseButtonDown (Byte vButton 
);
 ;
  
Boolean z3DCore_GetAutomation ();
 ;
             
HRESULT z3DCore_FindValidDeviceSettings (/* out */ Tz3DDeviceSettings &pOut ,
Pz3DDeviceSettings pIn = nil ,
Pz3DMatchOptions pMatchOptions = nil 
);
 ;

   
z3DCore_SetCursorSettings (Boolean bShowCursorWhenFullScreen ,
Boolean bClipCursorWhenFullScreen 
);
 ;
  
z3DCore_SetMultimonSettings (Boolean bAutoChangeAdapter 
);
 ;
        
z3DCore_SetShortcutKeySettings (Boolean bAllowWhenFullscreen = False ,
Boolean bAllowWhenWindowed = True 
);
 ;
    
z3DCore_SetWindowSettings (Boolean bCallDefWindowProc = True 
);
 ;
      .0333
z3DCore_SetConstantFrameTime (Boolean bConstantFrameTime ,
Single fTimePerFrame = 0 
);
 ;
                
HRESULT z3DCore_SetTimer (Tz3DCallback_Timer pCallbackTimer ,
Single fTimeoutInSecs = 1 ,
PLongWord pnIDEvent = nil ,
Pointer pCallbackUserContext = nil 
);
 ;
   
HRESULT z3DCore_KillTimer (LongWord nIDEvent 
);
 ;
  
HRESULT z3DCore_ToggleFullScreen ();
 ;
  
HRESULT z3DCore_ToggleREF ();
 ;
   
z3DCore_Pause (Boolean bPauseTime ,
Boolean bPauseRendering 
);
 ;
 
z3DCore_ResetEngineState ();
 ;

      
z3DCore_GetDesktopResolution (LongWord AdapterOrdinal ,
/* out */ LongWord &pWidth ,
/* out */ LongWord &pHeight 
);
 ;
       
IDirect3DDevice9 z3DCore_CreateRefDevice (HWND hWnd ,
Boolean bNullRef = True 
);
 ;

// Callback functions
      
z3DCore_SetCallback_DeviceCreated (Tz3DCallback_DeviceCreated pCallbackDeviceCreated ,
Pointer pUserContext = nil 
);
 ;
      
z3DCore_SetCallback_DeviceReset (Tz3DCallback_DeviceReset pCallbackDeviceReset ,
Pointer pUserContext = nil 
);
 ;
      
z3DCore_SetCallback_DeviceLost (Tz3DCallback_DeviceLost pCallbackDeviceLost ,
Pointer pUserContext = nil 
);
 ;
      
z3DCore_SetCallback_DeviceDestroyed (Tz3DCallback_DeviceDestroyed pCallbackDeviceDestroyed ,
Pointer pUserContext = nil 
);
 ;
      
z3DCore_SetCallback_DeviceChanging (Tz3DCallback_ModifyDeviceSettings pCallbackModifyDeviceSettings ,
Pointer pUserContext = nil 
);
 ;
      
z3DCore_SetCallback_FrameMove (Tz3DCallback_FrameMove pCallbackFrameMove ,
Pointer pUserContext = nil 
);
 ;
      
z3DCore_SetCallback_FrameRender (Tz3DCallback_FrameRender pCallbackFrameRender ,
Pointer pUserContext = nil 
);
 ;
      
z3DCore_SetCallback_Keyboard (Tz3DCallback_Keyboard pCallbackKeyboard ,
Pointer pUserContext = nil 
);
 ;
          
z3DCore_SetCallback_Mouse (Tz3DCallback_Mouse pCallbackMouse ,
Boolean bIncludeMouseMove = False ,
Pointer pUserContext = nil 
);
 ;
      
z3DCore_SetCallback_MsgProc (Tz3DCallback_MsgProc pCallbackMsgProc ,
Pointer pUserContext = nil 
);
 ;

// App starter
 
z3DCore_LaunchAppStart ();
 ;

// Registry control
        
Integer z3DCore_ReadRegIntValue (const PWideChar ASection ,
const PWideChar AKey ,
const Integer ADefault 
);
 ;
        
PWideChar z3DCore_ReadRegStrValue (const PWideChar ASection ,
const PWideChar AKey ,
const PWideChar ADefault 
);
 ;
       
z3DCore_WriteRegIntValue (const PWideChar ASection ,
const PWideChar AKey ,
const Integer AValue 
);
 ;
       
z3DCore_WriteRegStrValue (const PWideChar ASection ,
const PWideChar AKey ,
const PWideChar AValue 
);
 ;


// Debug mode and memory management
       
Boolean z3DSupports (const IInterface AInterface ,
const TGUID AGUID 
);
 ;
  
FreeAndNil ( &Obj 
);
#ifdef  SUPPORTS_INLINE
 inline;#endif
 ;
  
SafeRelease ( &i 
);
#ifdef  SUPPORTS_INLINE
 inline;#endif
 ;
  
SafeDelete ( &Obj 
);
#ifdef  SUPPORTS_INLINE
 inline;#endif
 ;
  
SafeFreeMem ( &p 
);
#ifdef  SUPPORTS_INLINE
 inline;#endif
 ;

      
z3DCore_OutputDebugString (PWideChar &strMsg ,
const const *args 
);
 ;
      
z3DCore_OutputDebugStringA (PAnsiChar strMsg ,
const const *args 
);
 ;
 z3DCore_OutputDebugStringW:      
 (PWideChar strMsg ,
const const *args 
);
  = z3DCore_OutputDebugString;

             
HRESULT z3DTraceDX (const PChar strFile ,
DWORD dwLine ,
HRESULT hr ,
const PWideChar strMsg ,
Boolean bPopMsgBox 
);
 ;
            $ 
HRESULT z3DError (PWideChar str ,
HRESULT hr ,
PChar FileName = nil ,
DWORD Line = FFFFFFFF 
);
#ifdef  SUPPORTS_INLINE
 inline;#endif
 ;
            $ 
HRESULT z3DErrorMessage (PWideChar str ,
HRESULT hr ,
PChar FileName = nil ,
DWORD Line = FFFFFFFF 
);
#ifdef  SUPPORTS_INLINE
 inline;#endif
 ;
     
z3DTraceDebug (PWideChar strMsg ,
const *args 
);
 ;

   
BOOL z3DFailedTrace (HRESULT Status 
);
#ifdef  SUPPORTS_INLINE
 inline;#endif
 ;


   typedef TKBDLLHookStruct* PKBDLLHookStruct;

   struct tagKBDLLHOOKSTRUCT
{

      DWORD vkCode; 

      DWORD scanCode; 

      DWORD flags; 

      DWORD time; 

      ULONG_PTR dwExtraInfo; 

 };

  
   typedef tagKBDLLHOOKSTRUCT KBDLLHOOKSTRUCT;
  
   typedef KBDLLHOOKSTRUCT TKBDLLHookStruct;


       const  WH_KEYBOARD_LL =  13;
          const  WH_MOUSE_LL =  14;

           const  z3D_PRIMARY_MONITOR =  HMONITOR($12340042);

#ifdef  FPC

   const  VK_LWIN =  91;
   const  VK_RWIN =  92;

   const  E_FAIL =  HRESULT($80004005);
   const  E_INVALIDARG =  HRESULT($80070057);
   const  E_OUTOFMEMORY =  HRESULT($8007000E);
   const  E_NOTIMPL =  HRESULT($80004001);

#endif



    z3DDebugTrace:  const  Boolean =  False;




        
     
/*
var

    GMonitorFromWindow: Boolean = False;
    GMonitorInfo: Boolean = False;
    GGetMonitorFromWindow: TMonitorFromWindow = nil;
    GGetMonitorInfo: TGetMonitorInfo = nil;
    GLog: TStringList;
    GRegistry: TRzRegIniFile;
    GWideBuffer: PWideChar; 

const
  z3DDebugLog = 'C:\z3DDebug.txt';

const
  z3D_GAMEPAD_TRIGGER_THRESHOLD      = 30;
  z3D_INPUT_DEADZONE                 = (0.24 * $7FFF);


        
z3DCreateWideChar (PWideChar &AWideChar ,
const Integer ASize = 255 
)
 ;{
#ifndef DOXYGEN_SKIP
  GetMem(AWideChar, ASize);
  ZeroMemory(AWideChar, ASize);
#endif /* DOXYGEN_SKIP */
};

  
PWideChar z3DWideBuffer ()
 ;{
#ifndef DOXYGEN_SKIP
  Result:= GWideBuffer;
#endif /* DOXYGEN_SKIP */
};

   
z3DFreeWideChar (PWideChar &AWideChar 
)
 ;{
#ifndef DOXYGEN_SKIP
  if AWideChar = nil then Exit;
  FreeMem(AWideChar);
  Pointer(AWideChar):= nil;
#endif /* DOXYGEN_SKIP */
};

        
Integer z3DCore_ReadRegIntValue (const PWideChar ASection ,
const PWideChar AKey ,
const Integer ADefault 
)
{
#ifndef DOXYGEN_SKIP
  Result:= GRegistry.ReadInteger(WideCharToString(ASection), WideCharToString(AKey), ADefault);
#endif /* DOXYGEN_SKIP */
};

        
PWideChar z3DCore_ReadRegStrValue (const PWideChar ASection ,
const PWideChar AKey ,
const PWideChar ADefault 
)

/*
var
 FValue: string;
*/
{
#ifndef DOXYGEN_SKIP

  FValue:= GRegistry.ReadString(WideCharToString(ASection), WideCharToString(AKey), WideCharToString(ADefault));
  StringToWideChar(FValue, GWideBuffer, 255);
  Result:= GWideBuffer;
#endif /* DOXYGEN_SKIP */
};

       
z3DCore_WriteRegIntValue (const PWideChar ASection ,
const PWideChar AKey ,
const Integer AValue 
)
{
#ifndef DOXYGEN_SKIP
  GRegistry.WriteInteger(WideCharToString(ASection), WideCharToString(AKey), AValue);
#endif /* DOXYGEN_SKIP */
};

       
z3DCore_WriteRegStrValue (const PWideChar ASection ,
const PWideChar AKey ,
const PWideChar AValue 
)
{
#ifndef DOXYGEN_SKIP
  GRegistry.WriteString(WideCharToString(ASection), WideCharToString(AKey), WideCharToString(AValue));
#endif /* DOXYGEN_SKIP */
};

       
Boolean z3DSupports (const IInterface AInterface ,
const TGUID AGUID 
)

/*
var
 FInt: IInterface;
*/
{
#ifndef DOXYGEN_SKIP

  AInterface.QueryInterface(AGUID, FInt);
  Result:= FInt <> nil;
#endif /* DOXYGEN_SKIP */
};

        
Boolean DynArrayContains (const Pointer DynArray ,
 &Element ,
Integer &ElementSize 
)

/*
var

  i: Integer;
  p, pp: Pointer;
*/
{
#ifndef DOXYGEN_SKIP

  Result:= False;
  if DynArray = nil then Exit;
  p:= DynArray; Dec(PLongint(p));
  for i:= 0 to PLongint(p)^ - 1 dobegin    pp:= Pointer(Longint(DynArray) + ElementSize*i);
    if CompareMem(@Element, pp, ElementSize) thenbegin      Result:= True;
      Break;
   end
 end
#endif /* DOXYGEN_SKIP */
};


#ifdef  WIN64

  
LongWord PtrToUlong (Pointer p 
)
#ifdef  SUPPORTS_INLINE
 inline;#endif
 ;{
#ifndef DOXYGEN_SKIP
  Result:= LongWord(ULONG_PTR(p));
#endif /* DOXYGEN_SKIP */
};
#endif


#ifdef  D5_OR_FPC

        
WideString WideFormat (const WideString FormatS ,
const const *Args 
)

/*
var

  S: String;
*/
{
#ifndef DOXYGEN_SKIP

  S:= Format(FormatS, Args);
  Result:= S + '_';
  Result[Length(S)+1]:= #0;
  SetLength(Result, Length(S));
#endif /* DOXYGEN_SKIP */
};

             
Cardinal WideFormatBuf ( &Buffer ,
Cardinal &BufLen ,
const  FormatBuf ,
const Integer iFormatLength ,
const const *Args 
)
 ;
/*
var

  l: Integer;
  S: WideString;
#ifdef  FPC

  S1: String;
  i: Integer;
#endif

*/
{
#ifndef DOXYGEN_SKIP

#ifdef  FPC

  for i:= 0 to High(Args) dobegin    if (Args[i].Vtype = vtPointer) or
       (Args[i].Vtype = vtObject) or
       (Args[i].Vtype = vtClass) or
       (Args[i].Vtype = vtVariant)
    then Break;
 end
#endif

  S:= WideFormat(PWideChar(@FormatBuf), Args);
  l:= Min(Length(S)*2, Integer(BufLen)-2);
  Move(S[1], Buffer, l+2);
  Result:= l div 2;
#endif /* DOXYGEN_SKIP */
};
#endif


            
Cardinal WideFormatBuf ( &Buffer ,
Cardinal &BufLen ,
const WideString Format ,
const const *Args 
)
 ;{
#ifndef DOXYGEN_SKIP
  Result:= #ifndef  D5_OR_FPC
SysUtils.#endif
WideFormatBuf(Buffer, BufLen, Format[1], Length(Format), Args);
#endif /* DOXYGEN_SKIP */
};

  
FreeAndNil ( &Obj 
)
#ifndef  DELPHI10
#ifdef  SUPPORTS_INLINE
 inline;#endif
 ;#endif

/*
var
 Temp: TObject;
*/
{
#ifndef DOXYGEN_SKIP

  Temp:= TObject(Obj);
  Pointer(Obj):= nil;
  Temp.Free;
#endif /* DOXYGEN_SKIP */
};

  
SafeRelease ( &i 
)
#ifdef  SUPPORTS_INLINE
 inline;#endif
 ;{
#ifndef DOXYGEN_SKIP
  if IUnknown(i) <> nil then IUnknown(i):= nil;
#endif /* DOXYGEN_SKIP */
};

  
SafeDelete ( &Obj 
)
#ifdef  SUPPORTS_INLINE
 inline;#endif
 ;
/*
var
 Temp: TObject;
*/
{
#ifndef DOXYGEN_SKIP

  Temp:= TObject(Obj);
  Pointer(Obj):= nil;
  Temp.Free;
#endif /* DOXYGEN_SKIP */
};

  
SafeFreeMem ( &p 
)
#ifdef  SUPPORTS_INLINE
 inline;#endif
 ;{
#ifndef DOXYGEN_SKIP
  if (Pointer(p) <> nil) thenbegin    FreeMem(Pointer(p));
    Pointer(p):= nil;
 end
#endif /* DOXYGEN_SKIP */
};

       
Boolean z3DGetMonitorInfo (const HMONITOR &AMonitor ,
Tz3DMonitorInfo &AMonitorInfo 
)

/*
var
 FUser32: HMODULE;
    FVersionInfo: TOSVersionInfo;
    FWorkArea: TRect;
*/
{
#ifndef DOXYGEN_SKIP

  if not GMonitorInfo thenbegin    FUser32 := GetModuleHandle('USER32');
    if (FUser32 <> 0) thenbegin      FVersioninfo.dwOSVersionInfoSize := SizeOf(FVersioninfo);
      GetVersionEx(FVersioninfo);
      if FVersioninfo.dwPlatformId = VER_PLATFORM_WIN32_NT then
      GGetMonitorInfo := GetProcAddress(FUser32, 'GetMonitorInfoW') else
      GGetMonitorInfo := GetProcAddress(FUser32, 'GetMonitorInfoA');
   end
    GMonitorInfo:= True;
 end
  if (@GGetMonitorInfo <> nil) thenbegin    Result:= GGetMonitorInfo(AMonitor, @AMonitorInfo);
    Exit;
 end
  if (AMonitor = z3D_PRIMARY_MONITOR) and (@AMonitorInfo <> nil) and
  (AMonitorInfo.cbSize >= SizeOf(TMonitorInfo)) and
  SystemParametersInfoA(SPI_GETWORKAREA, 0, @FWorkArea, 0) thenbegin    AMonitorInfo.rcMonitor.Left := 0;
    AMonitorInfo.rcMonitor.Top := 0;
    AMonitorInfo.rcMonitor.Right := GetSystemMetrics(SM_CXSCREEN);
    AMonitorInfo.rcMonitor.Bottom := GetSystemMetrics(SM_CYSCREEN);
    AMonitorInfo.rcWork := FWorkArea;
    AMonitorInfo.dwFlags := MONITORINFOF_PRIMARY;
    Result:= True;
    Exit;
 end
  Result:= False;
#endif /* DOXYGEN_SKIP */
};


       
HMONITOR z3DMonitorFromWindow (const HWND AWnd ,
const DWORD AFlags 
)

/*
var
 FUser32: HMODULE;
*/
{
#ifndef DOXYGEN_SKIP

  if not GMonitorFromWindow thenbegin    FUser32 := GetModuleHandle('USER32');
    if (FUser32 <> 0) then
    GGetMonitorFromWindow := GetProcAddress(FUser32, 'MonitorFromWindow');
    GMonitorFromWindow := True;
 end
  if (@GGetMonitorFromWindow <> nil) thenbegin    Result:= GGetMonitorFromWindow(AWnd, AFlags);
    Exit;
 end
  if (AFlags and (MONITOR_DEFAULTTOPRIMARY or MONITOR_DEFAULTTONEAREST) <> 0) thenbegin    Result:= z3D_PRIMARY_MONITOR;
    Exit;
 end
  Result:= 0;
#endif /* DOXYGEN_SKIP */
};

        
z3DTrace (const PWideChar AMessage ,
const Tz3DTraceKind AKind = z3DtkInformation 
)

/*
//const
 FMode: array[Tz3DTraceKind] of LongInt = (MB_ICONINFORMATION, MB_ICONWARNING, MB_ICONSTOP);
const FDesc: array[Tz3DTraceKind] of string = ('Information', 'Warning', 'Error');
*/
{
#ifndef DOXYGEN_SKIP

  if AKind = z3dtkError thenbegin    ShowWindow(z3DCore_GetHWND, SW_HIDE);
    ShowWindow(z3DCore_GetHWNDFocus, SW_HIDE);
    ShowWindow(z3DCore_GetHWNDDeviceFullScreen, SW_HIDE);
    ShowWindow(z3DCore_GetHWNDDeviceWindowed, SW_HIDE);
 end
  if (AKind = z3dtkError) then Application.MessageBox(PAnsiChar(WideCharToString(AMessage)+'.'), 'z3D Engine', MB_OK+FMode[AKind]);
  if z3DDebugTrace thenbegin    if FileExists(z3DDebugLog) then GLog.LoadFromFile(z3DDebugLog);
    GLog.Add(FDesc[AKind]+' - '+AMessage+'. ('+DateTimeToStr(Now)+')');
    GLog.SaveToFile(z3DDebugLog);
 end
  if AKind = z3dtkError then FatalExit(1);
#endif /* DOXYGEN_SKIP */
};

            
Boolean z3DTraceCondition (const Boolean ACondition ,
const PWideChar AMessage ,
const Tz3DTraceKind AKind = z3DtkInformation 
)
{
#ifndef DOXYGEN_SKIP
  if ACondition then z3DTrace(AMessage, AKind);
  Result:= ACondition;
#endif /* DOXYGEN_SKIP */
};


      
z3DCore_OutputDebugString (PWideChar strMsg ,
const const *args 
)

#ifdef  DEBUG

/*
var

  strBuffer: array[0..511] of WideChar;
#endif

*/
{
#ifndef DOXYGEN_SKIP

#ifdef  DEBUG

  StringCchFormat(strBuffer, 512, strMsg, args);
  OutputDebugStringW(strBuffer);
#else

   // Do nothing
#endif

#endif /* DOXYGEN_SKIP */
};

      
z3DCore_OutputDebugStringA (PAnsiChar strMsg ,
const const *args 
)

#ifdef  DEBUG

/*
var
 strBuffer: array[0..511] of AnsiChar;
#endif

*/
{
#ifndef DOXYGEN_SKIP

#ifdef  DEBUG

  StringCchFormat(strBuffer, 512, strMsg, args);
  OutputDebugStringA(strBuffer);
#else

   // Do nothing
#endif

#endif /* DOXYGEN_SKIP */
};

             
HRESULT z3DTraceDX (const PChar strFile ,
DWORD dwLine ,
HRESULT hr ,
const PWideChar strMsg ,
Boolean bPopMsgBox 
)
 ;
/*
var
 bShowMsgBoxOnError: Boolean;
*/
{
#ifndef DOXYGEN_SKIP

  bShowMsgBoxOnError := z3DCore_GetState.ShowMsgBoxOnError;
  if not (bPopMsgBox and bShowMsgBoxOnError) then bPopMsgBox := False;
  Result:= DXTraceW(strFile, dwLine, hr, strMsg, bPopMsgBox);
#endif /* DOXYGEN_SKIP */
};

#ifdef  DEBUG


            $ 
HRESULT z3DError (PWideChar str ,
HRESULT hr ,
PChar FileName = nil ,
DWORD Line = FFFFFFFF 
)
#ifdef  SUPPORTS_INLINE
 inline;#endif
 ;{
#ifndef DOXYGEN_SKIP
  z3DDisplayErrorMessage(hr);
  Result:= hr;
#endif /* DOXYGEN_SKIP */
};

            $ 
HRESULT z3DErrorMessage (PWideChar str ,
HRESULT hr ,
PChar FileName = nil ,
DWORD Line = FFFFFFFF 
)
{
#ifndef DOXYGEN_SKIP
  z3DDisplayErrorMessage(hr);
  Result:= hr;
#endif /* DOXYGEN_SKIP */
};

     
z3DTraceDebug (PWideChar strMsg ,
const *args 
)
{
#ifndef DOXYGEN_SKIP
  z3DTrace('The debugger sent a message on the current operation. Additional information: '+strMsg, z3dtkInformation);
  z3DCore_OutputDebugString(strMsg, args);
#endif /* DOXYGEN_SKIP */
};

#else


            $ 
HRESULT z3DError (PWideChar str ,
HRESULT hr ,
PChar FileName = nil ,
DWORD Line = FFFFFFFF 
)
#ifdef  SUPPORTS_INLINE
 inline;#endif
 ;{
#ifndef DOXYGEN_SKIP
  Result:= hr;
#endif /* DOXYGEN_SKIP */
};

            $ 
HRESULT z3DErrorMessage (PWideChar str ,
HRESULT hr ,
PChar FileName = nil ,
DWORD Line = FFFFFFFF 
)
{
#ifndef DOXYGEN_SKIP
  Result:= hr;
#endif /* DOXYGEN_SKIP */
};

     
z3DTraceDebug (PWideChar strMsg ,
const *args 
)
{
#ifndef DOXYGEN_SKIP

#endif /* DOXYGEN_SKIP */
};
#endif


#ifdef  DEBUG


   
BOOL z3DFailedTrace (HRESULT Status 
)
{
#ifndef DOXYGEN_SKIP
  Result := Status and HRESULT($80000000) <> 0;
  if Result then
  z3DTrace('Verification failed on operation with status: '+ IntToHex(Status, 12), z3dtkWarning);
#endif /* DOXYGEN_SKIP */
};

#else


   
BOOL z3DFailedTrace (HRESULT Status 
)
{
#ifndef DOXYGEN_SKIP
  Result := Failed(Status);
#endif /* DOXYGEN_SKIP */
};

#endif


      
z3DCore_GetDesktopResolution (LongWord AdapterOrdinal ,
/* out */ LongWord &pWidth ,
/* out */ LongWord &pHeight 
)

/*
var
 pd3dEnum: Iz3DDeviceList;
    pAdapterInfo: Iz3DEnumAdapterInfo;
    devMode: TDeviceModeW;
    strDeviceName: array[0..255] of WideChar;
*/
{
#ifndef DOXYGEN_SKIP

  pd3dEnum := z3DCore_GetDeviceList;
  pAdapterInfo := pd3dEnum.GetAdapterInfo(AdapterOrdinal);
  ZeroMemory(@devMode, SizeOf(devMode));
  devMode.dmSize := SizeOf(devMode);
  MultiByteToWideChar(CP_ACP, 0, pAdapterInfo.AdapterIdentifier.DeviceName, -1, strDeviceName, 256);
  strDeviceName[255] := #0;
  EnumDisplaySettingsW(strDeviceName, ENUM_REGISTRY_SETTINGS, devMode);
  pWidth := devMode.dmPelsWidth;
  pHeight := devMode.dmPelsHeight;
#endif /* DOXYGEN_SKIP */
};

       
IDirect3DDevice9 z3DCore_CreateRefDevice (HWND hWnd ,
Boolean bNullRef = True 
)

/*
var
 pD3D: IDirect3D9;
    Mode: TD3DDisplayMode;
    pp: TD3DPresentParameters;
    devType: TD3DDevType;
*/
{
#ifndef DOXYGEN_SKIP

  Result:= nil;
  pD3D := z3DCreateDirect3D9(D3D_SDK_VERSION);
  if (pD3D = nil) then Exit;
  pD3D.GetAdapterDisplayMode(0, Mode);
  ZeroMemory(@pp, SizeOf(pp));
  pp.BackBufferWidth  := 1;
  pp.BackBufferHeight := 1;
  pp.BackBufferFormat := Mode.Format;
  pp.BackBufferCount  := 1;
  pp.SwapEffect       := D3DSWAPEFFECT_COPY;
  pp.Windowed         := True;
  pp.hDeviceWindow    := hWnd;
  if bNullRef then devType:= D3DDEVTYPE_NULLREF else devType:= D3DDEVTYPE_REF;
  pD3D.CreateDevice(D3DADAPTER_DEFAULT, devType, hWnd,
  D3DCREATE_HARDWARE_VERTEXPROCESSING, @pp, Result);
#endif /* DOXYGEN_SKIP */
};

/* Tz3DTimer */ 

 
Tz3DTimer::Tz3DTimer ()

/*
var
 FTicksPerSec: LARGE_INTEGER;
*/
{
#ifndef DOXYGEN_SKIP

  FTimerStopped    := True;
  FQPFTicksPerSec  := 0;
  FStopTime        := 0;
  FLastElapsedTime := 0;
  FBaseTime        := 0;
  QueryPerformanceFrequency(FTicksPerSec.QuadPart);
  FQPFTicksPerSec := FTicksPerSec.QuadPart;
#endif /* DOXYGEN_SKIP */
};

 
Tz3DTimer::Reset ()

/*
var
 FTime: TLargeInteger;
*/
{
#ifndef DOXYGEN_SKIP

  FTime := GetAdjustedCurrentTime;
  FBaseTime        := FTime;
  FLastElapsedTime := FTime;
  FStopTime        := 0;
  FTimerStopped    := False;
#endif /* DOXYGEN_SKIP */
};

 
Tz3DTimer::Start ()

/*
var
 FTime: TLargeInteger;
*/
{
#ifndef DOXYGEN_SKIP

  QueryPerformanceCounter(FTime);
  if FTimerStopped then Inc(FBaseTime, FTime - FStopTime);
  FStopTime := 0;
  FLastElapsedTime := FTime;
  FTimerStopped := False;
#endif /* DOXYGEN_SKIP */
};

 
Tz3DTimer::Stop ()

/*
var
 qwTime: TLargeInteger;
*/
{
#ifndef DOXYGEN_SKIP

  if not FTimerStopped thenbegin    QueryPerformanceCounter(qwTime);
    FStopTime:= qwTime;
    FLastElapsedTime := qwTime;
    FTimerStopped := True;
 end
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DTimer::GetTimerStopped ()
{
#ifndef DOXYGEN_SKIP
  Result:= FTimerStopped;
#endif /* DOXYGEN_SKIP */
};

 
Tz3DTimer::Advance ()
{
#ifndef DOXYGEN_SKIP
  Inc(FStopTime, FQPFTicksPerSec div 10);
#endif /* DOXYGEN_SKIP */
};

  
Double Tz3DTimer::GetAbsoluteTime ()

/*
var
 qwTime: TLargeInteger;
    FTime: Double;
*/
{
#ifndef DOXYGEN_SKIP

  QueryPerformanceCounter(qwTime);
  FTime := qwTime / FQPFTicksPerSec;
  Result:= fTime;
#endif /* DOXYGEN_SKIP */
};

  
Double Tz3DTimer::GetTime ()

/*
var
 qwTime: TLargeInteger;
    FAppTime: Double;
*/
{
#ifndef DOXYGEN_SKIP

  qwTime:= GetAdjustedCurrentTime;
  FAppTime:= (qwTime - FBaseTime) / FQPFTicksPerSec;
  Result:= fAppTime;
#endif /* DOXYGEN_SKIP */
};

       
Tz3DTimer::GetTimeValues (/* out */ Double &pfTime ,
/* out */ Double &pfAbsoluteTime ,
/* out */ Single &pfElapsedTime 
)

/*
var
 qwTime: TLargeInteger;
    FElapsedTime: Single;
*/
{
#ifndef DOXYGEN_SKIP

  qwTime := GetAdjustedCurrentTime;
  fElapsedTime := (qwTime - FLastElapsedTime) / FQPFTicksPerSec;
  FLastElapsedTime := qwTime;
  if (FElapsedTime < 0) then FElapsedTime:= 0;
  pfAbsoluteTime := qwTime / FQPFTicksPerSec;
  pfTime := (qwTime - FBaseTime) / FQPFTicksPerSec;
  pfElapsedTime := fElapsedTime;
#endif /* DOXYGEN_SKIP */
};

  
Double Tz3DTimer::GetElapsedTime ()

/*
var

  qwTime: TLargeInteger;
  fElapsedTime: Double;
*/
{
#ifndef DOXYGEN_SKIP

  qwTime := GetAdjustedCurrentTime;
  fElapsedTime := (qwTime - FLastElapsedTime) / FQPFTicksPerSec;
  FLastElapsedTime := qwTime;
  if (fElapsedTime < 0.0) then fElapsedTime := 0.0;
  Result:= fElapsedTime;
#endif /* DOXYGEN_SKIP */
};

  
TLargeInteger Tz3DTimer::GetAdjustedCurrentTime ()

/*
var
 qwTime: TLargeInteger;
*/
{
#ifndef DOXYGEN_SKIP

  if FStopTime <> 0 then
  qwTime := FStopTime else QueryPerformanceCounter(qwTime);
  Result:= qwTime;
#endif /* DOXYGEN_SKIP */
};
/*
var
 Gz3DDeviceList: Iz3DDeviceList = nil;

  
Iz3DDeviceList z3DCore_GetDeviceList ()
{
#ifndef DOXYGEN_SKIP
  if (Gz3DDeviceList = nil) then Gz3DDeviceList:= Tz3DDeviceList.Create;
  Result:= Gz3DDeviceList;
#endif /* DOXYGEN_SKIP */
};

   
LongWord z3DCore_GetStencilBits (TD3DFormat fmt 
)
{
#ifndef DOXYGEN_SKIP
  case fmt of

    D3DFMT_D16_LOCKABLE,
    D3DFMT_D16,
    D3DFMT_D32F_LOCKABLE,
    D3DFMT_D32,
    D3DFMT_D24X8: Result:= 0;
    D3DFMT_D15S1: Result:= 1;
    D3DFMT_D24X4S4: Result:= 4;
    D3DFMT_D24S8,
    D3DFMT_D24FS8: Result:= 8;
  else
    Result:= 0;
 end
#endif /* DOXYGEN_SKIP */
};

   
LongWord z3DCore_GetDepthBits (TD3DFormat fmt 
)
{
#ifndef DOXYGEN_SKIP
  case fmt of

    D3DFMT_D32F_LOCKABLE,
    D3DFMT_D32: Result:= 32;
    D3DFMT_D24X8,
    D3DFMT_D24S8,
    D3DFMT_D24X4S4,
    D3DFMT_D24FS8: Result:= 24;
    D3DFMT_D16_LOCKABLE,
    D3DFMT_D16: Result:= 16;
    D3DFMT_D15S1: Result:= 15;
  else
    Result:= 0;
 end
#endif /* DOXYGEN_SKIP */
};

   
LongWord z3DCore_GetAlphaChannelBits (TD3DFormat fmt 
)
{
#ifndef DOXYGEN_SKIP
  case fmt of

    D3DFMT_R8G8B8:        Result:= 0;
    D3DFMT_A8R8G8B8:      Result:= 8;
    D3DFMT_X8R8G8B8:      Result:= 0;
    D3DFMT_R5G6B5:        Result:= 0;
    D3DFMT_X1R5G5B5:      Result:= 0;
    D3DFMT_A1R5G5B5:      Result:= 1;
    D3DFMT_A4R4G4B4:      Result:= 4;
    D3DFMT_R3G3B2:        Result:= 0;
    D3DFMT_A8R3G3B2:      Result:= 8;
    D3DFMT_X4R4G4B4:      Result:= 0;
    D3DFMT_A2B10G10R10:   Result:= 2;
    D3DFMT_A8B8G8R8:      Result:= 8;
    D3DFMT_A2R10G10B10:   Result:= 2;
    D3DFMT_A16B16G16R16:  Result:= 16;
   else Result:= 0;
 end
#endif /* DOXYGEN_SKIP */
};

   
Integer z3DCore_GetColorChannelBits (TD3DFormat fmt 
)
{
#ifndef DOXYGEN_SKIP
  case fmt of

    D3DFMT_R8G8B8:        Result:= 8;
    D3DFMT_A8R8G8B8:      Result:= 8;
    D3DFMT_X8R8G8B8:      Result:= 8;
    D3DFMT_R5G6B5:        Result:= 5;
    D3DFMT_X1R5G5B5:      Result:= 5;
    D3DFMT_A1R5G5B5:      Result:= 5;
    D3DFMT_A4R4G4B4:      Result:= 4;
    D3DFMT_R3G3B2:        Result:= 2;
    D3DFMT_A8R3G3B2:      Result:= 2;
    D3DFMT_X4R4G4B4:      Result:= 4;
    D3DFMT_A2B10G10R10:   Result:= 10;
    D3DFMT_A8B8G8R8:      Result:= 8;
    D3DFMT_A2R10G10B10:   Result:= 10;
    D3DFMT_A16B16G16R16:  Result:= 16;
    else Result:= 0;
 end
#endif /* DOXYGEN_SKIP */
};

             
QSort_int (Pointer base ,
Integer width ,
QSortCB compare ,
Integer Left ,
Integer Right ,
Pointer TempBuffer ,
Pointer TempBuffer2 
)

/*
var
 Lo, Hi: Integer;
    P: Pointer;
*/
{
#ifndef DOXYGEN_SKIP

  Lo := Left;
  Hi := Right;
  P := Pointer(Integer(base) + ((Lo + Hi) div 2)*width);
  Move(P^, TempBuffer2^, width);
  repeat
    while compare(Pointer(Integer(base) + Lo*width), TempBuffer2) < 0 do Inc(Lo);
    while compare(Pointer(Integer(base) + Hi*width), TempBuffer2) > 0 do Dec(Hi);
    if Lo <= Hi thenbegin      Move(Pointer(Integer(base) + Lo*width)^, TempBuffer^, width);
      Move(Pointer(Integer(base) + Hi*width)^, Pointer(Integer(base) + Lo*width)^, width);
      Move(TempBuffer^,  Pointer(Integer(base) + Hi*width)^, width);
      Inc(Lo);
      Dec(Hi);
   end
  until Lo > Hi;
  if Hi > Left  then qsort_int(base, width, compare, Left, Hi,  TempBuffer, TempBuffer2);
  if Lo < Right then qsort_int(base, width, compare, Lo, Right, TempBuffer, TempBuffer2);
#endif /* DOXYGEN_SKIP */
};

        
QSort (Pointer base ,
Size_t num ,
Size_t width ,
QSortCB compare 
)

/*
var
 p, p1: Pointer;
*/
{
#ifndef DOXYGEN_SKIP

  GetMem(p, width);
  GetMem(p1, width);
  try
    QSort_int(base, width, compare, 0, num - 1, p, p1);
  finally
    FreeMem(p1, width);
    FreeMem(p, width);
 end
#endif /* DOXYGEN_SKIP */
};

 
z3DCore_LaunchAppStart ()
{
#ifndef DOXYGEN_SKIP
  TfrmAppStart.Launch;
#endif /* DOXYGEN_SKIP */
};

/* Tz3DDeviceList */ 

     
Tz3DDeviceList::Tz3DDeviceList (const Iz3DBase AOwner = nil 
)
{
#ifndef DOXYGEN_SKIP
  inherited;
  FD3D:= nil;
  FAcceptDeviceFunc := nil;
  FAcceptDeviceFuncUserContext := nil;
  FRequirePostPixelShaderBlending := True;
  FMinWidth := 640;
  FMinHeight := 480;
  FMaxWidth := $FFFFFFFF;
  FMaxHeight := $FFFFFFFF;
  FRefreshMin := 0;
  FRefreshMax := $FFFFFFFF;
  FMultisampleQualityMax := $FFFF;
  ResetPossibleDepthStencilFormats;
  ResetPossibleMultisampleTypes;
  ResetPossiblePresentIntervals;
  SetPossibleVertexProcessingList(True, True, True, False);
#endif /* DOXYGEN_SKIP */
};

 
Tz3DDeviceList::~Tz3DDeviceList ()
{
#ifndef DOXYGEN_SKIP
  ClearAdapterInfoList;
  inherited;
#endif /* DOXYGEN_SKIP */
};

     
Integer SortModesCallback (const Pointer arg1 ,
const Pointer arg2 
)
 ;

               
HRESULT Tz3DDeviceList::Enumerate (IDirect3D9 pD3D = nil ,
Tz3DCallback_AcceptDevice AcceptDeviceFunc = nil ,
Pointer pAcceptDeviceFuncUserContext = nil 
)

/*
//const

  allowedAdapterFormatArray: array[0..3] of TD3DFormat  = (
    D3DFMT_X8R8G8B8,
    D3DFMT_X1R5G5B5,
    D3DFMT_R5G6B5,
    D3DFMT_A2R10G10B10
  );
var
  adapterFormatList: TD3DFormatArray;
  numAdapters: LongWord;
  adapterOrdinal: Integer;
  pAdapterInfo: Iz3DEnumAdapterInfo;
  iFormatList: Integer;
  allowedAdapterFormat: TD3DFormat;
  numAdapterModes: Integer;
  mode: Integer;
  displayMode: TD3DDisplayMode;
  l: Integer;
  bUniqueDesc: Boolean;
  i, j: Integer;
  pAdapterInfo1: Iz3DEnumAdapterInfo;
  pAdapterInfo2: Iz3DEnumAdapterInfo;
  sz: array[0..99] of WideChar;
*/
{
#ifndef DOXYGEN_SKIP

  try
    if (pD3D = nil) thenbegin      pD3D := z3DCore_GetD3DObject;
      if (pD3D = nil) thenbegin        Result:= z3DERR_NODIRECT3D;
        Exit;
     end
   end
    FD3D := pD3D;
    FAcceptDeviceFunc := AcceptDeviceFunc;
    FAcceptDeviceFuncUserContext := pAcceptDeviceFuncUserContext;
    ClearAdapterInfoList;
    numAdapters := pD3D.GetAdapterCount;
    for adapterOrdinal := 0 to numAdapters - 1 dobegin      pAdapterInfo:= Tz3DEnumAdapterInfo.Create;
      pAdapterInfo.AdapterOrdinal:= AdapterOrdinal;
      pD3D.GetAdapterIdentifier(adapterOrdinal, 0, pAdapterInfo.AdapterIdentifier^);
      adapterFormatList:= nil;
      for iFormatList := 0 to High(allowedAdapterFormatArray) dobegin        allowedAdapterFormat := allowedAdapterFormatArray[iFormatList];
        numAdapterModes := pD3D.GetAdapterModeCount(adapterOrdinal, allowedAdapterFormat);
        for mode := 0 to numAdapterModes - 1 dobegin          pD3D.EnumAdapterModes(adapterOrdinal, allowedAdapterFormat, mode, displayMode);
          if (displayMode.Width < FMinWidth) or
             (displayMode.Height < FMinHeight) or
             (displayMode.Width > FMaxWidth) or
             (displayMode.Height > FMaxHeight) or
             (displayMode.RefreshRate < FRefreshMin) or
             (displayMode.RefreshRate > FRefreshMax)
          then Continue;
          l:= Length(pAdapterInfo.displayModeList^);
          SetLength(pAdapterInfo.DisplayModeList^, l+1);
          pAdapterInfo.displayModeList^[l]:= displayMode;
          if not DynArrayContains(adapterFormatList, displayMode.Format, SizeOf(displayMode.Format)) thenbegin            l:= Length(adapterFormatList);
            SetLength(adapterFormatList, l+1);
            adapterFormatList[l]:= displayMode.Format;
         end
       end
     end
      pD3D.GetAdapterDisplayMode(adapterOrdinal, displayMode);
      if not DynArrayContains(adapterFormatList, displayMode.Format, SizeOf(displayMode.Format)) thenbegin        l:= Length(adapterFormatList);
        SetLength(adapterFormatList, l+1);
        adapterFormatList[l]:= displayMode.Format;
     end
      QSort(Pointer(pAdapterInfo.displayModeList^), Length(pAdapterInfo.displayModeList^),
      SizeOf(TD3DDisplayMode), SortModesCallback);
      if FAILED(EnumerateDevices(pAdapterInfo, adapterFormatList)) thenbegin        pAdapterInfo:= nil;
        Continue;
     end
      if (Length(pAdapterInfo.deviceInfoList^) > 0) thenbegin        l:= Length(FAdapterInfoList);
        SetLength(FAdapterInfoList, l+1);
        FAdapterInfoList[l]:= pAdapterInfo;
     endelse
      pAdapterInfo:= nil 
   end
    bUniqueDesc := true;
    for i:= 0 to Length(FAdapterInfoList) - 1 dobegin      pAdapterInfo1 := FAdapterInfoList[i];
      for j:= i+1 to Length(FAdapterInfoList) - 1 dobegin        pAdapterInfo2 := FAdapterInfoList[j];
        if (AnsiCompareText(pAdapterInfo1.AdapterIdentifier.Description,
        pAdapterInfo2.AdapterIdentifier.Description) = 0) thenbegin          bUniqueDesc := False;
          Break;
       end
     end
      if not bUniqueDesc then Break;
   end
    for i:= 0 to Length(FAdapterInfoList) - 1 dobegin      pAdapterInfo := FAdapterInfoList[I];
      MultiByteToWideChar(CP_ACP, 0, pAdapterInfo.AdapterIdentifier.Description, -1,
      pAdapterInfo.UniqueDescription^, 100);
      pAdapterInfo.UniqueDescription^[100] := #0;
      if not bUniqueDesc thenbegin        StringCchFormat(sz, 100, ' (#%d)', [pAdapterInfo.AdapterOrdinal]);
        StringCchCat(pAdapterInfo.UniqueDescription^, 256, sz);
     end
   end
    Result:= S_OK;
  except
    on EOutOfMemory dobegin      Result:= E_OUTOFMEMORY;
      Exit;
   end
 end
#endif /* DOXYGEN_SKIP */
};

      
HRESULT Tz3DDeviceList::EnumerateDevices (Iz3DEnumAdapterInfo pAdapterInfo ,
TD3DFormatArray pAdapterFormatList 
)

/*
//const

  devTypeArray: array[0..2] of TD3DDevType = (
    D3DDEVTYPE_HAL,
    D3DDEVTYPE_SW,
    D3DDEVTYPE_REF
  );
var
  iDeviceType: Integer;
  pDeviceInfo: Tz3DEnumDeviceInfo;
  l: Integer;
  Mode: TD3DDisplayMode;
  pp: TD3DPresentParameters;
  pDevice: IDirect3DDevice9;
*/
{
#ifndef DOXYGEN_SKIP

  for iDeviceType := 0 to High(devTypeArray) dobegin    try
      pDeviceInfo := Tz3DEnumDeviceInfo.Create;
    except
      Result:= E_OUTOFMEMORY;
      Exit;
   end
    pDeviceInfo.DeviceType := devTypeArray[iDeviceType];
    Result:= FD3D.GetDeviceCaps(pAdapterInfo.AdapterOrdinal, pDeviceInfo.DeviceType,
                                  pDeviceInfo.FCaps);
    if FAILED(Result) thenbegin      pDeviceInfo:= nil;
      Continue;
   end
    FD3D.GetAdapterDisplayMode(0, Mode);
    ZeroMemory(@pp, SizeOf(pp));
    pp.BackBufferWidth  := 1;
    pp.BackBufferHeight := 1;
    pp.BackBufferFormat := Mode.Format;
    pp.BackBufferCount  := 1;
    pp.SwapEffect       := D3DSWAPEFFECT_COPY;
    pp.Windowed         := True;
    pp.hDeviceWindow    := z3DCore_GetHWNDFocus;
    Result := FD3D.CreateDevice(pAdapterInfo.AdapterOrdinal, pDeviceInfo.DeviceType, z3DCore_GetHWNDFocus,
                              D3DCREATE_HARDWARE_VERTEXPROCESSING, @pp, pDevice);
    if FAILED(Result) thenbegin      if (Result = D3DERR_NOTAVAILABLE) thenbegin        pDeviceInfo:= nil;
        Continue;
     end
   end
    pDevice := nil;
    Result := EnumerateDeviceCombos(pAdapterInfo, pDeviceInfo, pAdapterFormatList);
    if FAILED(Result) thenbegin      pDeviceInfo:= nil;
      Continue;
   end
    if (Length(pDeviceInfo.DeviceSettingsComboList^) > 0) thenbegin      l:= Length(pAdapterInfo.DeviceInfoList^);
      SetLength(pAdapterInfo.DeviceInfoList^, l+1);
      pAdapterInfo.deviceInfoList^[l]:= pDeviceInfo;
   endelse
    pDeviceInfo:= nil 
 end
  Result:= S_OK;
#endif /* DOXYGEN_SKIP */
};

        
HRESULT Tz3DDeviceList::EnumerateDeviceCombos (Iz3DEnumAdapterInfo pAdapterInfo ,
Iz3DEnumDeviceInfo pDeviceInfo ,
TD3DFormatArray pAdapterFormatList 
)

/*
//const

  backBufferFormatArray: array[0..5] of TD3DFormat = (
    D3DFMT_A8R8G8B8,
    D3DFMT_X8R8G8B8,
    D3DFMT_A2R10G10B10,
    D3DFMT_R5G6B5,
    D3DFMT_A1R5G5B5,
    D3DFMT_X1R5G5B5
  );
var
  iFormat: Integer;
  adapterFormat: TD3DFormat;
  iBackBufferFormat: Integer;
  backBufferFormat: TD3DFormat;
  nWindowed: Integer;
  pDeviceCombo: PD3DDeviceSettingsCombinations;
  l: Integer;
*/
{
#ifndef DOXYGEN_SKIP

  try
    for iFormat:= 0 to Length(pAdapterFormatList) - 1 dobegin      adapterFormat := pAdapterFormatList[iFormat];
      for iBackBufferFormat := 0 to High(backBufferFormatArray) dobegin        backBufferFormat := backBufferFormatArray[iBackBufferFormat];
        for nWindowed := 0 to 1 dobegin          if (nWindowed = 0) and (Length(pAdapterInfo.DisplayModeList^) = 0)
          then Continue;
          if FAILED(FD3D.CheckDeviceType(pAdapterInfo.AdapterOrdinal, pDeviceInfo.DeviceType,
                                           adapterFormat, backBufferFormat, nWindowed <> 0))
          then Continue;
          if FRequirePostPixelShaderBlending thenbegin            if FAILED(FD3D.CheckDeviceFormat(pAdapterInfo.AdapterOrdinal, pDeviceInfo.DeviceType,
                                               adapterFormat, D3DUSAGE_QUERY_POSTPIXELSHADER_BLENDING,
                                               D3DRTYPE_TEXTURE, backBufferFormat))
            then Continue;
         end
          if (@FAcceptDeviceFunc <> nil) thenbegin            if (not FAcceptDeviceFunc(pDeviceInfo.Caps, adapterFormat, backBufferFormat, nWindowed <> 0, FAcceptDeviceFuncUserContext))
            then Continue;
         end
          New(pDeviceCombo);
          pDeviceCombo.AdapterOrdinal := pAdapterInfo.AdapterOrdinal;
          pDeviceCombo.DeviceType := pDeviceInfo.DeviceType;
          pDeviceCombo.AdapterFormat := adapterFormat;
          pDeviceCombo.BackBufferFormat := backBufferFormat;
          pDeviceCombo.Windowed := (nWindowed <> 0);
          BuildDepthStencilFormatList(pDeviceCombo);
          BuildMultiSampleTypeList(pDeviceCombo);
          if Length(pDeviceCombo.multiSampleTypeList) = 0 thenbegin            Dispose(pDeviceCombo);
            Continue;
         end
          BuildDSMSConflictList(pDeviceCombo);
          BuildPresentIntervalList(pDeviceInfo, pDeviceCombo);
          pDeviceCombo.AdapterInfo := pAdapterInfo;
          pDeviceCombo.DeviceInfo := pDeviceInfo;
          l:= Length(pDeviceInfo.DeviceSettingsComboList^);
          SetLength(pDeviceInfo.DeviceSettingsComboList^, l+1);
          pDeviceInfo.DeviceSettingsComboList^[l]:= pDeviceCombo;
       end
     end
   end
    Result:= S_OK;
  except
    on EOutOfMemory dobegin      Result:= E_OUTOFMEMORY;
      Exit;
   end
 end
#endif /* DOXYGEN_SKIP */
};

  
Tz3DDeviceList::BuildDepthStencilFormatList (PD3DDeviceSettingsCombinations pDeviceCombo 
)

/*
var

  depthStencilFmt: TD3DFormat;
  idsf, l: Integer;
*/
{
#ifndef DOXYGEN_SKIP

  for idsf := 0 to Length(FDepthStecilPossibleList) - 1 dobegin    depthStencilFmt := FDepthStecilPossibleList[idsf];
    if SUCCEEDED(FD3D.CheckDeviceFormat(pDeviceCombo.AdapterOrdinal,
         pDeviceCombo.DeviceType, pDeviceCombo.AdapterFormat,
         D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, depthStencilFmt)) thenbegin      if SUCCEEDED(FD3D.CheckDepthStencilMatch(pDeviceCombo.AdapterOrdinal,
           pDeviceCombo.DeviceType, pDeviceCombo.AdapterFormat,
           pDeviceCombo.BackBufferFormat, depthStencilFmt)) thenbegin        l:= Length(pDeviceCombo.depthStencilFormatList);
        SetLength(pDeviceCombo.depthStencilFormatList, l+1);
        pDeviceCombo.depthStencilFormatList[l]:= depthStencilFmt;
     end
   end
 end
#endif /* DOXYGEN_SKIP */
};

  
Tz3DDeviceList::BuildMultiSampleTypeList (PD3DDeviceSettingsCombinations pDeviceCombo 
)

/*
var

  msType: TD3DMultiSampleType;
  msQuality: DWORD;
  imst, l: Integer;
*/
{
#ifndef DOXYGEN_SKIP

  for imst := 0 to Length(FMultiSampleTypeList) - 1 dobegin    msType := FMultiSampleTypeList[imst];
    if SUCCEEDED(FD3D.CheckDeviceMultiSampleType(pDeviceCombo.AdapterOrdinal,
         pDeviceCombo.DeviceType, pDeviceCombo.BackBufferFormat,
         pDeviceCombo.Windowed, msType, @msQuality)) thenbegin      l:= Length(pDeviceCombo.multiSampleTypeList);
      SetLength(pDeviceCombo.multiSampleTypeList, l+1);
      pDeviceCombo.multiSampleTypeList[l]:= msType;
      if (msQuality > FMultisampleQualityMax+1) then msQuality := FMultisampleQualityMax+1;
      l:= Length(pDeviceCombo.multiSampleQualityList);
      SetLength(pDeviceCombo.multiSampleQualityList, l+1);
      pDeviceCombo.multiSampleQualityList[l]:= msQuality;
   end
 end
#endif /* DOXYGEN_SKIP */
};

  
Tz3DDeviceList::BuildDSMSConflictList (PD3DDeviceSettingsCombinations pDeviceCombo 
)

/*
var

  DSMSConflict: Tz3DEnumDSMSConflict;
  iDS, iMS, l: Integer;
  dsFmt: TD3DFormat;
  msType: TD3DMultiSampleType;
*/
{
#ifndef DOXYGEN_SKIP

  for iDS:=0 to Length(pDeviceCombo.depthStencilFormatList) - 1 dobegin    dsFmt := pDeviceCombo.depthStencilFormatList[iDS];
    for iMS:= 0 to Length(pDeviceCombo.multiSampleTypeList) - 1 dobegin      msType := pDeviceCombo.multiSampleTypeList[iMS];
      if FAILED(FD3D.CheckDeviceMultiSampleType(pDeviceCombo.AdapterOrdinal, pDeviceCombo.DeviceType,
      dsFmt, pDeviceCombo.Windowed, msType, nil)) thenbegin        DSMSConflict.DSFormat := dsFmt;
        DSMSConflict.MSType := msType;
        l:= Length(pDeviceCombo.DSMSConflictList);
        SetLength(pDeviceCombo.DSMSConflictList, l+1);
        pDeviceCombo.DSMSConflictList[l]:= DSMSConflict;
     end
   end
 end
#endif /* DOXYGEN_SKIP */
};

     
Tz3DDeviceList::BuildPresentIntervalList (Iz3DEnumDeviceInfo pDeviceInfo ,
PD3DDeviceSettingsCombinations pDeviceCombo 
)

/*
var

  pi: LongWord;
  ipi, l: Integer;
*/
{
#ifndef DOXYGEN_SKIP

  for ipi := 0 to Length(FPresentIntervalList) - 1 dobegin    pi := FPresentIntervalList[ipi];
    if pDeviceCombo.Windowed thenbegin      if (pi = D3DPRESENT_INTERVAL_TWO) or
      (pi = D3DPRESENT_INTERVAL_THREE) or
      (pi = D3DPRESENT_INTERVAL_FOUR) then Continue;
   end
    if (pi = D3DPRESENT_INTERVAL_DEFAULT) or
    (pDeviceInfo.Caps.PresentationIntervals and pi <> 0) thenbegin      l:= Length(pDeviceCombo.presentIntervalList);
      SetLength(pDeviceCombo.presentIntervalList, l+1);
      pDeviceCombo.presentIntervalList[l]:= pi;
   end
 end
#endif /* DOXYGEN_SKIP */
};

 
Tz3DDeviceList::ClearAdapterInfoList ()

/*
var

  i: Integer;
*/
{
#ifndef DOXYGEN_SKIP

  for i:= 0 to Length(FAdapterInfoList) - 1 do
    FAdapterInfoList[i]:= nil;
  FAdapterInfoList:= nil;
#endif /* DOXYGEN_SKIP */
};

  
Tz3DEnumAdapterInfoArray Tz3DDeviceList::GetAdapterInfoList ()
{
#ifndef DOXYGEN_SKIP
  Result:= FAdapterInfoList;
#endif /* DOXYGEN_SKIP */
};

   
Iz3DEnumAdapterInfo Tz3DDeviceList::GetAdapterInfo (LongWord AdapterOrdinal 
)

/*
var

  iAdapter: Integer;
*/
{
#ifndef DOXYGEN_SKIP

  for iAdapter:= 0 to Length(FAdapterInfoList) - 1 dobegin    if (FAdapterInfoList[iAdapter].AdapterOrdinal = AdapterOrdinal) thenbegin      Result:= FAdapterInfoList[iAdapter];
      Exit;
   end
 end
  Result:= nil;
#endif /* DOXYGEN_SKIP */
};

      
Iz3DEnumDeviceInfo Tz3DDeviceList::GetDeviceInfo (LongWord AdapterOrdinal ,
TD3DDevType DeviceType 
)

/*
var

  pAdapterInfo: Iz3DEnumAdapterInfo;
  iDeviceInfo: Integer;
*/
{
#ifndef DOXYGEN_SKIP

  pAdapterInfo := GetAdapterInfo(AdapterOrdinal);
  if (pAdapterInfo <> nil) thenbegin    for iDeviceInfo:= 0 to Length(pAdapterInfo.DeviceInfoList^) - 1 dobegin      if (pAdapterInfo.DeviceInfoList^[iDeviceInfo].DeviceType = DeviceType) thenbegin        Result:= pAdapterInfo.DeviceInfoList^[iDeviceInfo];
        Exit;
     end
   end
 end
  Result:= nil;
#endif /* DOXYGEN_SKIP */
};

    
PD3DDeviceSettingsCombinations Tz3DDeviceList::GetDeviceSettingsCombo (const Tz3DDeviceSettings pDeviceSettings 
)
{
#ifndef DOXYGEN_SKIP
  with pDeviceSettings do
  Result:= GetDeviceSettingsCombo(AdapterOrdinal, DeviceType, AdapterFormat,
  PresentParams.BackBufferFormat, PresentParams.Windowed);
#endif /* DOXYGEN_SKIP */
};

            
PD3DDeviceSettingsCombinations Tz3DDeviceList::GetDeviceSettingsCombo (LongWord AdapterOrdinal ,
TD3DDevType DeviceType ,
TD3DFormat AdapterFormat ,
TD3DFormat BackBufferFormat ,
Boolean Windowed 
)

/*
var

  pDeviceInfo: Iz3DEnumDeviceInfo;
  iDeviceCombo: Integer;
  pDeviceSettingsCombo: PD3DDeviceSettingsCombinations;
*/
{
#ifndef DOXYGEN_SKIP

  pDeviceInfo := GetDeviceInfo(AdapterOrdinal, DeviceType);
  if (pDeviceInfo <> nil) thenbegin    for iDeviceCombo:= 0 to Length(pDeviceInfo.DeviceSettingsComboList^) - 1 dobegin      pDeviceSettingsCombo := pDeviceInfo.DeviceSettingsComboList^[iDeviceCombo];
      if (pDeviceSettingsCombo.AdapterFormat = AdapterFormat) and
         (pDeviceSettingsCombo.BackBufferFormat = BackBufferFormat) and
         (pDeviceSettingsCombo.Windowed = Windowed) thenbegin        Result:= pDeviceSettingsCombo;
        Exit;
     end
   end
 end
  Result:= nil;
#endif /* DOXYGEN_SKIP */
};

 
Tz3DDeviceList::CleanupDirect3DInterfaces ()
{
#ifndef DOXYGEN_SKIP
  FD3D:= nil;
#endif /* DOXYGEN_SKIP */
};

     
Integer SortModesCallback (const Pointer arg1 ,
const Pointer arg2 
)

/*
var

  pdm1, pdm2: PD3DDisplayMode;
*/
{
#ifndef DOXYGEN_SKIP

  pdm1 := PD3DDisplayMode(arg1);
  pdm2 := PD3DDisplayMode(arg2);
  if (pdm1.Width > pdm2.Width) then Result:= 1
  else if (pdm1.Width < pdm2.Width) then Result:= -1
  else if (pdm1.Height > pdm2.Height) then Result:= 1
  else if (pdm1.Height < pdm2.Height) then Result:= -1
  else if (pdm1.Format > pdm2.Format) then Result:= 1
  else if (pdm1.Format < pdm2.Format) then Result:= -1
  else if (pdm1.RefreshRate > pdm2.RefreshRate) then Result:= 1
  else if (pdm1.RefreshRate < pdm2.RefreshRate) then Result:= -1
  else Result:= 0;
#endif /* DOXYGEN_SKIP */
};

/* Tz3DEnumAdapterInfo */ 

 
Tz3DEnumAdapterInfo::~Tz3DEnumAdapterInfo ()

/*
var
 I: Integer;
*/
{
#ifndef DOXYGEN_SKIP

  for I:= 0 to Length(FDeviceInfoList)-1 do FDeviceInfoList[I]:= nil;
  FDeviceInfoList:= nil;
  inherited;
#endif /* DOXYGEN_SKIP */
};

  
PD3DAdapterIdentifier9 Tz3DEnumAdapterInfo::GetAdapterIdentifier ()
{
#ifndef DOXYGEN_SKIP
  Result:= @FAdapterIdentifier;
#endif /* DOXYGEN_SKIP */
};

  
LongWord Tz3DEnumAdapterInfo::GetAdapterOrdinal ()
{
#ifndef DOXYGEN_SKIP
  Result:= FAdapterOrdinal;
#endif /* DOXYGEN_SKIP */
};

  
Pz3DDeviceInfoList Tz3DEnumAdapterInfo::GetDeviceInfoList ()
{
#ifndef DOXYGEN_SKIP
  Result:= @FDeviceInfoList;
#endif /* DOXYGEN_SKIP */
};

  
PD3DDisplayModeArray Tz3DEnumAdapterInfo::GetDisplayModeList ()
{
#ifndef DOXYGEN_SKIP
  Result:= @FDisplayModeList;
#endif /* DOXYGEN_SKIP */
};

  
PDescArray Tz3DEnumAdapterInfo::GetUniqueDescription ()
{
#ifndef DOXYGEN_SKIP
  Result:= @FUniqueDescription;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DEnumAdapterInfo::SetAdapterIdentifier (const PD3DAdapterIdentifier9 Value 
)
{
#ifndef DOXYGEN_SKIP
  FAdapterIdentifier:= Value^;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DEnumAdapterInfo::SetAdapterOrdinal (const LongWord Value 
)
{
#ifndef DOXYGEN_SKIP
  FAdapterOrdinal:= Value;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DEnumAdapterInfo::SetDeviceInfoList (const Pz3DDeviceInfoList Value 
)
{
#ifndef DOXYGEN_SKIP
  FDeviceInfoList:= Value^;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DEnumAdapterInfo::SetDisplayModeList (const PD3DDisplayModeArray Value 
)
{
#ifndef DOXYGEN_SKIP
  FDisplayModeList:= Value^;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DEnumAdapterInfo::SetUniqueDescription (const PDescArray Value 
)
{
#ifndef DOXYGEN_SKIP
  FUniqueDescription:= Value^;
#endif /* DOXYGEN_SKIP */
};

/* Tz3DEnumDeviceInfo */ 

 
Tz3DEnumDeviceInfo::~Tz3DEnumDeviceInfo ()

/*
var

  i: Integer;
*/
{
#ifndef DOXYGEN_SKIP

  for i:= 0 to Length(FDeviceSettingsComboList) - 1 do FDeviceSettingsComboList[i]:= nil;
  FDeviceSettingsComboList:= nil;
  inherited;
#endif /* DOXYGEN_SKIP */
};

  
TD3DCaps9 Tz3DEnumDeviceInfo::GetCaps ()
{
#ifndef DOXYGEN_SKIP
  Result:= FCaps;
#endif /* DOXYGEN_SKIP */
};

  
LongWord Tz3DEnumDeviceInfo::GetAdapterOrdinal ()
{
#ifndef DOXYGEN_SKIP
  Result:= FAdapterOrdinal;
#endif /* DOXYGEN_SKIP */
};

  
Pz3DDeviceSettingsComboList Tz3DEnumDeviceInfo::GetDeviceSettingsComboList ()
{
#ifndef DOXYGEN_SKIP
  Result:= @FDeviceSettingsComboList;
#endif /* DOXYGEN_SKIP */
};

  
TD3DDevType Tz3DEnumDeviceInfo::GetDeviceType ()
{
#ifndef DOXYGEN_SKIP
  Result:= FDeviceType;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DEnumDeviceInfo::SetAdapterOrdinal (const LongWord Value 
)
{
#ifndef DOXYGEN_SKIP
  FAdapterOrdinal:= Value;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DEnumDeviceInfo::SetCaps (const TD3DCaps9 Value 
)
{
#ifndef DOXYGEN_SKIP
  FCaps:= Value;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DEnumDeviceInfo::SetDeviceSettingsComboList (const Pz3DDeviceSettingsComboList Value 
)
{
#ifndef DOXYGEN_SKIP
  FDeviceSettingsComboList:= Value^;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DEnumDeviceInfo::SetDeviceType (const TD3DDevType Value 
)
{
#ifndef DOXYGEN_SKIP
  FDeviceType:= Value;
#endif /* DOXYGEN_SKIP */
};

/* Tz3DDeviceList */ 

  
TD3DFormatArray Tz3DDeviceList::GetPossibleDepthStencilFormats ()
{
#ifndef DOXYGEN_SKIP
  Result:= FDepthStecilPossibleList;
#endif /* DOXYGEN_SKIP */
};

  
TD3DMultiSampleTypeArray Tz3DDeviceList::GetPossibleMultisampleTypes ()
{
#ifndef DOXYGEN_SKIP
  Result:= FMultiSampleTypeList;
#endif /* DOXYGEN_SKIP */
};

  
TLongWordArray Tz3DDeviceList::GetPossiblePresentIntervals ()
{
#ifndef DOXYGEN_SKIP
  Result:= FPresentIntervalList;
#endif /* DOXYGEN_SKIP */
};

  
Tz3DDeviceList::SetPossibleDepthStencilFormats (TD3DFormatArray a 
)
{
#ifndef DOXYGEN_SKIP
  FDepthStecilPossibleList:= a;
#endif /* DOXYGEN_SKIP */
};

  
Tz3DDeviceList::SetPossibleMultisampleTypes (TD3DMultiSampleTypeArray a 
)
{
#ifndef DOXYGEN_SKIP
  FMultiSampleTypeList:= a;
#endif /* DOXYGEN_SKIP */
};

  
Tz3DDeviceList::SetPossiblePresentIntervals (TLongWordArray a 
)
{
#ifndef DOXYGEN_SKIP
  FPresentIntervalList:= a;
#endif /* DOXYGEN_SKIP */
};

 
Tz3DDeviceList::ResetPossibleDepthStencilFormats ()
{
#ifndef DOXYGEN_SKIP
  FDepthStecilPossibleList:= nil;
  SetLength(FDepthStecilPossibleList, 6);
  FDepthStecilPossibleList[0]:= D3DFMT_D16;
  FDepthStecilPossibleList[1]:= D3DFMT_D15S1;
  FDepthStecilPossibleList[2]:= D3DFMT_D24X8;
  FDepthStecilPossibleList[3]:= D3DFMT_D24S8;
  FDepthStecilPossibleList[4]:= D3DFMT_D24X4S4;
  FDepthStecilPossibleList[5]:= D3DFMT_D32;
#endif /* DOXYGEN_SKIP */
};

 
Tz3DDeviceList::ResetPossibleMultisampleTypes ()
{
#ifndef DOXYGEN_SKIP
  FMultiSampleTypeList:= nil;
  SetLength(FMultiSampleTypeList, 17);
  FMultiSampleTypeList[00]:= D3DMULTISAMPLE_NONE;
  FMultiSampleTypeList[01]:= D3DMULTISAMPLE_NONMASKABLE;
  FMultiSampleTypeList[02]:= D3DMULTISAMPLE_2_SAMPLES;
  FMultiSampleTypeList[03]:= D3DMULTISAMPLE_3_SAMPLES;
  FMultiSampleTypeList[04]:= D3DMULTISAMPLE_4_SAMPLES;
  FMultiSampleTypeList[05]:= D3DMULTISAMPLE_5_SAMPLES;
  FMultiSampleTypeList[06]:= D3DMULTISAMPLE_6_SAMPLES;
  FMultiSampleTypeList[07]:= D3DMULTISAMPLE_7_SAMPLES;
  FMultiSampleTypeList[08]:= D3DMULTISAMPLE_8_SAMPLES;
  FMultiSampleTypeList[09]:= D3DMULTISAMPLE_9_SAMPLES;
  FMultiSampleTypeList[10]:= D3DMULTISAMPLE_10_SAMPLES;
  FMultiSampleTypeList[11]:= D3DMULTISAMPLE_11_SAMPLES;
  FMultiSampleTypeList[12]:= D3DMULTISAMPLE_12_SAMPLES;
  FMultiSampleTypeList[13]:= D3DMULTISAMPLE_13_SAMPLES;
  FMultiSampleTypeList[14]:= D3DMULTISAMPLE_14_SAMPLES;
  FMultiSampleTypeList[15]:= D3DMULTISAMPLE_15_SAMPLES;
  FMultiSampleTypeList[16]:= D3DMULTISAMPLE_16_SAMPLES;
#endif /* DOXYGEN_SKIP */
};

 
Tz3DDeviceList::ResetPossiblePresentIntervals ()
{
#ifndef DOXYGEN_SKIP
  FPresentIntervalList:= nil;
  SetLength(FPresentIntervalList, 6);
  FPresentIntervalList[0]:= D3DPRESENT_INTERVAL_IMMEDIATE;
  FPresentIntervalList[1]:= D3DPRESENT_INTERVAL_DEFAULT;
  FPresentIntervalList[2]:= D3DPRESENT_INTERVAL_ONE;
  FPresentIntervalList[3]:= D3DPRESENT_INTERVAL_TWO;
  FPresentIntervalList[4]:= D3DPRESENT_INTERVAL_THREE;
  FPresentIntervalList[5]:= D3DPRESENT_INTERVAL_FOUR;
#endif /* DOXYGEN_SKIP */
};

       
Tz3DDeviceList::GetPossibleVertexProcessingList (/* out */ Boolean &pbSoftwareVP ,
/* out */ Boolean &pbHardwareVP ,
/* out */ Boolean &pbPureHarewareVP ,
/* out */ Boolean &pbMixedVP 
)
{
#ifndef DOXYGEN_SKIP
  pbSoftwareVP := FSoftwareVP;
  pbHardwareVP := FHardwareVP;
  pbPureHarewareVP := FPureHarewareVP;
  pbMixedVP := FMixedVP;
#endif /* DOXYGEN_SKIP */
};

      
Tz3DDeviceList::SetPossibleVertexProcessingList (Boolean bSoftwareVP ,
Boolean bHardwareVP ,
Boolean bPureHarewareVP ,
Boolean bMixedVP 
)
{
#ifndef DOXYGEN_SKIP
  FSoftwareVP := bSoftwareVP;
  FHardwareVP := bHardwareVP;
  FPureHarewareVP := bPureHarewareVP;
  FMixedVP := bMixedVP;
#endif /* DOXYGEN_SKIP */
};

      
Tz3DDeviceList::SetResolutionMinMax (LongWord nMinWidth ,
LongWord nMinHeight ,
LongWord nMaxWidth ,
LongWord nMaxHeight 
)
{
#ifndef DOXYGEN_SKIP
  FMinWidth := nMinWidth;
  FMinHeight := nMinHeight;
  FMaxWidth := nMaxWidth;
  FMaxHeight := nMaxHeight;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DDeviceList::SetRefreshMinMax (LongWord nMin ,
LongWord nMax 
)
{
#ifndef DOXYGEN_SKIP
  FRefreshMin := nMin;
  FRefreshMax := nMax;
#endif /* DOXYGEN_SKIP */
};

  
Tz3DDeviceList::SetMultisampleQualityMax (LongWord nMax 
)
{
#ifndef DOXYGEN_SKIP
  if (nMax > $FFFF) then nMax := $FFFF;
  FMultisampleQualityMax := nMax;
#endif /* DOXYGEN_SKIP */
};

  
LongWord Tz3DDeviceList::GetMultisampleQualityMax ()
{
#ifndef DOXYGEN_SKIP
  Result:= FMultisampleQualityMax;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DDeviceList::GetRequirePostPixelShaderBlending ()
{
#ifndef DOXYGEN_SKIP
  Result:= FRequirePostPixelShaderBlending;
#endif /* DOXYGEN_SKIP */
};

  
Tz3DDeviceList::SetRequirePostPixelShaderBlending (Boolean bRequire 
)
{
#ifndef DOXYGEN_SKIP
  FRequirePostPixelShaderBlending := bRequire;
#endif /* DOXYGEN_SKIP */
};
/*
var
 g_state: Iz3DState = nil;

  
Iz3DState z3DCore_GetState ()
{
#ifndef DOXYGEN_SKIP
  if (g_state = nil) then g_state:= Tz3DState.Create;
  Result:= g_state;
#endif /* DOXYGEN_SKIP */
};

 
z3DCore_FreeState ()
{
#ifndef DOXYGEN_SKIP
  g_state:= nil;
#endif /* DOXYGEN_SKIP */
};

/*
//const

  z3D_MIN_WINDOW_SIZE_X = 200;
  z3D_MIN_WINDOW_SIZE_Y = 200;

var
  g_cs: TRTLCriticalSection;
  g_bThreadSafe: Boolean = True;

*/
 
z3DLock ()
#ifdef  SUPPORTS_INLINE
 inline;#endif
 ;{
#ifndef DOXYGEN_SKIP
  if (g_bThreadSafe) then EnterCriticalSection(g_cs);
#endif /* DOXYGEN_SKIP */
};

 
z3DUnlock ()
#ifdef  SUPPORTS_INLINE
 inline;#endif
 ;{
#ifndef DOXYGEN_SKIP
  if (g_bThreadSafe) then LeaveCriticalSection(g_cs);
#endif /* DOXYGEN_SKIP */
};
#ifdef INCLUDE_TYPE_SECTION

   struct Tz3DState_STATE
{

      IDirect3D9 m_D3D; 
                   // the main D3D object
      IDirect3DDevice9 m_D3DDevice; 
       // the D3D rendering device
      Iz3DDeviceList m_D3DDeviceList; 
   // CD3DDeviceList object
      Pz3DDeviceSettings m_CurrentDeviceSettings; 
   // current device settings
      TD3DSurfaceDesc m_BackBufferSurfaceDesc; 
   // back buffer surface description
      TD3DCaps9 m_Caps; 
                   // D3D caps for current device
      HWND m_HWNDFocus; 
                   // the main app focus window
      HWND m_HWNDDeviceFullScreen; 
        // the main app device window in fullscreen mode
      HWND m_HWNDDeviceWindowed; 
          // the main app device window in windowed mode
      HMONITOR m_AdapterMonitor; 
          // the monitor of the adapter
      HMENU m_Menu; 
                       // handle to menu

      LongWord m_FullScreenBackBufferWidthAtModeChange; 
  // back buffer size of fullscreen mode right before switching to windowed mode.  Used to restore to same resolution when toggling back to fullscreen
      LongWord m_FullScreenBackBufferHeightAtModeChange; 
 // back buffer size of fullscreen mode right before switching to windowed mode.  Used to restore to same resolution when toggling back to fullscreen
      LongWord m_WindowBackBufferWidthAtModeChange; 
      // back buffer size of windowed mode right before switching to fullscreen mode.  Used to restore to same resolution when toggling back to windowed mode
      LongWord m_WindowBackBufferHeightAtModeChange; 
     // back buffer size of windowed mode right before switching to fullscreen mode.  Used to restore to same resolution when toggling back to windowed mode
      DWORD m_WindowedStyleAtModeChange; 
  // window style
      TWindowPlacement m_WindowedPlacement; 
 // record of windowed HWND position/show state/etc
      Boolean m_TopmostWhileWindowed; 
     // if true, the windowed HWND is topmost 
      Boolean FCursorWatermark; 
           // if true, a watermark with D3D is added to the full screen cursor
      Boolean m_Minimized; 
                // if true, the HWND is minimized
      Boolean m_Maximized; 
                // if true, the HWND is maximized
      Boolean m_MinimizedWhileFullscreen; 
 // if true, the HWND is minimized due to a focus switch away when fullscreen mode
      Boolean m_IgnoreSizeChange; 
         // if true, z3D won't reset the device upon HWND size change

      Double m_Time; 
                      // current time in seconds
      Double m_AbsoluteTime; 
              // absolute time in seconds
      Single m_ElapsedTime; 
               // time elapsed since last frame
      Single FStatsUpdateInterval; 
        // interval for stats update

      HINST m_HInstance; 
                  // handle to the app instance
      Double m_LastStatsUpdateTime; 
       // last time the stats were updated
      DWORD m_LastStatsUpdateFrames; 
      // frames count since last time the stats were updated
      Single m_FPS; 
                       // frames per second
      Integer m_CurrentFrameNumber; 
       // the current frame number
      HHOOK m_KeyboardHook; 
               // handle to keyboard hook
      Boolean m_AllowShortcutKeysWhenFullscreen; 
 // if true, when fullscreen enable shortcut keys (Windows keys, StickyKeys shortcut, ToggleKeys shortcut, FilterKeys shortcut)
      Boolean m_AllowShortcutKeysWhenWindowed; 
   // if true, when windowed enable shortcut keys (Windows keys, StickyKeys shortcut, ToggleKeys shortcut, FilterKeys shortcut)
      Boolean m_AllowShortcutKeys; 
        // if true, then shortcut keys are currently disabled (Windows key, etc)
      Boolean m_CallDefWindowProc; 
        // if true, z3DStaticWndProc will call DefWindowProc for unhandled messages. Applications rendering to a dialog may need to set this to false.
      TStickyKeys m_StartupStickyKeys; 
    // StickyKey settings upon startup so they can be restored later
      TToggleKeys m_StartupToggleKeys; 
    // ToggleKey settings upon startup so they can be restored later
      TFilterKeys m_StartupFilterKeys; 
    // FilterKey settings upon startup so they can be restored later

      Boolean m_HandleDefaultHotkeys; 
     // if true, then z3D will handle some default hotkeys
      Boolean m_HandleAltEnter; 
           // if true, then z3D will handle Alt-Enter
      Boolean m_ShowMsgBoxOnError; 
        // if true, then msgboxes are displayed upon errors
      Boolean m_NoStats; 
                  // if true, then z3DGetFrameStats() and z3DGetDeviceStats() will return blank strings
      Boolean m_ClipCursorWhenFullScreen; 
 // if true, then z3D will keep the cursor from going outside the window when full screen
      Boolean m_ShowCursorWhenFullScreen; 
 // if true, then z3D will show a cursor when full screen
      Boolean m_ConstantFrameTime; 
        // if true, then elapsed frame time will always be 0.05f seconds which is good for debugging or automated capture
      Single m_TimePerFrame; 
              // the constant time per frame in seconds, only valid if m_ConstantFrameTime==true
      Boolean m_WireframeMode; 
            // if true, then D3DRS_FILLMODE==D3DFILL_WIREFRAME else D3DRS_FILLMODE==D3DFILL_SOLID
      Boolean m_AutoChangeAdapter; 
        // if true, then the adapter will automatically change if the window is different monitor
      Boolean m_WindowCreatedWithDefaultPositions; 
 // if true, then CW_USEDEFAULT was used and the window should be moved to the right adapter
      Integer m_ExitCode; 
                 // the exit code to be returned to the command line

      Boolean m_z3DInited; 
               // if true, then z3DInit() has succeeded
      Boolean m_WindowCreated; 
            // if true, then z3DCreateWindow() or z3DSetWindow() has succeeded
      Boolean m_DeviceCreated; 
            // if true, then z3DCreateDevice*() or z3DSetDevice() has succeeded

      Boolean m_z3DInitCalled; 
           // if true, then z3DInit() was called
      Boolean m_WindowCreateCalled; 
       // if true, then z3DCreateWindow() or z3DSetWindow() was called
      Boolean m_DeviceCreateCalled; 
       // if true, then z3DCreateDevice*() or z3DSetDevice() was called

      Boolean m_DeviceObjectsCreated; 
     // if true, then DeviceCreated callback has been called (if non-NULL)
      Boolean m_DeviceObjectsReset; 
       // if true, then DeviceReset callback has been called (if non-NULL)
      Boolean m_InsideDeviceCallback; 
     // if true, then the engine is inside an app device callback
      Boolean m_InsideMainloop; 
           // if true, then the engine is inside the main loop
      Boolean m_Active; 
                   // if true, then the app is the active top level window
      Boolean m_TimePaused; 
               // if true, then time is paused
      Boolean m_RenderingPaused; 
          // if true, then rendering is paused
      Integer m_PauseRenderingCount; 
      // pause rendering ref count
      Integer m_PauseTimeCount; 
           // pause time ref count
      Boolean m_DeviceLost; 
               // if true, then the device is lost and needs to be reset
      Boolean m_NotifyOnMouseMove; 
        // if true, include WM_MOUSEMOVE in mousecallback
      Boolean m_Automation; 
               // if true, automation is enabled
      Boolean m_InSizeMove; 
               // if true, app is inside a WM_ENTERSIZEMOVE

      Integer m_OverrideAdapterOrdinal; 
   // if != -1, then override to use this adapter ordinal
      Boolean m_OverrideWindowed; 
         // if true, then force to start windowed
      Boolean m_OverrideFullScreen; 
       // if true, then force to start full screen
      Integer m_OverrideStartX; 
           // if != -1, then override to this X position of the window
      Integer m_OverrideStartY; 
           // if != -1, then override to this Y position of the window
      Integer m_OverrideWidth; 
            // if != 0, then override to this width
      Integer m_OverrideHeight; 
           // if != 0, then override to this height
      Boolean m_OverrideForceHAL; 
         // if true, then force to HAL device (failing if one doesn't exist)
      Boolean m_OverrideForceREF; 
         // if true, then force to REF device (failing if one doesn't exist)
      Boolean m_OverrideForcePureHWVP; 
    // if true, then force to use pure HWVP (failing if device doesn't support it)
      Boolean m_OverrideForceHWVP; 
        // if true, then force to use HWVP (failing if device doesn't support it)
      Boolean m_OverrideForceSWVP; 
        // if true, then force to use SWVP
      Boolean m_OverrideConstantFrameTime; 
// if true, then force to constant frame time
      Single m_OverrideConstantTimePerFrame; 
 // the constant time per frame in seconds if m_OverrideConstantFrameTime==true
      Integer m_OverrideQuitAfterFrame; 
   // if != 0, then it will force the app to quit after that frame
      Integer m_OverrideForceVsync; 
       // if == 0, then it will force the app to use D3DPRESENT_INTERVAL_IMMEDIATE, if == 1 force use of D3DPRESENT_INTERVAL_DEFAULT
      Boolean m_OverrideRelaunchMCE; 
      // if true, then force relaunch of MCE at exit

         Tz3DCallback_AcceptDevice m_AcceptDeviceFunc; 
   // is device acceptable callback
       Tz3DCallback_ModifyDeviceSettings m_ModifyDeviceSettingsFunc; 
 // modify device settings callback
              Tz3DCallback_DeviceCreated m_DeviceCreatedFunc; 
        // device created callback
                Tz3DCallback_DeviceReset m_DeviceResetFunc; 
          // device reset callback
                 Tz3DCallback_DeviceLost m_DeviceLostFunc; 
           // device lost callback
            Tz3DCallback_DeviceDestroyed m_DeviceDestroyedFunc; 
      // device destroyed callback
                  Tz3DCallback_FrameMove m_FrameMoveFunc; 
            // frame move callback
                Tz3DCallback_FrameRender m_FrameRenderFunc; 
          // frame render callback
                   Tz3DCallback_Keyboard m_KeyboardFunc; 
             // keyboard callback
                      Tz3DCallback_Mouse m_MouseFunc; 
                // mouse callback
                  Tz3DCallback_MsgProc m_WindowMsgFunc; 
              // window messages callback

        Pointer m_AcceptDeviceFuncUserContext; 
 // user context for is device acceptable callback
      Pointer m_ModifyDeviceSettingsFuncUserContext; 
 // user context for modify device settings callback
                 Pointer m_DeviceCreatedUserContext; 
 // user context for device created callback
             Pointer m_DeviceCreatedFuncUserContext; 
 // user context for device created callback
               Pointer m_DeviceResetFuncUserContext; 
 // user context for device reset callback
                Pointer m_DeviceLostFuncUserContext; 
 // user context for device lost callback
           Pointer m_DeviceDestroyedFuncUserContext; 
 // user context for device destroyed callback
                 Pointer m_FrameMoveFuncUserContext; 
 // user context for frame move callback
               Pointer m_FrameRenderFuncUserContext; 
 // user context for frame render callback
                  Pointer m_KeyboardFuncUserContext; 
 // user context for keyboard callback
                     Pointer m_MouseFuncUserContext; 
 // user context for mouse callback
                 Pointer m_WindowMsgFuncUserContext; 
 // user context for window messages callback

                           Tz3DKeysArray m_Keys; 
                    // array of key state
                   Tz3DMouseButtonsArray m_MouseButtons; 
             // array of mouse states

      Tz3DTimerRecordArray m_TimerList; 
                                   // list of z3D_TIMER structs
     WideChar m_StaticFrameStats[255]; /*!< [0..255] */
                  // static part of frames stats
     WideChar m_FPSStats[63]; /*!< [0..63] */
                           // fps stats
     WideChar m_FrameStats[255]; /*!< [0..255] */
                        // frame stats (fps, width, etc)
     WideChar m_DeviceStats[255]; /*!< [0..255] */
                       // device stats (description, device type, etc)
     WideChar m_WindowTitle[255]; /*!< [0..255] */
                       // window title

     WideChar CurrentApp[255]; /*!< [0..255] */
     // Current application
 end;



   const Tz3DState_STATE m_state; 


     
Tz3DState::Tz3DState (const Iz3DBase AOwner = nil 
)
{
#ifndef DOXYGEN_SKIP
  inherited;
  CreateState;
  Application.OnException:= AppException;
#endif /* DOXYGEN_SKIP */
};

 
Tz3DState::~Tz3DState ()
{
#ifndef DOXYGEN_SKIP
  DestroyState;
  inherited;
#endif /* DOXYGEN_SKIP */
};

 
Tz3DState::CreateState ()
{
#ifndef DOXYGEN_SKIP
  z3DCore_GetGlobalResourceCache;
  ZeroMemory(@m_state, SizeOf(m_state));
  g_bThreadSafe := True;
  InitializeCriticalSection(g_cs);
  m_state.m_OverrideStartX := -1;
  m_state.m_OverrideStartY := -1;
  m_state.m_OverrideAdapterOrdinal := -1;
  m_state.m_OverrideForceVsync := 0; // TODO JP: Change to 1 to accept REF device
  m_state.m_AutoChangeAdapter := True;
  m_state.m_ShowMsgBoxOnError := True;
  m_state.FStatsUpdateInterval:= 0.5;
  m_state.FCursorWatermark:= False;
  m_state.m_AllowShortcutKeysWhenWindowed := True;
  m_state.m_Active := True;
  m_state.m_CallDefWindowProc := True;
#endif /* DOXYGEN_SKIP */
};

 
Tz3DState::DestroyState ()
{
#ifndef DOXYGEN_SKIP
  z3DCore_Shutdown;
  DeleteCriticalSection(g_cs);
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetActive ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_Active;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
PWideChar Tz3DState::GetCurrentApp ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.CurrentApp;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  /// \sa Direct3D9

HMONITOR Tz3DState::GetAdapterMonitor ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_AdapterMonitor;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Single Tz3DState::GetStatsUpdateInterval ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.FStatsUpdateInterval;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetAutoChangeAdapter ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_AutoChangeAdapter;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
PD3DSurfaceDesc Tz3DState::GetBackBufferSurfaceDesc ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= @m_state.m_BackBufferSurfaceDesc;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
PD3DCaps9 Tz3DState::GetCaps ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= @m_state.m_Caps;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetClipCursorWhenFullScreen ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_ClipCursorWhenFullScreen;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetConstantFrameTime ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_ConstantFrameTime;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Pz3DDeviceSettings Tz3DState::GetCurrentDeviceSettings ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_CurrentDeviceSettings;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Integer Tz3DState::GetCurrentFrameNumber ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_CurrentFrameNumber;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
IDirect3D9 Tz3DState::GetD3D ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_D3D;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
IDirect3DDevice9 Tz3DState::GetD3DDevice ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_D3DDevice;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Iz3DDeviceList Tz3DState::GeTz3DDeviceList ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_D3DDeviceList;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetDeviceCreateCalled ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_DeviceCreateCalled;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetDeviceCreated ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_DeviceCreated;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Tz3DCallback_DeviceCreated Tz3DState::GetDeviceCreatedFunc ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_DeviceCreatedFunc;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Tz3DCallback_DeviceDestroyed Tz3DState::GetDeviceDestroyedFunc ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_DeviceDestroyedFunc;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetDeviceLost ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_DeviceLost;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Tz3DCallback_DeviceLost Tz3DState::GetDeviceLostFunc ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_DeviceLostFunc;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetDeviceObjectsCreated ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_DeviceObjectsCreated;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetDeviceObjectsReset ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_DeviceObjectsReset;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Tz3DCallback_DeviceReset Tz3DState::GetDeviceResetFunc ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_DeviceResetFunc;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
PWideChar Tz3DState::GetDeviceStats ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_DeviceStats;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::Getz3DInitCalled ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_z3DInitCalled;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::Getz3DInited ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_z3DInited;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Single Tz3DState::GetElapsedTime ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_ElapsedTime;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Integer Tz3DState::GetExitCode ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_ExitCode;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Single Tz3DState::GetFPS ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_FPS;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Tz3DCallback_FrameMove Tz3DState::GetFrameMoveFunc ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_FrameMoveFunc;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Tz3DCallback_FrameRender Tz3DState::GetFrameRenderFunc ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_FrameRenderFunc;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
PWideChar Tz3DState::GetFrameStats ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_FrameStats;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetHandleDefaultHotkeys ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_HandleDefaultHotkeys;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
HWND Tz3DState::GetHWNDFocus ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_HWNDFocus;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
HWND Tz3DState::GetHWNDDeviceFullScreen ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_HWNDDeviceFullScreen;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
HWND Tz3DState::GetHWNDDeviceWindowed ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_HWNDDeviceWindowed;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetIgnoreSizeChange ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_IgnoreSizeChange;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetNotifyOnMouseMove ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_NotifyOnMouseMove;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetInsideDeviceCallback ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_InsideDeviceCallback;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetInsideMainloop ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_InsideMainloop;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Tz3DCallback_AcceptDevice Tz3DState::GetAcceptDeviceFunc ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_AcceptDeviceFunc;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Tz3DCallback_Keyboard Tz3DState::GetKeyboardFunc ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_KeyboardFunc;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
DWORD Tz3DState::GetLastStatsUpdateFrames ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_LastStatsUpdateFrames;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetCursorWatermark ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.FCursorWatermark;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Double Tz3DState::GetLastStatsUpdateTime ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_LastStatsUpdateTime;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetMaximized ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_Maximized;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
HMENU Tz3DState::GetMenu ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_Menu;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetMinimized ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_Minimized;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Tz3DCallback_ModifyDeviceSettings Tz3DState::GetModifyDeviceSettingsFunc ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_ModifyDeviceSettingsFunc;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Tz3DCallback_Mouse Tz3DState::GetMouseFunc ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_MouseFunc;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Integer Tz3DState::GetOverrideAdapterOrdinal ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_OverrideAdapterOrdinal;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetOverrideConstantFrameTime ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_OverrideConstantFrameTime;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Single Tz3DState::GetOverrideConstantTimePerFrame ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_OverrideConstantTimePerFrame;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetOverrideForceHAL ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_OverrideForceHAL;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetOverrideForceHWVP ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_OverrideForceHWVP;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetOverrideForcePureHWVP ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_OverrideForcePureHWVP;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetOverrideForceREF ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_OverrideForceREF;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetOverrideForceSWVP ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_OverrideForceSWVP;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetOverrideFullScreen ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_OverrideFullScreen;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Integer Tz3DState::GetOverrideHeight ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_OverrideHeight;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Integer Tz3DState::GetOverrideQuitAfterFrame ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_OverrideQuitAfterFrame;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Integer Tz3DState::GetOverrideForceVsync ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_OverrideForceVsync;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Integer Tz3DState::GetOverrideStartX ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_OverrideStartX;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Integer Tz3DState::GetOverrideStartY ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_OverrideStartY;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Integer Tz3DState::GetOverrideWidth ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_OverrideWidth;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetOverrideWindowed ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_OverrideWindowed;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Integer Tz3DState::GetPauseRenderingCount ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_PauseRenderingCount;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Integer Tz3DState::GetPauseTimeCount ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_PauseTimeCount;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetRenderingPaused ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_RenderingPaused;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetShowCursorWhenFullScreen ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_ShowCursorWhenFullScreen;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetShowMsgBoxOnError ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_ShowMsgBoxOnError;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

 
Boolean Tz3DState::GetNoStats ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_NoStats;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
PWideChar Tz3DState::GetStaticFrameStats ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_StaticFrameStats;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
PWideChar Tz3DState::GetFPSStats ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_FPSStats;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Double Tz3DState::GetTime ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_Time;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Double Tz3DState::GetAbsoluteTime ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_AbsoluteTime;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetTimePaused ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_TimePaused;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Single Tz3DState::GetTimePerFrame ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_TimePerFrame;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Tz3DTimerRecordArray Tz3DState::GetTimerList ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_TimerList;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Pz3DKeysArray Tz3DState::GetKeys ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= @m_state.m_Keys;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Pz3DMouseButtonsArray Tz3DState::GetMouseButtons ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= @m_state.m_MouseButtons;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetWindowCreateCalled ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_WindowCreateCalled;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetWindowCreated ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_WindowCreated;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetWindowCreatedWithDefaultPositions ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_WindowCreatedWithDefaultPositions;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Tz3DCallback_MsgProc Tz3DState::GetWindowMsgFunc ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_WindowMsgFunc;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
PWideChar Tz3DState::GetWindowTitle ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_WindowTitle;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetWireframeMode ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_WireframeMode;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};


  
Boolean Tz3DState::GetAllowShortcutKeys ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_AllowShortcutKeys;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetAllowShortcutKeysWhenFullscreen ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_AllowShortcutKeysWhenFullscreen;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetAllowShortcutKeysWhenWindowed ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_AllowShortcutKeysWhenWindowed;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
HHOOK Tz3DState::GetKeyboardHook ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_KeyboardHook;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
TFilterKeys Tz3DState::GetStartupFilterKeys ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_StartupFilterKeys;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
TStickyKeys Tz3DState::GetStartupStickyKeys ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_StartupStickyKeys;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
TToggleKeys Tz3DState::GetStartupToggleKeys ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_StartupToggleKeys;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetAutomation ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_Automation;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Pointer Tz3DState::GetDeviceCreatedFuncUserContext ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_DeviceCreatedFuncUserContext;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Pointer Tz3DState::GetDeviceDestroyedFuncUserContext ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_DeviceDestroyedFuncUserContext;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Pointer Tz3DState::GetDeviceLostFuncUserContext ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_DeviceLostFuncUserContext;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Pointer Tz3DState::GetDeviceResetFuncUserContext ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_DeviceResetFuncUserContext;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Pointer Tz3DState::GetFrameMoveFuncUserContext ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_FrameMoveFuncUserContext;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Pointer Tz3DState::GetFrameRenderFuncUserContext ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_FrameRenderFuncUserContext;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
LongWord Tz3DState::GetFullScreenBackBufferHeightAtModeChange ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_FullScreenBackBufferHeightAtModeChange;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
LongWord Tz3DState::GetFullScreenBackBufferWidthAtModeChange ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_FullScreenBackBufferWidthAtModeChange;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
HINST Tz3DState::GetHInstance ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_HInstance;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetInSizeMove ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_InSizeMove;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Pointer Tz3DState::GetAcceptDeviceFuncUserContext ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_AcceptDeviceFuncUserContext;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Pointer Tz3DState::GetKeyboardFuncUserContext ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_KeyboardFuncUserContext;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetMinimizedWhileFullscreen ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_MinimizedWhileFullscreen;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Pointer Tz3DState::GetModifyDeviceSettingsFuncUserContext ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_ModifyDeviceSettingsFuncUserContext;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Pointer Tz3DState::GetMouseFuncUserContext ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_MouseFuncUserContext;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
LongWord Tz3DState::GetWindowBackBufferHeightAtModeChange ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_WindowBackBufferHeightAtModeChange;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
LongWord Tz3DState::GetWindowBackBufferWidthAtModeChange ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_WindowBackBufferWidthAtModeChange;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
PWindowPlacement Tz3DState::GetWindowedPlacement ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= @m_state.m_WindowedPlacement;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
DWORD Tz3DState::GetWindowedStyleAtModeChange ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_WindowedStyleAtModeChange;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetTopmostWhileWindowed ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_TopmostWhileWindowed;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Pointer Tz3DState::GetWindowMsgFuncUserContext ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_WindowMsgFuncUserContext;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetCallDefWindowProc ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_CallDefWindowProc;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

  
Boolean Tz3DState::GetHandleAltEnter ()
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  Result:= m_state.m_HandleAltEnter;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetActive (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_Active:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetCurrentApp (const PWideChar Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  StringCchCopy(m_state.CurrentApp, 255, Value);
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetStatsUpdateInterval (const Single Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.FStatsUpdateInterval:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetAdapterMonitor (const Direct3D9::ONITOR Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_AdapterMonitor:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetAutoChangeAdapter (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;                 
  m_state.m_AutoChangeAdapter:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

     
Tz3DState::SetBackBufferSurfaceDesc (const PD3DSurfaceDesc Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_BackBufferSurfaceDesc:= Value^;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetCaps (const PD3DCaps9 Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_Caps:= Value^;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetClipCursorWhenFullScreen (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_ClipCursorWhenFullScreen:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetConstantFrameTime (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_ConstantFrameTime:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

     
Tz3DState::SetCurrentDeviceSettings (const Pz3DDeviceSettings Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_CurrentDeviceSettings:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetCurrentFrameNumber (const Integer Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_CurrentFrameNumber:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetD3D (const IDirect3D9 Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_D3D:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetD3DDevice (const IDirect3DDevice9 Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_D3DDevice:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SeTz3DDeviceList (const Iz3DDeviceList Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_D3DDeviceList:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetDeviceCreateCalled (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_DeviceCreateCalled:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetDeviceCreated (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_DeviceCreated:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

     
Tz3DState::SetDeviceCreatedFunc (const Tz3DCallback_DeviceCreated Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_DeviceCreatedFunc:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

     
Tz3DState::SetDeviceDestroyedFunc (const Tz3DCallback_DeviceDestroyed Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_DeviceDestroyedFunc:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetDeviceLost (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_DeviceLost:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

     
Tz3DState::SetDeviceLostFunc (const Tz3DCallback_DeviceLost Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_DeviceLostFunc:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetDeviceObjectsCreated (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_DeviceObjectsCreated:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetDeviceObjectsReset (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_DeviceObjectsReset:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

     
Tz3DState::SetDeviceResetFunc (const Tz3DCallback_DeviceReset Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_DeviceResetFunc:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::Setz3DInitCalled (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_z3DInitCalled:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::Setz3DInited (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_z3DInited:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetElapsedTime (const Single Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_ElapsedTime:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetExitCode (const Integer Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_ExitCode:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetFPS (const Single Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_FPS:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetFrameMoveFunc (const Tz3DCallback_FrameMove Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_FrameMoveFunc:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

     
Tz3DState::SetFrameRenderFunc (const Tz3DCallback_FrameRender Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_FrameRenderFunc:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetHandleDefaultHotkeys (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_HandleDefaultHotkeys:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetHWNDFocus (const HWND Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_HWNDFocus:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetHWNDDeviceFullScreen (const HWND Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_HWNDDeviceFullScreen:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetHWNDDeviceWindowed (const HWND Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_HWNDDeviceWindowed:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetIgnoreSizeChange (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_IgnoreSizeChange:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetNotifyOnMouseMove (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_NotifyOnMouseMove:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetInsideDeviceCallback (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_InsideDeviceCallback:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetInsideMainloop (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_InsideMainloop:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

     
Tz3DState::SetAcceptDeviceFunc (const Tz3DCallback_AcceptDevice Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_AcceptDeviceFunc:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetKeyboardFunc (const Tz3DCallback_Keyboard Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_KeyboardFunc:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetLastStatsUpdateFrames (const DWORD Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_LastStatsUpdateFrames:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetLastStatsUpdateTime (const Double Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_LastStatsUpdateTime:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetMaximized (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_Maximized:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetMenu (const HMENU Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_Menu:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetMinimized (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_Minimized:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

     
Tz3DState::SetModifyDeviceSettingsFunc (const Tz3DCallback_ModifyDeviceSettings Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_ModifyDeviceSettingsFunc:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetMouseFunc (const Tz3DCallback_Mouse Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_MouseFunc:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetOverrideAdapterOrdinal (const Integer Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_OverrideAdapterOrdinal:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetOverrideConstantFrameTime (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_OverrideConstantFrameTime:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetOverrideConstantTimePerFrame (const Single Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_OverrideConstantTimePerFrame:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetOverrideForceHAL (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_OverrideForceHAL:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetOverrideForceHWVP (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_OverrideForceHWVP:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetOverrideForcePureHWVP (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_OverrideForcePureHWVP:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetOverrideForceREF (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_OverrideForceREF:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetOverrideForceSWVP (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_OverrideForceSWVP:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetOverrideFullScreen (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_OverrideFullScreen:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetOverrideHeight (const Integer Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_OverrideHeight:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetOverrideQuitAfterFrame (const Integer Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_OverrideQuitAfterFrame:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetOverrideForceVsync (const Integer Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_OverrideForceVsync:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetOverrideRelaunchMCE (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_OverrideRelaunchMCE:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetOverrideStartX (const Integer Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_OverrideStartX:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetOverrideStartY (const Integer Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_OverrideStartY:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetOverrideWidth (const Integer Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_OverrideWidth:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetOverrideWindowed (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_OverrideWindowed:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetPauseRenderingCount (const Integer Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_PauseRenderingCount:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetPauseTimeCount (const Integer Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_PauseTimeCount:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetRenderingPaused (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_RenderingPaused:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetShowCursorWhenFullScreen (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_ShowCursorWhenFullScreen:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetShowMsgBoxOnError (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_ShowMsgBoxOnError:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetNoStats (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_NoStats:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetTime (const Double Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_Time:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetAbsoluteTime (const Double Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_AbsoluteTime:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetTimePaused (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_TimePaused:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetTimePerFrame (const Single Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_TimePerFrame:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetTimerList (const Tz3DTimerRecordArray Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_TimerList:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetWindowCreateCalled (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_WindowCreateCalled:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetWindowCreated (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_WindowCreated:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

     
Tz3DState::SetWindowCreatedWithDefaultPositions (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_WindowCreatedWithDefaultPositions:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetWindowMsgFunc (const Tz3DCallback_MsgProc Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_WindowMsgFunc:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetWireframeMode (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_WireframeMode:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetAllowShortcutKeys (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_AllowShortcutKeys:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

     
Tz3DState::SetAllowShortcutKeysWhenFullscreen (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_AllowShortcutKeysWhenFullscreen:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

     
Tz3DState::SetAllowShortcutKeysWhenWindowed (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_AllowShortcutKeysWhenWindowed:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetKeyboardHook (const HHOOK Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_KeyboardHook:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetStartupFilterKeys (const TFilterKeys Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_StartupFilterKeys:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetStartupStickyKeys (const TStickyKeys Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_StartupStickyKeys:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetStartupToggleKeys (const TToggleKeys Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_StartupToggleKeys:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetAutomation (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_Automation:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetDeviceCreatedFuncUserContext (const Pointer Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_DeviceCreatedFuncUserContext:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

     
Tz3DState::SetDeviceDestroyedFuncUserContext (const Pointer Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_DeviceDestroyedFuncUserContext:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetDeviceLostFuncUserContext (const Pointer Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_DeviceLostFuncUserContext:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetDeviceResetFuncUserContext (const Pointer Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_DeviceResetFuncUserContext:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetFrameMoveFuncUserContext (const Pointer Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_FrameMoveFuncUserContext:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetFrameRenderFuncUserContext (const Pointer Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_FrameRenderFuncUserContext:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

     
Tz3DState::SetFullScreenBackBufferHeightAtModeChange (const LongWord Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_FullScreenBackBufferHeightAtModeChange:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

     
Tz3DState::SetFullScreenBackBufferWidthAtModeChange (const LongWord Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_FullScreenBackBufferWidthAtModeChange:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetHInstance (const HINST Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_HInstance:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetInSizeMove (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_InSizeMove:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

     
Tz3DState::SetAcceptDeviceFuncUserContext (const Pointer Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_AcceptDeviceFuncUserContext:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetKeyboardFuncUserContext (const Pointer Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_KeyboardFuncUserContext:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetMinimizedWhileFullscreen (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_MinimizedWhileFullscreen:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

     
Tz3DState::SetModifyDeviceSettingsFuncUserContext (const Pointer Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_ModifyDeviceSettingsFuncUserContext:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetMouseFuncUserContext (const Pointer Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_MouseFuncUserContext:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

     
Tz3DState::SetWindowBackBufferHeightAtModeChange (const LongWord Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_WindowBackBufferHeightAtModeChange:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

     
Tz3DState::SetWindowBackBufferWidthAtModeChange (const LongWord Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_WindowBackBufferWidthAtModeChange:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetWindowedPlacement (const PWindowPlacement Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_WindowedPlacement:= Value^;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetWindowedStyleAtModeChange (const DWORD Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_WindowedStyleAtModeChange:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetCursorWatermark (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.FCursorWatermark:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetTopmostWhileWindowed (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_TopmostWhileWindowed:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetWindowMsgFuncUserContext (const Pointer Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_WindowMsgFuncUserContext:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetCallDefWindowProc (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_CallDefWindowProc:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};

   
Tz3DState::SetHandleAltEnter (const Boolean Value 
)
{
#ifndef DOXYGEN_SKIP
  z3DLock;
  m_state.m_HandleAltEnter:= Value;
  z3DUnlock;
#endif /* DOXYGEN_SKIP */
};



   
Integer z3DMapButtonToArrayIndex (Byte vButton 
)
 ;
 
z3DSetProcessorAffinity ()
 ;
 
z3DParseCommandLine ()
 ;
     
Iz3DDeviceList z3DPrepareDeviceListObject (Boolean bEnumerate = False 
)
 ;
      
z3DBuildOptimalDeviceSettings (Pz3DDeviceSettings pOptimalDeviceSettings ,
Pz3DDeviceSettings pDeviceSettingsIn ,
Pz3DMatchOptions pMatchOptions 
)
 ;
       
Boolean z3DDoesDeviceComboMatchPreserveOptions (PD3DDeviceSettingsCombinations pDeviceSettingsCombo ,
Pz3DDeviceSettings pDeviceSettingsIn ,
Pz3DMatchOptions pMatchOptions 
)
 ;
       
Single z3DRankDeviceCombo (PD3DDeviceSettingsCombinations pDeviceSettingsCombo ,
Pz3DDeviceSettings pOptimalDeviceSettings ,
PD3DDisplayMode pAdapterDesktopDisplayMode 
)
 ;
          
z3DBuildValidDeviceSettings (/* out */ Tz3DDeviceSettings &pValidDeviceSettings ,
const TD3DDeviceSettingsCombinations pBestDeviceSettingsCombo ,
Pz3DDeviceSettings pDeviceSettingsIn ,
Pz3DMatchOptions pMatchOptions 
)
 ;

         
HRESULT z3DFindValidResolution (const TD3DDeviceSettingsCombinations pBestDeviceSettingsCombo ,
TD3DDisplayMode displayModeIn ,
/* out */ TD3DDisplayMode &pBestDisplayMode 
)
 ;
            
HRESULT z3DFindAdapterFormat (LongWord AdapterOrdinal ,
TD3DDevType DeviceType ,
TD3DFormat BackBufferFormat ,
Boolean Windowed ,
/* out */ TD3DFormat &pAdapterFormat 
)
 ;
         
HRESULT z3DChangeDevice (Pz3DDeviceSettings pNewDeviceSettings ,
IDirect3DDevice9 pd3dDeviceFromApp ,
Boolean bForceRecreate ,
Boolean bClipWindowToSingleAdapter 
)
 ;
   
z3DUpdateDeviceSettingsWithOverrides (/* out */ Tz3DDeviceSettings &pDeviceSettings 
)
 ;
    
HRESULT z3DCreate3DEnvironment (const IDirect3DDevice9 pd3dDeviceFromApp 
)
 ;
  
HRESULT z3DReset3DEnvironment ()
 ;
    
z3DCleanup3DEnvironment (Boolean bReleaseSettings = True 
)
 ;
 
z3DUpdateFrameStats ()
 ;
       
z3DUpdateDeviceStats (TD3DDevType DeviceType ,
DWORD BehaviorFlags ,
const TD3DAdapterIdentifier9 pAdapterIdentifier 
)
 ;
 
z3DUpdateStaticFrameStats ()
 ;
 
z3DCheckForWindowSizeChange ()
 ;
 
z3DCheckForWindowChangingMonitors ()
 ;
 
z3DHandleTimers ()
 ;
      
Boolean z3DIsNextArg (PAnsiChar &strCmdLine ,
PAnsiChar strArg 
)
 ;
       
Boolean z3DGetCmdParam (PAnsiChar &strCmdLine ,
/* out */ PAnsiChar &strFlag 
)
 ;
      
HRESULT z3DGetAdapterOrdinalFromMonitor (HMONITOR hMonitor ,
/* out */ LongWord &pAdapterOrdinal 
)
 ;
  
z3DAllowShortcutKeys (Boolean bAllowKeys 
)
 ;
 
z3DUpdateBackBufferDesc ()
 ;
 
z3DSetupCursor ()
 ;
        
HRESULT z3DSetDeviceCursor (const IDirect3DDevice9 pd3dDevice ,
HCURSOR hCursor ,
Boolean bAddWatermark 
)
 ;


    
z3DCore_SetCallback_DeviceCreated (Tz3DCallback_DeviceCreated pCallbackDeviceCreated ,
Pointer pUserContext 
)
{
#ifndef DOXYGEN_SKIP
  z3DCore_GetState.SetDeviceCreatedFunc(pCallbackDeviceCreated);
  z3DCore_GetState.SetDeviceCreatedFuncUserContext(pUserContext);
#endif /* DOXYGEN_SKIP */
};

    
z3DCore_SetCallback_DeviceReset (Tz3DCallback_DeviceReset pCallbackDeviceReset ,
Pointer pUserContext 
)
{
#ifndef DOXYGEN_SKIP
  z3DCore_GetState.SetDeviceResetFunc(pCallbackDeviceReset);
  z3DCore_GetState.SetDeviceResetFuncUserContext(pUserContext);
#endif /* DOXYGEN_SKIP */
};

    
z3DCore_SetCallback_DeviceLost (Tz3DCallback_DeviceLost pCallbackDeviceLost ,
Pointer pUserContext 
)
{
#ifndef DOXYGEN_SKIP
  z3DCore_GetState.SetDeviceLostFunc(pCallbackDeviceLost);
  z3DCore_GetState.SetDeviceLostFuncUserContext(pUserContext);
#endif /* DOXYGEN_SKIP */
};

    
z3DCore_SetCallback_DeviceDestroyed (Tz3DCallback_DeviceDestroyed pCallbackDeviceDestroyed ,
Pointer pUserContext 
)
{
#ifndef DOXYGEN_SKIP
  z3DCore_GetState.SetDeviceDestroyedFunc(pCallbackDeviceDestroyed);
  z3DCore_GetState.SetDeviceDestroyedFuncUserContext(pUserContext);
#endif /* DOXYGEN_SKIP */
};

    
z3DCore_SetCallback_DeviceChanging (Tz3DCallback_ModifyDeviceSettings pCallbackModifyDeviceSettings ,
Pointer pUserContext 
)
{
#ifndef DOXYGEN_SKIP
  z3DCore_GetState.SetModifyDeviceSettingsFunc(pCallbackModifyDeviceSettings);
  z3DCore_GetState.SetModifyDeviceSettingsFuncUserContext(pUserContext);
#endif /* DOXYGEN_SKIP */
};

    
z3DCore_SetCallback_FrameMove (Tz3DCallback_FrameMove pCallbackFrameMove ,
Pointer pUserContext 
)
{
#ifndef DOXYGEN_SKIP
  z3DCore_GetState.SetFrameMoveFunc(pCallbackFrameMove);
  z3DCore_GetState.SetFrameMoveFuncUserContext(pUserContext);
#endif /* DOXYGEN_SKIP */
};

    
z3DCore_SetCallback_FrameRender (Tz3DCallback_FrameRender pCallbackFrameRender ,
Pointer pUserContext 
)
{
#ifndef DOXYGEN_SKIP
  z3DCore_GetState.SetFrameRenderFunc(pCallbackFrameRender);
  z3DCore_GetState.SetFrameRenderFuncUserContext(pUserContext);
#endif /* DOXYGEN_SKIP */
};

    
z3DCore_SetCallback_Keyboard (Tz3DCallback_Keyboard pCallbackKeyboard ,
Pointer pUserContext 
)
{
#ifndef DOXYGEN_SKIP
  z3DCore_GetState.SetKeyboardFunc(pCallbackKeyboard);
  z3DCore_GetState.SetKeyboardFuncUserContext(pUserContext);
#endif /* DOXYGEN_SKIP */
};

      
z3DCore_SetCallback_Mouse (Tz3DCallback_Mouse pCallbackMouse ,
Boolean bIncludeMouseMove ,
Pointer pUserContext 
)
{
#ifndef DOXYGEN_SKIP
  with z3DCore_GetState dobegin    SetMouseFunc(pCallbackMouse);
    SetNotifyOnMouseMove(bIncludeMouseMove);
 end
#endif /* DOXYGEN_SKIP */
};

    
z3DCore_SetCallback_MsgProc (Tz3DCallback_MsgProc pCallbackMsgProc ,
Pointer pUserContext 
)
{
#ifndef DOXYGEN_SKIP
  z3DCore_GetState.SetWindowMsgFunc(pCallbackMsgProc);
  z3DCore_GetState.SetWindowMsgFuncUserContext(pUserContext);
#endif /* DOXYGEN_SKIP */
};

////////////////////////////////////////////////////////////////////////////////
// Note about the z3D Command line parameters                                 //
////////////////////////////////////////////////////////////////////////////////
// Possible command line parameters are:                                      //
////////////////////////////////////////////////////////////////////////////////
//    -adapter:#            forces app to use this adapter # (fails if the    //
//                          adapter doesn't exist)                            //
//    -windowed             forces app to start windowed                      //
//    -fullscreen           forces app to start full screen                   //
//    -forcehal             forces app to use HAL (fails if HAL doesn't       //
//                          exist)                                            //
//    -forceref             forces app to use REF (fails if REF doesn't       //
//                          exist)                                            //
//    -forcepurehwvp        forces app to use pure HWVP (fails if device      //
//                          doesn't support it)                               //
//    -forcehwvp            forces app to use HWVP (fails if device doesn't   //
//                          support it)                                       //
//    -forceswvp            forces app to use SWVP                            //
//    -forcevsync:#         if # is 0, forces app to use                      //
//                          D3DPRESENT_INTERVAL_IMMEDIATE otherwise force use //
//                          of D3DPRESENT_INTERVAL_DEFAULT                    //
//    -width:#              forces app to use # for width. for full screen,   //
//                          it will pick the closest possible supported mode  //
//    -height:#             forces app to use # for height. for full screen,  //
//                          it will pick the closest possible supported mode  //
//    -startx:#             forces app to use # for the x coord of the window //
//                          position for windowed mode                        //
//    -starty:#             forces app to use # for the y coord of the window //
//                          position for windowed mode                        //
//    -constantframetime:#  forces app to use constant frame time, where # is //
//                          the time/frame in seconds                         //
//    -quitafterframe:x     forces app to quit after # frames                 //
//    -noerrormsgboxes      prevents the display of message boxes generated   //
//                          by the engine so the application can be run       //
//                          without user interaction                          //
//    -nostats              prevents the display of the stats                 //
//    -automation           every Cz3DDialog created will have                //
//                          EnableKeyboardInput(true) called, enabling UI     //
//                          navigation with keyboard                          //
//                          This is useful when automating application        //
//                          testing.                                          //
////////////////////////////////////////////////////////////////////////////////
// Hotkeys handled by default are:                                            //
////////////////////////////////////////////////////////////////////////////////
//    Alt-Enter           toggle between full screen & windowed (hotkey       //
//                        always enabled)                                     //
//    ESC                 exit app                                            //
//    F3                  toggle HAL/REF                                      //
//    F8                  toggle wire-frame mode                              //
//    Pause               pause time                                          //
////////////////////////////////////////////////////////////////////////////////

                  
HRESULT z3DInit (Boolean bParseCommandLine = True ,
Boolean bHandleDefaultHotkeys = True ,
Boolean bShowMsgBoxOnError = True ,
Boolean bHandleAltEnter = True 
)

/*
var

  sk: TStickyKeys;
  tk: TToggleKeys;
  fk: TFilterKeys;
  pD3D: IDirect3D9;
*/
{
#ifndef DOXYGEN_SKIP

  z3DCore_GetState.Setz3DInitCalled(True);
//  InitCommonControls;
  FillChar(sk, SizeOf(sk), 0); sk.cbSize:= SizeOf(sk);
  SystemParametersInfo(SPI_GETSTICKYKEYS, SizeOf(sk), @sk, 0);
  z3DCore_GetState.SetStartupStickyKeys(sk);
  FillChar(tk, SizeOf(tk), 0); tk.cbSize:= SizeOf(tk);
  SystemParametersInfo(SPI_GETTOGGLEKEYS, SizeOf(tk), @tk, 0);
  z3DCore_GetState.SetStartupToggleKeys(tk);
  FillChar(fk, SizeOf(fk), 0); fk.cbSize:= SizeOf(fk);
  SystemParametersInfo(SPI_GETFILTERKEYS, SizeOf(fk), @fk, 0);
  z3DCore_GetState.SetStartupFilterKeys(fk);
  timeBeginPeriod(1);
  z3DCore_GetState.SetShowMsgBoxOnError(bShowMsgBoxOnError);
  z3DCore_GetState.SetHandleDefaultHotkeys(bHandleDefaultHotkeys);
  z3DCore_GetState.SetHandleAltEnter(bHandleAltEnter);
  if bParseCommandLine and not z3DCore_GetState.z3DInited then z3DParseCommandLine;

  // Check DirectX version
  if not D3DXCheckVersion(D3D_SDK_VERSION, D3DX_SDK_VERSION) thenbegin    z3DDisplayErrorMessage(z3DERR_INCORRECTVERSION);
    Result:= z3DError('D3DXCheckVersion', z3DERR_INCORRECTVERSION);
    Exit;
 end

  // Test device creation
  pD3D := z3DCore_GetD3DObject;
  if (pD3D = nil) thenbegin    pD3D := z3DCreateDirect3D9(D3D_SDK_VERSION);
    z3DCore_GetState.D3D := pD3D;
 end
  if (pD3D = nil) thenbegin    z3DDisplayErrorMessage(z3DERR_NODIRECT3D);
    Result:= z3DError('Direct3DCreate9', z3DERR_NODIRECT3D);
    Exit;
 end

  // Check if current app is valid
  if z3DFileSystemController <> nil then
  if (WideCharToString(z3DCore_GetState.CurrentApp) = '') or not
  DirectoryExists(z3DFileSystemController.GetFullPath(z3DCore_GetState.CurrentApp)) then
  z3DCore_LaunchAppStart;

  // Reset timers and init app
  z3DCore_GetGlobalTimer.Reset;
  z3DCore_GetState.z3DInited := True;
  Result:= S_OK;
#endif /* DOXYGEN_SKIP */
};

 
z3DSetProcessorAffinity ()

/*
var

  hCurrentProcess: THandle;
  dwProcessAffinityMask: DWORD_PTR;
  dwSystemAffinityMask: DWORD_PTR;
  dwAffinityMask: DWORD_PTR;
  hCurrentThread: THandle;
*/
{
#ifndef DOXYGEN_SKIP

  hCurrentProcess := GetCurrentProcess;
  dwProcessAffinityMask := 0;
  dwSystemAffinityMask := 0;
  if GetProcessAffinityMask(hCurrentProcess, dwProcessAffinityMask, dwSystemAffinityMask) and
     (dwProcessAffinityMask <> 0) thenbegin    dwAffinityMask := (dwProcessAffinityMask and ((not dwProcessAffinityMask) + 1 ));
    hCurrentThread := GetCurrentThread;
    if (INVALID_HANDLE_VALUE <> hCurrentThread) thenbegin      SetThreadAffinityMask(hCurrentThread, dwAffinityMask);
      CloseHandle(hCurrentThread);
   end
 end
  CloseHandle(hCurrentProcess);
#endif /* DOXYGEN_SKIP */
};

 
z3DParseCommandLine ()

/*
var

  S: PWideChar;
  strCmdLine: PAnsiChar;
  strFlag: PAnsiChar;
  nNumArgs: Integer;
  iArg: Integer;
  nAdapter: Integer;
  nOn: Integer;
  nWidth, nHeight: Integer;
  nX, nY: Integer;
  fTimePerFrame: Single;
  nFrame: Integer;
  strSpace: PAnsiChar;
*/
{
#ifndef DOXYGEN_SKIP

  nNumArgs:= ParamCount;
  GetMem(S, 255);
  try
    for iArg:= 1 to nNumArgs dobegin      StringToWideChar(ParamStr(iArg), S, 255);
      strCmdLine := PAnsiChar(ParamStr(iArg));
      if (strCmdLine^ = '/') or (strCmdLine^ = '-') thenbegin        Inc(strCmdLine);

        if z3DIsNextArg(strCmdLine, 'adapter') thenbegin          if z3DGetCmdParam(strCmdLine, strFlag) thenbegin            nAdapter := StrToInt(strFlag);
            z3DCore_GetState.OverrideAdapterOrdinal := nAdapter;
            Continue;
         end
       end
        if z3DIsNextArg(strCmdLine, 'windowed') thenbegin          z3DCore_GetState.OverrideWindowed := True;
          Continue;
       end
        if z3DIsNextArg(strCmdLine, 'fullscreen') thenbegin          z3DCore_GetState.OverrideFullScreen := True;
          Continue;
       end
        if z3DIsNextArg(strCmdLine, 'forcehal') thenbegin          z3DCore_GetState.OverrideForceHAL := True;
          Continue;
       end
        if z3DIsNextArg(strCmdLine,'forceref') thenbegin          z3DCore_GetState.OverrideForceREF := True;
          Continue;
       end
        if z3DIsNextArg(strCmdLine, 'forcepurehwvp') thenbegin          z3DCore_GetState.OverrideForcePureHWVP := True;
          Continue;
       end
        if z3DIsNextArg(strCmdLine, 'forcehwvp') thenbegin          z3DCore_GetState.OverrideForceHWVP := True;
          Continue;
       end
        if z3DIsNextArg(strCmdLine, 'forceswvp') thenbegin          z3DCore_GetState.OverrideForceSWVP := True;
          Continue;
       end
        if z3DIsNextArg(strCmdLine, 'forcevsync') thenbegin          if z3DGetCmdParam(strCmdLine, strFlag) thenbegin            nOn := StrToInt(strFlag);
            z3DCore_GetState.OverrideForceVsync := nOn;
            Continue;
         end
       end
        if z3DIsNextArg(strCmdLine, 'width') thenbegin          if z3DGetCmdParam(strCmdLine, strFlag) thenbegin            nWidth := StrToInt(strFlag);
            z3DCore_GetState.OverrideWidth := nWidth;
            Continue;
         end
       end
        if z3DIsNextArg(strCmdLine, 'app') thenbegin          if z3DGetCmdParam(strCmdLine, strFlag) thenbegin            StringToWideChar(strFlag, z3DCore_GetState.CurrentApp, 255);
            Continue;
         end
       end
        if z3DIsNextArg(strCmdLine, 'height') thenbegin          if z3DGetCmdParam(strCmdLine, strFlag) thenbegin            nHeight := StrToInt(strFlag);
            z3DCore_GetState.OverrideHeight := nHeight;
            Continue;
         end
       end
        if z3DIsNextArg(strCmdLine, 'startx') thenbegin          if z3DGetCmdParam(strCmdLine, strFlag) thenbegin            nX := StrToInt(strFlag);
            z3DCore_GetState.OverrideStartX := nX;
            Continue;
         end
       end
        if z3DIsNextArg(strCmdLine, 'starty') thenbegin          if z3DGetCmdParam(strCmdLine, strFlag) thenbegin            nY := StrToInt(strFlag);
            z3DCore_GetState.OverrideStartY := nY;
            Continue;
         end
       end
        if z3DIsNextArg(strCmdLine, 'constantframetime') thenbegin          if z3DGetCmdParam(strCmdLine, strFlag)
          then fTimePerFrame := StrToFloat(strFlag)
          else fTimePerFrame := 0.0333;
          z3DCore_GetState.OverrideConstantFrameTime := True;
          z3DCore_GetState.OverrideConstantTimePerFrame := fTimePerFrame;
          z3DCore_SetConstantFrameTime(True, fTimePerFrame);
          Continue;
       end
        if z3DIsNextArg(strCmdLine, 'quitafterframe') thenbegin          if z3DGetCmdParam(strCmdLine, strFlag) thenbegin            nFrame := StrToInt(strFlag);
            z3DCore_GetState.OverrideQuitAfterFrame := nFrame;
            Continue;
         end
       end
        if z3DIsNextArg(strCmdLine, 'noerrormsgboxes') thenbegin          z3DCore_GetState.ShowMsgBoxOnError := False;
          Continue;
       end
        if z3DIsNextArg(strCmdLine, 'nostats') thenbegin          z3DCore_GetState.NoStats := True;
          Continue;
       end
        if z3DIsNextArg(strCmdLine, 'automation') thenbegin          z3DCore_GetState.Automation := True;
          Continue;
       end
     end
      strFlag := strCmdLine;
      strSpace := PAnsiChar(strFlag);
      while (strSpace^ <> #0) and (strSpace^ > ' ') do Inc(strSpace);
      strSpace^ := #0;
      z3DTrace(PWideChar(WideString('z3DParseCommandLine: Unknown parameter: '+strFlag)));
   end
  finally
    FreeMem(S);
 end
#endif /* DOXYGEN_SKIP */
};

      
Boolean z3DIsNextArg (PAnsiChar &strCmdLine ,
PAnsiChar strArg 
)

/*
var

  nArgLen: Integer;
  nCmdLen: Integer;
*/
{
#ifndef DOXYGEN_SKIP

  nArgLen := StrLen(strArg);
  nCmdLen := StrLen(strCmdLine);
  if (nCmdLen >= nArgLen) and
     (StrLIComp(strCmdLine, strArg, nArgLen) = 0) and
     ((strCmdLine[nArgLen] = #0) or (strCmdLine[nArgLen] = ':')) thenbegin    Inc(strCmdLine, nArgLen);
    Result:= True;
    Exit;
 end
  Result:= False;
#endif /* DOXYGEN_SKIP */
};

       
Boolean z3DGetCmdParam (PAnsiChar &strCmdLine ,
/* out */ PAnsiChar &strFlag 
)

/*
var

  strFlagBuf: array[0..255] of AnsiChar;
  strSpace: PChar;
*/
{
#ifndef DOXYGEN_SKIP

  if (strCmdLine^ = ':') thenbegin    Inc(strCmdLine);
    StringCchCopy(strFlagBuf, 256, strCmdLine);
    strSpace := strFlagBuf;
    while (strSpace^ <> #0) and (strSpace^ > ' ') do Inc(strSpace);
    strSpace^ := #0;
    strFlag := strFlagBuf;
    Inc(strCmdLine, Length(strFlag));
    Result:= True;
 endelsebegin    strFlag := '' 
    Result:= False;
 end
#endif /* DOXYGEN_SKIP */
};

                                                                       (
z3DCore_CreateWindow (const PWideChar strWindowTitle = nil ,
LongWord hInstance = 0 ,
HICON hIcon = 0 ,
HMENU hMenu = 0 ,
Integer x = Integer ,
 CW_USEDEFAULT 
)
 y: Integer = Integer(CW_USEDEFAULT)): HRESULT;
/*
var

  szExePath: array[0..MAX_PATH-1] of WideChar;
  dwError: DWORD;
  rc: TRect;
  nDefaultWidth: Integer;
  nDefaultHeight: Integer;
  strCachedWindowTitle: PWideChar;
  hWnd: Windows.HWND;
  wndClass: TWndClassW;
*/
{
#ifndef DOXYGEN_SKIP

  if z3DCore_GetState.InsideDeviceCallback thenbegin    Result:= z3DErrorMessage('z3DCreateWindow', E_FAIL);
    Exit;
 end
  z3DCore_GetState.WindowCreateCalled:= True;
  if not z3DCore_GetState.z3DInited thenbegin    if z3DCore_GetState.z3DInitCalled thenbegin      Result:= E_FAIL;
      Exit;
   end
    Result := z3DInit;
    if FAILED(Result) then Exit;
 end
  if (z3DCore_GetHWNDFocus = 0) thenbegin    if (hInstance = 0) then hInstance := GetModuleHandle(nil);
    z3DCore_GetState.SetHInstance(hInstance);
    GetModuleFileNameW(0, szExePath, MAX_PATH);
    if (hIcon = 0) then
      hIcon := ExtractIconW(hInstance, szExePath, 0);
    FillChar(wndClass, SizeOf(wndClass), 0);
    wndClass.style := CS_DBLCLKS;
    wndClass.lpfnWndProc := @z3DCore_StaticWndProc;
    wndClass.cbClsExtra := 0;
    wndClass.cbWndExtra := 0;
    wndClass.hInstance := hInstance;
    wndClass.hIcon := hIcon;
    wndClass.hCursor := LoadCursor(0, IDC_ARROW);
    wndClass.hbrBackground := GetStockObject(BLACK_BRUSH);
    wndClass.lpszMenuName := nil;
    wndClass.lpszClassName := 'z3DWindowClass';
    if (Windows.RegisterClassW(wndClass) = 0) thenbegin      dwError := GetLastError;
      if (dwError <> ERROR_CLASS_ALREADY_EXISTS) thenbegin        Result:= z3DErrorMessage('RegisterClass', HRESULT((dwError and $0000FFFF) or (FACILITY_WIN32 shl 16))); // HRESULT_FROM_WIN32(dwError));
        Exit;
     end
   end
    if (z3DCore_GetState.OverrideStartX <> -1) then
      x := z3DCore_GetState.OverrideStartX;
    if (z3DCore_GetState.OverrideStartY <> -1) then
      y := z3DCore_GetState.OverrideStartY;
    z3DCore_GetState.WindowCreatedWithDefaultPositions:= False;
    if (DWORD(x) = CW_USEDEFAULT) and (DWORD(y) = CW_USEDEFAULT) then
      z3DCore_GetState.WindowCreatedWithDefaultPositions:= True;
    nDefaultWidth := 640;
    nDefaultHeight := 480;
    if (z3DCore_GetState.OverrideWidth <> 0) then
      nDefaultWidth := z3DCore_GetState.OverrideWidth;
    if (z3DCore_GetState.OverrideHeight <> 0) then
      nDefaultHeight := z3DCore_GetState.OverrideHeight;
    SetRect(rc, 0, 0, nDefaultWidth, nDefaultHeight);
    AdjustWindowRect(rc, WS_OVERLAPPEDWINDOW, (hMenu <> 0));

    strCachedWindowTitle := z3DCore_GetState.WindowTitle;
    StringCchCopy(strCachedWindowTitle, 256, strWindowTitle);
    hWnd := CreateWindowW('z3DWindowClass', strCachedWindowTitle, WS_OVERLAPPEDWINDOW,
                         x, y, (rc.right-rc.left), (rc.bottom-rc.top), 0,
                         hMenu, hInstance, nil);
    if (hWnd = 0) thenbegin      dwError := GetLastError;
      Result:= z3DErrorMessage('CreateWindow', HRESULT((dwError and $0000FFFF) or (FACILITY_WIN32 shl 16))); // HRESULT_FROM_WIN32(dwError));
      Exit;
   end
    z3DCore_GetState.WindowCreated := True;
    z3DCore_GetState.SetHWNDFocus(hWnd);
    z3DCore_GetState.SetHWNDDeviceFullScreen(hWnd);
    z3DCore_GetState.SetHWNDDeviceWindowed(hWnd);
 end
  Result:= S_OK;
#endif /* DOXYGEN_SKIP */
};

          
HRESULT z3DCore_SetWindow (HWND hWndFocus ,
HWND hWndDeviceFullScreen ,
HWND hWndDeviceWindowed ,
Boolean bHandleMessages = True 
)

/*
var

  nResult: LONG_PTR;
  strCachedWindowTitle: PWideChar;
  dwError: DWORD;
  hInstance: HINST;
*/
{
#ifndef DOXYGEN_SKIP

  if (z3DCore_GetState.GetInsideDeviceCallback) thenbegin    Result:= z3DErrorMessage('z3DSetWindow', E_FAIL);
    Exit;
 end
  z3DCore_GetState.SetWindowCreateCalled(True);
  if (hWndFocus = 0) or (hWndDeviceFullScreen = 0) or (hWndDeviceWindowed = 0) thenbegin    Result:= z3DErrorMessage('z3DSetWindow', E_INVALIDARG);
    Exit;
 end
  if (bHandleMessages) thenbegin  #ifdef  WIN64

    LONG_PTR nResult = SetWindowLongPtr(hWndFocus, GWLP_WNDPROC, (LONG_PTR)z3DStaticWndProc );
  #else

    nResult := SetWindowLong(hWndFocus, GWL_WNDPROC, Integer(@z3DCore_StaticWndProc));
  #endif


    dwError := GetLastError;
    if (nResult = 0) thenbegin      Result:= z3DErrorMessage('SetWindowLongPtr', HRESULT((dwError and $0000FFFF) or (FACILITY_WIN32 shl 16))); // HRESULT_FROM_WIN32(dwError));
      Exit;
   end
 end
  if (not z3DCore_GetState.Getz3DInited) thenbegin    if (z3DCore_GetState.Getz3DInitCalled) thenbegin      Result:= E_FAIL;
      Exit;
   end
    Result := z3DInit;
    if FAILED(Result) then Exit;
 end
  strCachedWindowTitle := z3DCore_GetState.WindowTitle;
  GetWindowTextW(hWndFocus, strCachedWindowTitle, 255);
  strCachedWindowTitle[255] := #0;
  #ifdef  WIN64

  hInstance := HINST(LONG_PTR(GetWindowLongPtr(hWndFocus, GWLP_HINSTANCE)));
  #else

  hInstance := HINST(LONG_PTR(GetWindowLong(hWndFocus, GWLP_HINSTANCE)));
  #endif

  z3DCore_GetState.HInstance := hInstance;
  z3DCore_GetState.WindowCreatedWithDefaultPositions := False;
  z3DCore_GetState.WindowCreated := True;
  z3DCore_GetState.SetHWNDFocus(hWndFocus);
  z3DCore_GetState.SetHWNDDeviceFullScreen(hWndDeviceFullScreen);
  z3DCore_GetState.SetHWNDDeviceWindowed(hWndDeviceWindowed);
  Result:= S_OK;
#endif /* DOXYGEN_SKIP */
};

                                                                                                                                 
HRESULT z3DCore_CreateDevice (LongWord AdapterOrdinal = D3DADAPTER_DEFAULT ,
Boolean bWindowed = True ,
Integer nSuggestedWidth = 0 ,
Integer nSuggestedHeight = 0 ,
Tz3DCallback_AcceptDevice pCallbackAcceptDevice = nil ,
Tz3DCallback_ModifyDeviceSettings pCallbackModifyDeviceSettings = nil ,
Pointer pUserContext = nil 
)

/*
var

  matchOptions: Tz3DMatchOptions;
  deviceSettings: Tz3DDeviceSettings;
*/
{
#ifndef DOXYGEN_SKIP

  if z3DCore_GetState.InsideDeviceCallback thenbegin    Result:= z3DErrorMessage('z3DCreateWindow', E_FAIL);
    Exit;
 end
  z3DCore_GetState.SetAcceptDeviceFunc(pCallbackAcceptDevice);
  z3DCore_GetState.SetModifyDeviceSettingsFunc(pCallbackModifyDeviceSettings);
  z3DCore_GetState.SetAcceptDeviceFuncUserContext(pUserContext);
  z3DCore_GetState.SetModifyDeviceSettingsFuncUserContext(pUserContext);
  z3DCore_GetState.DeviceCreateCalled:= True;
  if (not z3DCore_GetState.WindowCreated) thenbegin    if z3DCore_GetState.WindowCreateCalled thenbegin      Result:= E_FAIL;
      Exit;
   end
    Result := z3DCore_CreateWindow;
    if FAILED(Result) then Exit;
 end
  z3DPrepareDeviceListObject(True);
  matchOptions.eAdapterOrdinal     := z3DMT_PRESERVE_INPUT;
  matchOptions.eDeviceType         := z3DMT_IGNORE_INPUT;
  matchOptions.eWindowed           := z3DMT_PRESERVE_INPUT;
  matchOptions.eAdapterFormat      := z3DMT_IGNORE_INPUT;
  matchOptions.eVertexProcessing   := z3DMT_IGNORE_INPUT;
  if bWindowed or ((nSuggestedWidth <> 0) and (nSuggestedHeight <> 0))
    then matchOptions.eResolution  := z3DMT_CLOSEST_TO_INPUT
    else matchOptions.eResolution  := z3DMT_IGNORE_INPUT;
  matchOptions.eBackBufferFormat   := z3DMT_IGNORE_INPUT;
  matchOptions.eBackBufferCount    := z3DMT_IGNORE_INPUT;
  matchOptions.eMultiSample        := z3DMT_IGNORE_INPUT;
  matchOptions.eSwapEffect         := z3DMT_IGNORE_INPUT;
  matchOptions.eDepthFormat        := z3DMT_IGNORE_INPUT;
  matchOptions.eStencilFormat      := z3DMT_IGNORE_INPUT;
  matchOptions.ePresentFlags       := z3DMT_IGNORE_INPUT;
  matchOptions.eRefreshRate        := z3DMT_IGNORE_INPUT;
  matchOptions.ePresentInterval    := z3DMT_IGNORE_INPUT;

  ZeroMemory(@deviceSettings, SizeOf(Tz3DDeviceSettings));
  deviceSettings.AdapterOrdinal      := AdapterOrdinal;
  deviceSettings.PresentParams.Windowed         := bWindowed;
  deviceSettings.PresentParams.BackBufferWidth  := nSuggestedWidth;
  deviceSettings.PresentParams.BackBufferHeight := nSuggestedHeight;
  if (z3DCore_GetState.OverrideWidth <> 0)
  then deviceSettings.PresentParams.BackBufferWidth := z3DCore_GetState.OverrideWidth;
  if (z3DCore_GetState.OverrideHeight <> 0)
  then deviceSettings.PresentParams.BackBufferHeight := z3DCore_GetState.OverrideHeight;
  if (z3DCore_GetState.OverrideAdapterOrdinal <> -1)
  then deviceSettings.AdapterOrdinal := z3DCore_GetState.OverrideAdapterOrdinal;
  if (z3DCore_GetState.OverrideFullScreen) thenbegin    deviceSettings.PresentParams.Windowed := False;
    if (z3DCore_GetState.OverrideWidth = 0) and (z3DCore_GetState.OverrideHeight = 0)
    then matchOptions.eResolution := z3DMT_IGNORE_INPUT;
 end
  if (z3DCore_GetState.OverrideWindowed) then
    deviceSettings.PresentParams.Windowed := True;
  if (z3DCore_GetState.OverrideForceHAL) thenbegin    deviceSettings.DeviceType := D3DDEVTYPE_HAL;
    matchOptions.eDeviceType := z3DMT_PRESERVE_INPUT;
 end
  if (z3DCore_GetState.OverrideForceREF) thenbegin    deviceSettings.DeviceType := D3DDEVTYPE_REF;
    matchOptions.eDeviceType := z3DMT_PRESERVE_INPUT;
 end
  if (z3DCore_GetState.OverrideForcePureHWVP) thenbegin    deviceSettings.BehaviorFlags := D3DCREATE_HARDWARE_VERTEXPROCESSING or D3DCREATE_PUREDEVICE;
    matchOptions.eVertexProcessing := z3DMT_PRESERVE_INPUT;
 end  else if (z3DCore_GetState.OverrideForceHWVP) thenbegin    deviceSettings.BehaviorFlags := D3DCREATE_HARDWARE_VERTEXPROCESSING 
    matchOptions.eVertexProcessing := z3DMT_PRESERVE_INPUT;
 end  else if (z3DCore_GetState.OverrideForceSWVP) thenbegin    deviceSettings.BehaviorFlags := D3DCREATE_SOFTWARE_VERTEXPROCESSING 
    matchOptions.eVertexProcessing := z3DMT_PRESERVE_INPUT;
 end
  if (z3DCore_GetState.OverrideForceVsync = 0) thenbegin    deviceSettings.PresentParams.PresentationInterval := D3DPRESENT_INTERVAL_IMMEDIATE;
    matchOptions.ePresentInterval := z3DMT_PRESERVE_INPUT;
 end  else if (z3DCore_GetState.OverrideForceVsync = 1) thenbegin    deviceSettings.PresentParams.PresentationInterval := D3DPRESENT_INTERVAL_DEFAULT 
    matchOptions.ePresentInterval := z3DMT_PRESERVE_INPUT;
 end
  Result := z3DCore_FindValidDeviceSettings(deviceSettings, @deviceSettings, @matchOptions);
  if FAILED(Result) thenbegin    z3DDisplayErrorMessage(Result);
    Result:= z3DError('z3DFindValidDeviceSettings', Result);
    Exit;
 end
  Result := z3DChangeDevice(@deviceSettings, nil, False, True);
  if FAILED(Result) then Exit;
  Result:= S_OK;
#endif /* DOXYGEN_SKIP */
};

   
HRESULT z3DCore_SetDevice (IDirect3DDevice9 pd3dDevice 
)

/*
var

  pBackBuffer: IDirect3DSurface9;
  pSwapChain: IDirect3DSwapChain9;
  d3dCreationParams: TD3DDeviceCreationParameters;
  pDeviceSettings: Pz3DDeviceSettings;
*/
{
#ifndef DOXYGEN_SKIP

  if (pd3dDevice = nil) thenbegin    Result:= z3DErrorMessage('z3DSetDevice', E_INVALIDARG);
    Exit;
 end
  if (z3DCore_GetState.GetInsideDeviceCallback) thenbegin    Result:= z3DErrorMessage('z3DCreateWindow', E_FAIL);
    Exit;
 end
  z3DCore_GetState.DeviceCreateCalled:= True;
  if (not z3DCore_GetState.WindowCreated) thenbegin    if (z3DCore_GetState.WindowCreateCalled) thenbegin      Result:= E_FAIL;
      Exit;
   end
    Result := z3DCore_CreateWindow;
    if FAILED(Result) then Exit;
 end
  try
    New(pDeviceSettings);
  except
    Result:= E_OUTOFMEMORY;
    Exit;
 end
  ZeroMemory(pDeviceSettings, SizeOf(Tz3DDeviceSettings));
  Result := pd3dDevice.GetBackBuffer(0, 0, D3DBACKBUFFER_TYPE_MONO, pBackBuffer);
  if SUCCEEDED(Result) thenbegin    Result := pBackBuffer.GetContainer(IID_IDirect3DSwapChain9, Pointer(pSwapChain));
    if SUCCEEDED(Result) thenbegin      pSwapChain.GetPresentParameters(pDeviceSettings.PresentParams);
      SafeRelease(pSwapChain);
   end
    SafeRelease(pBackBuffer);
 end
  pd3dDevice.GetCreationParameters(d3dCreationParams);
  pDeviceSettings.AdapterOrdinal := d3dCreationParams.AdapterOrdinal;
  pDeviceSettings.DeviceType     := d3dCreationParams.DeviceType;
  z3DFindAdapterFormat(pDeviceSettings.AdapterOrdinal, pDeviceSettings.DeviceType,
                        pDeviceSettings.PresentParams.BackBufferFormat, pDeviceSettings.PresentParams.Windowed,
                        pDeviceSettings.AdapterFormat);
  pDeviceSettings.BehaviorFlags  := d3dCreationParams.BehaviorFlags;
  Result := z3DChangeDevice(pDeviceSettings, pd3dDevice, False, False);
  Dispose(pDeviceSettings);
  if FAILED(Result) then Exit;
  Result:= S_OK;
#endif /* DOXYGEN_SKIP */
};

           
HRESULT z3DCore_CreateDeviceFromSettings (Pz3DDeviceSettings pDeviceSettings ,
Boolean bPreserveInput = False ,
Boolean bClipWindowToSingleAdapter = True 
)

/*
var

  matchOptions: Tz3DMatchOptions;
*/
{
#ifndef DOXYGEN_SKIP

  z3DCore_GetState.SetDeviceCreateCalled(True);
  if not z3DCore_GetState.GetWindowCreated thenbegin    if (z3DCore_GetState.GetWindowCreateCalled) thenbegin      Result:= E_FAIL;
      Exit;
   end
    Result := z3DCore_CreateWindow;
    if FAILED(Result) then Exit;
 end
  if not bPreserveInput thenbegin    matchOptions.eAdapterOrdinal     := z3DMT_CLOSEST_TO_INPUT;
    matchOptions.eDeviceType         := z3DMT_CLOSEST_TO_INPUT;
    matchOptions.eWindowed           := z3DMT_CLOSEST_TO_INPUT;
    matchOptions.eAdapterFormat      := z3DMT_CLOSEST_TO_INPUT;
    matchOptions.eVertexProcessing   := z3DMT_CLOSEST_TO_INPUT;
    matchOptions.eResolution         := z3DMT_CLOSEST_TO_INPUT;
    matchOptions.eBackBufferFormat   := z3DMT_CLOSEST_TO_INPUT;
    matchOptions.eBackBufferCount    := z3DMT_CLOSEST_TO_INPUT;
    matchOptions.eMultiSample        := z3DMT_CLOSEST_TO_INPUT;
    matchOptions.eSwapEffect         := z3DMT_CLOSEST_TO_INPUT;
    matchOptions.eDepthFormat        := z3DMT_CLOSEST_TO_INPUT;
    matchOptions.eStencilFormat      := z3DMT_CLOSEST_TO_INPUT;
    matchOptions.ePresentFlags       := z3DMT_CLOSEST_TO_INPUT;
    matchOptions.eRefreshRate        := z3DMT_CLOSEST_TO_INPUT;
    matchOptions.ePresentInterval    := z3DMT_CLOSEST_TO_INPUT;

    Result := z3DCore_FindValidDeviceSettings(pDeviceSettings^, pDeviceSettings, @matchOptions);
    if FAILED(Result) thenbegin      z3DDisplayErrorMessage(Result);
      Result:= z3DError('z3DFindValidDeviceSettings', Result);
      Exit;
   end
 end
  Result := z3DChangeDevice(pDeviceSettings, nil, False, bClipWindowToSingleAdapter);
  if FAILED(Result) then Exit;
  Result:= S_OK;
#endif /* DOXYGEN_SKIP */
};

  
HRESULT z3DCore_ToggleFullScreen ()

/*
var

  deviceSettings: Tz3DDeviceSettings;
  matchOptions: Tz3DMatchOptions;
  nWidth: Integer;
  nHeight: Integer;
  hr2: HRESULT;
*/
{
#ifndef DOXYGEN_SKIP

  deviceSettings := z3DCore_GetDeviceSettings;
  deviceSettings.PresentParams.Windowed := not deviceSettings.PresentParams.Windowed;

  matchOptions.eAdapterOrdinal     := z3DMT_PRESERVE_INPUT;
  matchOptions.eDeviceType         := z3DMT_CLOSEST_TO_INPUT;
  matchOptions.eWindowed           := z3DMT_PRESERVE_INPUT;
  matchOptions.eAdapterFormat      := z3DMT_IGNORE_INPUT;
  matchOptions.eVertexProcessing   := z3DMT_CLOSEST_TO_INPUT;
  matchOptions.eBackBufferFormat   := z3DMT_IGNORE_INPUT;
  matchOptions.eBackBufferCount    := z3DMT_CLOSEST_TO_INPUT;
  matchOptions.eMultiSample        := z3DMT_CLOSEST_TO_INPUT;
  matchOptions.eSwapEffect         := z3DMT_CLOSEST_TO_INPUT;
  matchOptions.eDepthFormat        := z3DMT_CLOSEST_TO_INPUT;
  matchOptions.eStencilFormat      := z3DMT_CLOSEST_TO_INPUT;
  matchOptions.ePresentFlags       := z3DMT_CLOSEST_TO_INPUT;
  matchOptions.eRefreshRate        := z3DMT_IGNORE_INPUT;
  matchOptions.ePresentInterval    := z3DMT_CLOSEST_TO_INPUT;
  if deviceSettings.PresentParams.Windowed thenbegin    nWidth  := z3DCore_GetState.GetWindowBackBufferWidthAtModeChange;
    nHeight := z3DCore_GetState.GetWindowBackBufferHeightAtModeChange;
 endelsebegin    nWidth  := z3DCore_GetState.GetFullScreenBackBufferWidthAtModeChange 
    nHeight := z3DCore_GetState.GetFullScreenBackBufferHeightAtModeChange;
 end

  if (nWidth > 0) and (nHeight > 0) thenbegin    matchOptions.eResolution := z3DMT_CLOSEST_TO_INPUT;
    deviceSettings.PresentParams.BackBufferWidth := nWidth;
    deviceSettings.PresentParams.BackBufferHeight := nHeight;
 endelsebegin    matchOptions.eResolution := z3DMT_IGNORE_INPUT 
 end

  Result := z3DCore_FindValidDeviceSettings(deviceSettings, @deviceSettings, @matchOptions);
  if SUCCEEDED(Result) thenbegin    Result := z3DChangeDevice(@deviceSettings, nil, False, False);
    if FAILED(Result) and (Result <> E_ABORT) thenbegin      deviceSettings.PresentParams.Windowed := not deviceSettings.PresentParams.Windowed;
      if deviceSettings.PresentParams.Windowed thenbegin        nWidth  := z3DCore_GetState.GetWindowBackBufferWidthAtModeChange;
        nHeight := z3DCore_GetState.GetWindowBackBufferHeightAtModeChange;
     endelsebegin        nWidth  := z3DCore_GetState.GetFullScreenBackBufferWidthAtModeChange 
        nHeight := z3DCore_GetState.GetFullScreenBackBufferHeightAtModeChange;
     end
      if (nWidth > 0) and (nHeight > 0) thenbegin        matchOptions.eResolution := z3DMT_CLOSEST_TO_INPUT;
        deviceSettings.PresentParams.BackBufferWidth := nWidth;
        deviceSettings.PresentParams.BackBufferHeight := nHeight;
     endelse
        matchOptions.eResolution := z3DMT_IGNORE_INPUT 

      z3DCore_FindValidDeviceSettings(deviceSettings, @deviceSettings, @matchOptions);

      hr2 := z3DChangeDevice(@deviceSettings, nil, False, False);
      if FAILED(hr2) then
        z3DCore_Shutdown;
   end
 end
#endif /* DOXYGEN_SKIP */
};

  
HRESULT z3DCore_ToggleREF ()

/*
var

  deviceSettings: Tz3DDeviceSettings;
  matchOptions: Tz3DMatchOptions;
  hr2: HRESULT;
*/
{
#ifndef DOXYGEN_SKIP

  deviceSettings := z3DCore_GetDeviceSettings;
  if (deviceSettings.DeviceType = D3DDEVTYPE_HAL)
  then deviceSettings.DeviceType := D3DDEVTYPE_REF
  else if (deviceSettings.DeviceType = D3DDEVTYPE_REF)
  then deviceSettings.DeviceType := D3DDEVTYPE_HAL;

  matchOptions.eAdapterOrdinal     := z3DMT_PRESERVE_INPUT;
  matchOptions.eDeviceType         := z3DMT_PRESERVE_INPUT;
  matchOptions.eWindowed           := z3DMT_CLOSEST_TO_INPUT;
  matchOptions.eAdapterFormat      := z3DMT_CLOSEST_TO_INPUT;
  matchOptions.eVertexProcessing   := z3DMT_CLOSEST_TO_INPUT;
  matchOptions.eResolution         := z3DMT_CLOSEST_TO_INPUT;
  matchOptions.eBackBufferFormat   := z3DMT_CLOSEST_TO_INPUT;
  matchOptions.eBackBufferCount    := z3DMT_CLOSEST_TO_INPUT;
  matchOptions.eMultiSample        := z3DMT_CLOSEST_TO_INPUT;
  matchOptions.eSwapEffect         := z3DMT_CLOSEST_TO_INPUT;
  matchOptions.eDepthFormat        := z3DMT_CLOSEST_TO_INPUT;
  matchOptions.eStencilFormat      := z3DMT_CLOSEST_TO_INPUT;
  matchOptions.ePresentFlags       := z3DMT_CLOSEST_TO_INPUT;
  matchOptions.eRefreshRate        := z3DMT_CLOSEST_TO_INPUT;
  matchOptions.ePresentInterval    := z3DMT_CLOSEST_TO_INPUT;

  Result := z3DCore_FindValidDeviceSettings(deviceSettings, @deviceSettings, @matchOptions);
  if SUCCEEDED(Result) thenbegin    Result := z3DChangeDevice(@deviceSettings, nil, False, False);
    if FAILED(Result) and (Result <> E_ABORT) thenbegin      // Failed creating device, try to switch back.
      if (deviceSettings.DeviceType = D3DDEVTYPE_HAL) then deviceSettings.DeviceType := D3DDEVTYPE_REF
      else if (deviceSettings.DeviceType = D3DDEVTYPE_REF) then deviceSettings.DeviceType := D3DDEVTYPE_HAL;

      z3DCore_FindValidDeviceSettings(deviceSettings, @deviceSettings, @matchOptions);

      hr2 := z3DChangeDevice(@deviceSettings, nil, False, False);
      if FAILED(hr2) then
        z3DCore_Shutdown;
   end
 end
#endif /* DOXYGEN_SKIP */
};

     
Iz3DDeviceList z3DPrepareDeviceListObject (Boolean bEnumerate = False 
)

/*
var

  pd3dEnum: Iz3DDeviceList;
  pD3D: IDirect3D9;
*/
{
#ifndef DOXYGEN_SKIP

  // Create a new Tz3DDeviceList object and enumerate all devices unless its already been done
  pd3dEnum := z3DCore_GetState.z3DDeviceList;
  if (pd3dEnum = nil) thenbegin    pd3dEnum := z3DCore_GetDeviceList;
    z3DCore_GetState.SeTz3DDeviceList(pd3dEnum);

    bEnumerate := True;
 end
  if (bEnumerate) thenbegin    pD3D := z3DCore_GetD3DObject;
    pd3dEnum.Enumerate(pD3D, z3DCore_GetState.AcceptDeviceFunc, z3DCore_GetState.AcceptDeviceFuncUserContext);
 end

  Result:= pd3dEnum;
#endif /* DOXYGEN_SKIP */
};

             
HRESULT z3DCore_FindValidDeviceSettings (/* out */ Tz3DDeviceSettings &pOut ,
Pz3DDeviceSettings pIn = nil ,
Pz3DMatchOptions pMatchOptions = nil 
)

/*
var

  pd3dEnum: Iz3DDeviceList;
  pD3D: IDirect3D9;
  defaultMatchOptions: Tz3DMatchOptions;
  optimalDeviceSettings: Tz3DDeviceSettings;
  fBestRanking: Single;
  pBestDeviceSettingsCombo: PD3DDeviceSettingsCombinations;
  adapterDesktopDisplayMode: TD3DDisplayMode;
  pAdapterList: Tz3DEnumAdapterInfoArray;
  iAdapter: Integer;
  pAdapterInfo: Iz3DEnumAdapterInfo;
  iDeviceInfo: Integer;
  pDeviceInfo: Iz3DEnumDeviceInfo;
  iDeviceCombo: Integer;
  pDeviceSettingsCombo: PD3DDeviceSettingsCombinations;
  fCurRanking: Single;
  validDeviceSettings: Tz3DDeviceSettings;
*/
{
#ifndef DOXYGEN_SKIP

  pd3dEnum := z3DPrepareDeviceListObject(False);
  pD3D     := z3DCore_GetD3DObject;

  if (nil = pMatchOptions) thenbegin    ZeroMemory(@defaultMatchOptions, SizeOf(Tz3DMatchOptions));
    pMatchOptions := @defaultMatchOptions;
 end

  z3DBuildOptimalDeviceSettings(@optimalDeviceSettings, pIn, pMatchOptions);
  fBestRanking := -1.0;
  pBestDeviceSettingsCombo := nil;

  pAdapterList := pd3dEnum.GetAdapterInfoList;
  for iAdapter:= 0 to Length(pAdapterList) - 1 dobegin    pAdapterInfo := pAdapterList[iAdapter];

    pD3D.GetAdapterDisplayMode(pAdapterInfo.AdapterOrdinal, adapterDesktopDisplayMode);
    for iDeviceInfo:= 0 to Length(pAdapterInfo.deviceInfoList^) - 1 dobegin      pDeviceInfo := pAdapterInfo.deviceInfoList^[iDeviceInfo];
      for iDeviceCombo:= 0 to Length(pDeviceInfo.deviceSettingsComboList^) - 1 dobegin        pDeviceSettingsCombo := pDeviceInfo.deviceSettingsComboList^[iDeviceCombo];
        if pDeviceSettingsCombo.Windowed and (pDeviceSettingsCombo.AdapterFormat <> adapterDesktopDisplayMode.Format)
        then Continue;
        if not z3DDoesDeviceComboMatchPreserveOptions(pDeviceSettingsCombo, pIn, pMatchOptions)
        then Continue;
        fCurRanking := z3DRankDeviceCombo(pDeviceSettingsCombo, @optimalDeviceSettings, @adapterDesktopDisplayMode);
        if (fCurRanking > fBestRanking) thenbegin          pBestDeviceSettingsCombo := pDeviceSettingsCombo;
          fBestRanking := fCurRanking;
       end
     end
   end
 end
  if (pBestDeviceSettingsCombo = nil) thenbegin    Result:= z3DERR_NOCOMPATIBLEDEVICES;
    Exit;
 end
  z3DBuildValidDeviceSettings(validDeviceSettings, pBestDeviceSettingsCombo^, pIn, pMatchOptions);
  pOut := validDeviceSettings;
  Result:= S_OK;
#endif /* DOXYGEN_SKIP */
};

       
z3DBuildOptimalDeviceSettings (Pz3DDeviceSettings pOptimalDeviceSettings ,
Pz3DDeviceSettings pDeviceSettingsIn ,
Pz3DMatchOptions pMatchOptions 
)

/*
var

  pD3D: IDirect3D9;
  adapterDesktopDisplayMode: TD3DDisplayMode;
  nBackBufferBits: LongWord;
*/
{
#ifndef DOXYGEN_SKIP

  pD3D := z3DCore_GetD3DObject;

  ZeroMemory(pOptimalDeviceSettings, SizeOf(Tz3DDeviceSettings));

  //---------------------
  // Adapter ordinal
  //---------------------
  if (pMatchOptions.eAdapterOrdinal = z3DMT_IGNORE_INPUT)
  then pOptimalDeviceSettings.AdapterOrdinal := D3DADAPTER_DEFAULT
  else pOptimalDeviceSettings.AdapterOrdinal := pDeviceSettingsIn.AdapterOrdinal;

  //---------------------
  // Device type
  //---------------------
  if (pMatchOptions.eDeviceType = z3DMT_IGNORE_INPUT)
  then pOptimalDeviceSettings.DeviceType := D3DDEVTYPE_HAL
  else pOptimalDeviceSettings.DeviceType := pDeviceSettingsIn.DeviceType;

  //---------------------
  // Windowed
  //---------------------
  if (pMatchOptions.eWindowed = z3DMT_IGNORE_INPUT)
  then pOptimalDeviceSettings.PresentParams.Windowed := True
  else pOptimalDeviceSettings.PresentParams.Windowed := pDeviceSettingsIn.PresentParams.Windowed;

  //---------------------
  // Adapter format
  //---------------------
  if (pMatchOptions.eAdapterFormat = z3DMT_IGNORE_INPUT) thenbegin    pD3D.GetAdapterDisplayMode(pOptimalDeviceSettings.AdapterOrdinal, adapterDesktopDisplayMode);
    if pOptimalDeviceSettings.PresentParams.Windowed or (z3DCore_GetColorChannelBits(adapterDesktopDisplayMode.Format) >= 8)
    then pOptimalDeviceSettings.AdapterFormat := adapterDesktopDisplayMode.Format
    else pOptimalDeviceSettings.AdapterFormat := D3DFMT_X8R8G8B8;
 endelsebegin    pOptimalDeviceSettings.AdapterFormat := pDeviceSettingsIn.AdapterFormat 
 end

  //---------------------
  // Vertex processing
  //---------------------
  if (pMatchOptions.eVertexProcessing = z3DMT_IGNORE_INPUT)
  then pOptimalDeviceSettings.BehaviorFlags := D3DCREATE_HARDWARE_VERTEXPROCESSING
  else pOptimalDeviceSettings.BehaviorFlags := pDeviceSettingsIn.BehaviorFlags;

  //---------------------
  // Resolution
  //---------------------
  if (pMatchOptions.eResolution = z3DMT_IGNORE_INPUT) thenbegin    if pOptimalDeviceSettings.PresentParams.Windowed thenbegin      pOptimalDeviceSettings.PresentParams.BackBufferWidth := 640;
      pOptimalDeviceSettings.PresentParams.BackBufferHeight := 480;
   endelsebegin      pD3D.GetAdapterDisplayMode( pOptimalDeviceSettings.AdapterOrdinal, adapterDesktopDisplayMode) 
      pOptimalDeviceSettings.PresentParams.BackBufferWidth := adapterDesktopDisplayMode.Width;
      pOptimalDeviceSettings.PresentParams.BackBufferHeight := adapterDesktopDisplayMode.Height;
   end
 endelsebegin    pOptimalDeviceSettings.PresentParams.BackBufferWidth := pDeviceSettingsIn.PresentParams.BackBufferWidth 
    pOptimalDeviceSettings.PresentParams.BackBufferHeight := pDeviceSettingsIn.PresentParams.BackBufferHeight;
 end

  //---------------------
  // Back buffer format
  //---------------------
  if (pMatchOptions.eBackBufferFormat = z3DMT_IGNORE_INPUT)
  then pOptimalDeviceSettings.PresentParams.BackBufferFormat := pOptimalDeviceSettings.AdapterFormat // Default to match the adapter format
  else pOptimalDeviceSettings.PresentParams.BackBufferFormat := pDeviceSettingsIn.PresentParams.BackBufferFormat;

  //---------------------
  // Back buffer count
  //---------------------
  if (pMatchOptions.eBackBufferCount = z3DMT_IGNORE_INPUT)
  then pOptimalDeviceSettings.PresentParams.BackBufferCount := 2 // Default to triple buffering for perf gain
  else pOptimalDeviceSettings.PresentParams.BackBufferCount := pDeviceSettingsIn.PresentParams.BackBufferCount;

  //---------------------
  // Multisample
  //---------------------
  if (pMatchOptions.eMultiSample = z3DMT_IGNORE_INPUT) thenbegin    // Default to no multisampling
    pOptimalDeviceSettings.PresentParams.MultiSampleType := D3DMULTISAMPLE_NONE;
    pOptimalDeviceSettings.PresentParams.MultiSampleQuality := 0;
 endelsebegin    pOptimalDeviceSettings.PresentParams.MultiSampleType := pDeviceSettingsIn.PresentParams.MultiSampleType 
    pOptimalDeviceSettings.PresentParams.MultiSampleQuality := pDeviceSettingsIn.PresentParams.MultiSampleQuality;
 end

  //---------------------
  // Swap effect
  //---------------------
  if (pMatchOptions.eSwapEffect = z3DMT_IGNORE_INPUT)
  then pOptimalDeviceSettings.PresentParams.SwapEffect := D3DSWAPEFFECT_DISCARD
  else pOptimalDeviceSettings.PresentParams.SwapEffect := pDeviceSettingsIn.PresentParams.SwapEffect;

  //---------------------
  // Depth stencil
  //---------------------
  if (pMatchOptions.eDepthFormat = z3DMT_IGNORE_INPUT) and
     (pMatchOptions.eStencilFormat = z3DMT_IGNORE_INPUT) thenbegin    nBackBufferBits := z3DCore_GetColorChannelBits(pOptimalDeviceSettings.PresentParams.BackBufferFormat);
    if (nBackBufferBits >= 8)
    then pOptimalDeviceSettings.PresentParams.AutoDepthStencilFormat := D3DFMT_D32
    else pOptimalDeviceSettings.PresentParams.AutoDepthStencilFormat := D3DFMT_D16;
 endelsebegin    pOptimalDeviceSettings.PresentParams.AutoDepthStencilFormat := pDeviceSettingsIn.PresentParams.AutoDepthStencilFormat 
 end

  //---------------------
  // Present flags
  //---------------------
  if (pMatchOptions.ePresentFlags = z3DMT_IGNORE_INPUT)
  then pOptimalDeviceSettings.PresentParams.Flags := D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL
  else pOptimalDeviceSettings.PresentParams.Flags := pDeviceSettingsIn.PresentParams.Flags;

  //---------------------
  // Refresh rate
  //---------------------
  if (pMatchOptions.eRefreshRate = z3DMT_IGNORE_INPUT)
  then pOptimalDeviceSettings.PresentParams.FullScreen_RefreshRateInHz := 0
  else pOptimalDeviceSettings.PresentParams.FullScreen_RefreshRateInHz := pDeviceSettingsIn.PresentParams.FullScreen_RefreshRateInHz;

  //---------------------
  // Present interval
  //---------------------
  if (pMatchOptions.ePresentInterval = z3DMT_IGNORE_INPUT) thenbegin    pOptimalDeviceSettings.PresentParams.PresentationInterval := D3DPRESENT_INTERVAL_DEFAULT;
 endelsebegin    pOptimalDeviceSettings.PresentParams.PresentationInterval := pDeviceSettingsIn.PresentParams.PresentationInterval 
 end
#endif /* DOXYGEN_SKIP */
};

        
Boolean z3DDoesDeviceComboMatchPreserveOptions (PD3DDeviceSettingsCombinations pDeviceSettingsCombo ,
Pz3DDeviceSettings pDeviceSettingsIn ,
Pz3DMatchOptions pMatchOptions 
)

/*
var

  bFound: Boolean;
  i: Integer;
  displayMode: TD3DDisplayMode;
  msType: TD3DMultiSampleType;
  msQuality: DWORD;
  dwDepthBits: LongWord;
  depthStencilFmt: TD3DFormat;
  dwCurDepthBits: LongWord;
  dwStencilBits: LongWord;
  dwCurStencilBits: LongWord;
*/
{
#ifndef DOXYGEN_SKIP

  Result:= False;

  //---------------------
  // Adapter ordinal
  //---------------------
  if (pMatchOptions.eAdapterOrdinal = z3DMT_PRESERVE_INPUT) and
     (pDeviceSettingsCombo.AdapterOrdinal <> pDeviceSettingsIn.AdapterOrdinal)
  then Exit;

  //---------------------
  // Device type
  //---------------------
  if (pMatchOptions.eDeviceType = z3DMT_PRESERVE_INPUT) and
     (pDeviceSettingsCombo.DeviceType <> pDeviceSettingsIn.DeviceType)
  then Exit;

  //---------------------
  // Windowed
  //---------------------
  if (pMatchOptions.eWindowed = z3DMT_PRESERVE_INPUT) and
     (pDeviceSettingsCombo.Windowed <> pDeviceSettingsIn.PresentParams.Windowed)
  then Exit;

  //---------------------
  // Adapter format
  //---------------------
  if (pMatchOptions.eAdapterFormat = z3DMT_PRESERVE_INPUT) and
     (pDeviceSettingsCombo.AdapterFormat <> pDeviceSettingsIn.AdapterFormat)
  then Exit;

  //---------------------
  // Vertex processing
  //---------------------
  if (pMatchOptions.eVertexProcessing = z3DMT_PRESERVE_INPUT) and
     ((pDeviceSettingsIn.BehaviorFlags and D3DCREATE_HARDWARE_VERTEXPROCESSING) <> 0) and
     ((pDeviceSettingsCombo.DeviceInfo.Caps.DevCaps and D3DDEVCAPS_HWTRANSFORMANDLIGHT) = 0)
  then Exit;

  //---------------------
  // Resolution
  //---------------------
  if (pMatchOptions.eResolution = z3DMT_PRESERVE_INPUT) thenbegin    bFound := False;
    for i:= 0 to Length(pDeviceSettingsCombo.AdapterInfo.displayModeList^) - 1 dobegin      displayMode := pDeviceSettingsCombo.AdapterInfo.displayModeList^[i];
      if (displayMode.Format <> pDeviceSettingsCombo.AdapterFormat)
      then Continue; // Skip this display mode if it doesn't match the combo's adapter format

      if (displayMode.Width = pDeviceSettingsIn.PresentParams.BackBufferWidth) and
         (displayMode.Height = pDeviceSettingsIn.PresentParams.BackBufferHeight) thenbegin        bFound := True;
        Break;
     end
   end

    if (not bFound) then Exit;
 end

  //---------------------
  // Back buffer format
  //---------------------
  if (pMatchOptions.eBackBufferFormat = z3DMT_PRESERVE_INPUT) and
     (pDeviceSettingsCombo.BackBufferFormat <> pDeviceSettingsIn.PresentParams.BackBufferFormat)
  then Exit;

  //---------------------
  // Back buffer count
  //---------------------
  // No caps for the back buffer count

  //---------------------
  // Multisample
  //---------------------
  if (pMatchOptions.eMultiSample = z3DMT_PRESERVE_INPUT) thenbegin    bFound := false;
    for i:= 0 to Length(pDeviceSettingsCombo.multiSampleTypeList) - 1 dobegin      msType := pDeviceSettingsCombo.multiSampleTypeList[i];
      msQuality  := pDeviceSettingsCombo.multiSampleQualityList[i];

      if (msType = pDeviceSettingsIn.PresentParams.MultiSampleType) and
         (msQuality >= pDeviceSettingsIn.PresentParams.MultiSampleQuality) thenbegin        bFound := True;
        Break;
     end
   end

    // If multisample type/quality not supported by this combo, then return false
    if not bFound then Exit;
 end

  //---------------------
  // Swap effect
  //---------------------
  // No caps for swap effects

  //---------------------
  // Depth stencil
  //---------------------
  // If keep depth stencil format then check that the depth stencil format is supported by this combo
  if (pMatchOptions.eDepthFormat = z3DMT_PRESERVE_INPUT) and
     (pMatchOptions.eStencilFormat = z3DMT_PRESERVE_INPUT) thenbegin    if (pDeviceSettingsIn.PresentParams.AutoDepthStencilFormat <> D3DFMT_UNKNOWN) and
       not DynArrayContains(pDeviceSettingsCombo.depthStencilFormatList,
                            pDeviceSettingsIn.PresentParams.AutoDepthStencilFormat,
                            SizeOf(pDeviceSettingsIn.PresentParams.AutoDepthStencilFormat))
    then Exit;
 end

  // If keep depth format then check that the depth format is supported by this combo
  if (pMatchOptions.eDepthFormat = z3DMT_PRESERVE_INPUT) and
     (pDeviceSettingsIn.PresentParams.AutoDepthStencilFormat <> D3DFMT_UNKNOWN) thenbegin    bFound := False;
    dwDepthBits := z3DCore_GetDepthBits(pDeviceSettingsIn.PresentParams.AutoDepthStencilFormat);
    for i:= 0 to Length(pDeviceSettingsCombo.depthStencilFormatList) - 1 dobegin      depthStencilFmt := pDeviceSettingsCombo.depthStencilFormatList[i];
      dwCurDepthBits := z3DCore_GetDepthBits(depthStencilFmt);
      if (dwCurDepthBits - dwDepthBits = 0) then bFound := True;
   end

    if not bFound then Exit;
 end

  // If keep depth format then check that the depth format is supported by this combo
  if (pMatchOptions.eStencilFormat = z3DMT_PRESERVE_INPUT) and
     (pDeviceSettingsIn.PresentParams.AutoDepthStencilFormat <> D3DFMT_UNKNOWN) thenbegin    bFound := False;
    dwStencilBits := z3DCore_GetStencilBits(pDeviceSettingsIn.PresentParams.AutoDepthStencilFormat);
    for i:= 0 to Length(pDeviceSettingsCombo.depthStencilFormatList) - 1 dobegin      depthStencilFmt := pDeviceSettingsCombo.depthStencilFormatList[i];
      dwCurStencilBits := z3DCore_GetStencilBits(depthStencilFmt);
      if (dwCurStencilBits - dwStencilBits = 0) then bFound := True;
   end

    if not bFound then Exit;
 end

  //---------------------
  // Present flags
  //---------------------
  // No caps for the present flags

  //---------------------
  // Refresh rate
  //---------------------
  // If keep refresh rate then check that the resolution is supported by this combo
  if (pMatchOptions.eRefreshRate = z3DMT_PRESERVE_INPUT) thenbegin    bFound := false;
    for i:= 0 to Length(pDeviceSettingsCombo.AdapterInfo.displayModeList^) - 1 dobegin      displayMode := pDeviceSettingsCombo.AdapterInfo.displayModeList^[i];
      if (displayMode.Format <> pDeviceSettingsCombo.AdapterFormat) then Continue;
      if (displayMode.RefreshRate = pDeviceSettingsIn.PresentParams.FullScreen_RefreshRateInHz) thenbegin        bFound := True;
        Break;
     end
   end

    // If refresh rate not supported by this combo, then return false
    if not bFound then Exit;
 end

  //---------------------
  // Present interval
  //---------------------
  // If keep present interval then check that the present interval is supported by this combo
  if (pMatchOptions.ePresentInterval = z3DMT_PRESERVE_INPUT) and
     not DynArrayContains(pDeviceSettingsCombo.presentIntervalList,
                          pDeviceSettingsIn.PresentParams.PresentationInterval,
                          SizeOf(pDeviceSettingsIn.PresentParams.PresentationInterval))
  then Exit;

  Result:= True;
#endif /* DOXYGEN_SKIP */
};

        
Single z3DRankDeviceCombo (PD3DDeviceSettingsCombinations pDeviceSettingsCombo ,
Pz3DDeviceSettings pOptimalDeviceSettings ,
PD3DDisplayMode pAdapterDesktopDisplayMode 
)

/*
//const

  fAdapterOrdinalWeight   = 1000.0;
  fDeviceTypeWeight       = 100.0;
  fWindowWeight           = 10.0;
  fAdapterFormatWeight    = 1.0;
  fVertexProcessingWeight = 1.0;
  fResolutionWeight       = 1.0;
  fBackBufferFormatWeight = 1.0;
  fMultiSampleWeight      = 1.0;
  fDepthStencilWeight     = 1.0;
  fRefreshRateWeight      = 1.0;
  fPresentIntervalWeight  = 1.0;
var
  fCurRanking: Single;
  nBitDepthDelta: Integer;
  fScale: Single;
  bAdapterOptimalMatch: Boolean;
  bResolutionFound: Boolean;
  idm: Integer;
  displayMode: TD3DDisplayMode;
  bAdapterMatchesBB: Boolean;
  bMultiSampleFound: Boolean;
  i: Integer;
  msType: TD3DMultiSampleType;
  msQuality: DWORD;
  bRefreshFound: Boolean;
*/
{
#ifndef DOXYGEN_SKIP

  fCurRanking := 0.0;

  //---------------------
  // Adapter ordinal
  //---------------------
  if (pDeviceSettingsCombo.AdapterOrdinal = pOptimalDeviceSettings.AdapterOrdinal)
  then fCurRanking := fCurRanking + fAdapterOrdinalWeight;

  //---------------------
  // Device type
  //---------------------
  if (pDeviceSettingsCombo.DeviceType = pOptimalDeviceSettings.DeviceType)
  then fCurRanking := fCurRanking + fDeviceTypeWeight;
  // Slightly prefer HAL
  if (pDeviceSettingsCombo.DeviceType = D3DDEVTYPE_HAL)
  then fCurRanking := fCurRanking + 0.1;

  //---------------------
  // Windowed
  //---------------------
  if (pDeviceSettingsCombo.Windowed = pOptimalDeviceSettings.PresentParams.Windowed )
  then fCurRanking := fCurRanking + fWindowWeight;

  //---------------------
  // Adapter format
  //---------------------
  if (pDeviceSettingsCombo.AdapterFormat = pOptimalDeviceSettings.AdapterFormat) thenbegin    fCurRanking := fCurRanking + fAdapterFormatWeight;
 endelsebegin    nBitDepthDelta := Abs(z3DCore_GetColorChannelBits(pDeviceSettingsCombo.AdapterFormat) -
                          z3DCore_GetColorChannelBits(pOptimalDeviceSettings.AdapterFormat)) 
    fScale := Max(0.9 - nBitDepthDelta*0.2, 0);
    fCurRanking := fCurRanking + fScale * fAdapterFormatWeight;
 end

  if (not pDeviceSettingsCombo.Windowed) thenbegin    if (z3DCore_GetColorChannelBits(pAdapterDesktopDisplayMode.Format) >= 8)
    then bAdapterOptimalMatch := (pDeviceSettingsCombo.AdapterFormat = pAdapterDesktopDisplayMode.Format)
    else bAdapterOptimalMatch := (pDeviceSettingsCombo.AdapterFormat = D3DFMT_X8R8G8B8);

    if (bAdapterOptimalMatch) then fCurRanking := fCurRanking + 0.1;
 end

  //---------------------
  // Vertex processing
  //---------------------
  if ((pOptimalDeviceSettings.BehaviorFlags and D3DCREATE_HARDWARE_VERTEXPROCESSING) <> 0) or
     ((pOptimalDeviceSettings.BehaviorFlags and D3DCREATE_MIXED_VERTEXPROCESSING) <> 0) thenbegin    if ((pDeviceSettingsCombo.DeviceInfo.Caps.DevCaps and D3DDEVCAPS_HWTRANSFORMANDLIGHT) <> 0)
    then fCurRanking := fCurRanking + fVertexProcessingWeight;
 end
  // Slightly prefer HW T&L
  if ((pDeviceSettingsCombo.DeviceInfo.Caps.DevCaps and D3DDEVCAPS_HWTRANSFORMANDLIGHT) <> 0)
  then fCurRanking := fCurRanking + 0.1;

  //---------------------
  // Resolution
  //---------------------
  bResolutionFound := False;
  for idm := 0 to Length(pDeviceSettingsCombo.AdapterInfo.displayModeList^) - 1 dobegin    displayMode := pDeviceSettingsCombo.AdapterInfo.displayModeList^[idm];
    if (displayMode.Format <> pDeviceSettingsCombo.AdapterFormat) then Continue;

    if (displayMode.Width = pOptimalDeviceSettings.PresentParams.BackBufferWidth) and
       (displayMode.Height = pOptimalDeviceSettings.PresentParams.BackBufferHeight)
    then bResolutionFound := True;
 end
  if (bResolutionFound) then fCurRanking := fCurRanking + fResolutionWeight;

  //---------------------
  // Back buffer format
  //---------------------
  if (pDeviceSettingsCombo.BackBufferFormat = pOptimalDeviceSettings.PresentParams.BackBufferFormat) thenbegin    fCurRanking := fCurRanking + fBackBufferFormatWeight;
 endelsebegin    nBitDepthDelta := Abs(z3DCore_GetColorChannelBits(pDeviceSettingsCombo.BackBufferFormat) -
                          z3DCore_GetColorChannelBits(pOptimalDeviceSettings.PresentParams.BackBufferFormat)) 
    fScale := Max(0.9 - nBitDepthDelta*0.2, 0);
    fCurRanking := fCurRanking + fScale * fBackBufferFormatWeight;
 end

  // Check if this back buffer format is the same as
  // the adapter format since this is preferred.
  bAdapterMatchesBB := (pDeviceSettingsCombo.BackBufferFormat = pDeviceSettingsCombo.AdapterFormat);
  if bAdapterMatchesBB then fCurRanking := fCurRanking + 0.1;

  //---------------------
  // Back buffer count
  //---------------------
  // No caps for the back buffer count

  //---------------------
  // Multisample
  //---------------------
  bMultiSampleFound := False;
  for i:= 0 to Length(pDeviceSettingsCombo.multiSampleTypeList) - 1 dobegin    msType := pDeviceSettingsCombo.multiSampleTypeList[i];
    msQuality  := pDeviceSettingsCombo.multiSampleQualityList[i];

    if (msType = pOptimalDeviceSettings.PresentParams.MultiSampleType) and
       (msQuality >= pOptimalDeviceSettings.PresentParams.MultiSampleQuality) thenbegin      bMultiSampleFound := True;
      Break;
   end
 end
  if bMultiSampleFound then fCurRanking := fCurRanking + fMultiSampleWeight;

  //---------------------
  // Swap effect
  //---------------------
  // No caps for swap effects

  //---------------------
  // Depth stencil
  //---------------------
  if DynArrayContains(pDeviceSettingsCombo.depthStencilFormatList,
                      pOptimalDeviceSettings.PresentParams.AutoDepthStencilFormat,
                      SizeOf(pOptimalDeviceSettings.PresentParams.AutoDepthStencilFormat))
  then fCurRanking := fCurRanking + fDepthStencilWeight;

  //---------------------
  // Present flags
  //---------------------
  // No caps for the present flags

  //---------------------
  // Refresh rate
  //---------------------
  bRefreshFound := False;
  for idm := 0 to Length(pDeviceSettingsCombo.AdapterInfo.displayModeList^) - 1 dobegin    displayMode := pDeviceSettingsCombo.AdapterInfo.displayModeList^[idm];
    if (displayMode.Format <> pDeviceSettingsCombo.AdapterFormat) then Continue;

    if (displayMode.RefreshRate = pOptimalDeviceSettings.PresentParams.FullScreen_RefreshRateInHz)
    then bRefreshFound := True;
 end
  if bRefreshFound then fCurRanking := fCurRanking + fRefreshRateWeight;

  //---------------------
  // Present interval
  //---------------------
  if DynArrayContains(pDeviceSettingsCombo.presentIntervalList,
                      pOptimalDeviceSettings.PresentParams.PresentationInterval,
                      SizeOf(pOptimalDeviceSettings.PresentParams.PresentationInterval))
  then fCurRanking := fCurRanking + fPresentIntervalWeight;

  Result:= fCurRanking;
#endif /* DOXYGEN_SKIP */
};

            
z3DBuildValidDeviceSettings (/* out */ Tz3DDeviceSettings &pValidDeviceSettings ,
const TD3DDeviceSettingsCombinations pBestDeviceSettingsCombo ,
Pz3DDeviceSettings pDeviceSettingsIn ,
Pz3DMatchOptions pMatchOptions 
)

/*
var

  pD3D: IDirect3D9;
  adapterDesktopDisplayMode: TD3DDisplayMode;
  dwBestBehaviorFlags: DWORD;
  bestDisplayMode: TD3DDisplayMode;
  displayModeIn: TD3DDisplayMode;
  bestBackBufferCount: LongWord;
  bestMultiSampleType: TD3DMultiSampleType;
  bestMultiSampleQuality: DWORD;
  i: Integer;
  bestSwapEffect: TD3DSwapEffect;
  bestDepthStencilFormat: TD3DFormat;
  bestEnableAutoDepthStencil: Boolean;
  depthStencilRanking: array of Integer;
  dwBackBufferBitDepth: LongWord;
  dwInputDepthBitDepth: LongWord;
  curDepthStencilFmt: TD3DFormat;
  dwCurDepthBitDepth: DWORD;
  nRanking: Integer;
  l: Integer;
  dwInputStencilBitDepth: LongWord;
  dwCurStencilBitDepth: DWORD;
  nBestRanking: Integer;
  nBestIndex: Integer;
  dwBestFlags: DWORD;
  refreshRateMatch: LongWord;
  nBestRefreshRanking: Integer;
  pDisplayModeList: TD3DDisplayModeArray;
  iDisplayMode: Integer;
  displayMode: TD3DDisplayMode;
  nCurRanking: Integer;
  bestPresentInterval: LongWord;
  type_: TD3DMultiSampleType;
  qualityLevels: DWORD;
*/
{
#ifndef DOXYGEN_SKIP

  pDisplayModeList := nil;
  pD3D := z3DCore_GetD3DObject;
  pD3D.GetAdapterDisplayMode(pBestDeviceSettingsCombo.AdapterOrdinal, adapterDesktopDisplayMode);

  //---------------------
  // Vertex processing
  //---------------------
  dwBestBehaviorFlags := 0;
  if (pMatchOptions.eVertexProcessing = z3DMT_PRESERVE_INPUT) thenbegin    dwBestBehaviorFlags := pDeviceSettingsIn.BehaviorFlags;
 end  else if (pMatchOptions.eVertexProcessing = z3DMT_IGNORE_INPUT) thenbegin    if ((pBestDeviceSettingsCombo.DeviceInfo.Caps.DevCaps and D3DDEVCAPS_HWTRANSFORMANDLIGHT) <> 0)
    then dwBestBehaviorFlags := dwBestBehaviorFlags or D3DCREATE_HARDWARE_VERTEXPROCESSING
    else dwBestBehaviorFlags := dwBestBehaviorFlags or D3DCREATE_SOFTWARE_VERTEXPROCESSING 
 end  elsebegin    // Default to input, and fallback to SWVP if HWVP not available
    dwBestBehaviorFlags := pDeviceSettingsIn.BehaviorFlags 
    if ((pBestDeviceSettingsCombo.DeviceInfo.Caps.DevCaps and D3DDEVCAPS_HWTRANSFORMANDLIGHT) = 0) and
       (((dwBestBehaviorFlags and D3DCREATE_HARDWARE_VERTEXPROCESSING) <> 0) or
        ((dwBestBehaviorFlags and D3DCREATE_MIXED_VERTEXPROCESSING) <> 0)) thenbegin      dwBestBehaviorFlags := dwBestBehaviorFlags and not D3DCREATE_HARDWARE_VERTEXPROCESSING;
      dwBestBehaviorFlags := dwBestBehaviorFlags and not D3DCREATE_MIXED_VERTEXPROCESSING;
      dwBestBehaviorFlags := dwBestBehaviorFlags or D3DCREATE_SOFTWARE_VERTEXPROCESSING;
   end

    // One of these must be selected
    if ((dwBestBehaviorFlags and D3DCREATE_HARDWARE_VERTEXPROCESSING) = 0) and
       ((dwBestBehaviorFlags and D3DCREATE_MIXED_VERTEXPROCESSING) = 0) and
       ((dwBestBehaviorFlags and D3DCREATE_SOFTWARE_VERTEXPROCESSING) = 0) thenbegin      if ((pBestDeviceSettingsCombo.DeviceInfo.Caps.DevCaps and D3DDEVCAPS_HWTRANSFORMANDLIGHT) <> 0)
      then dwBestBehaviorFlags := dwBestBehaviorFlags or D3DCREATE_HARDWARE_VERTEXPROCESSING
      else dwBestBehaviorFlags := dwBestBehaviorFlags or D3DCREATE_SOFTWARE_VERTEXPROCESSING;
   end
 end

  //---------------------
  // Resolution
  //---------------------
  if (pMatchOptions.eResolution = z3DMT_PRESERVE_INPUT) thenbegin    bestDisplayMode.Width := pDeviceSettingsIn.PresentParams.BackBufferWidth;
    bestDisplayMode.Height := pDeviceSettingsIn.PresentParams.BackBufferHeight;
 endelsebegin    if (pMatchOptions.eResolution = z3DMT_CLOSEST_TO_INPUT) and
       (pDeviceSettingsIn <> nil) thenbegin      displayModeIn.Width := pDeviceSettingsIn.PresentParams.BackBufferWidth 
      displayModeIn.Height := pDeviceSettingsIn.PresentParams.BackBufferHeight;
   end    elsebegin      if pBestDeviceSettingsCombo.Windowed thenbegin        displayModeIn.Width := 640 
        displayModeIn.Height := 480;
     endelsebegin        displayModeIn.Width := adapterDesktopDisplayMode.Width 
        displayModeIn.Height := adapterDesktopDisplayMode.Height;
     end
   end

    // Call a helper function to find the closest valid display mode to the optimal
    z3DFindValidResolution(pBestDeviceSettingsCombo, displayModeIn, bestDisplayMode);
 end

  //---------------------
  // Back Buffer Format
  //---------------------
  // Just using pBestDeviceSettingsCombo->BackBufferFormat

  //---------------------
  // Back buffer count
  //---------------------
  if (pMatchOptions.eBackBufferCount = z3DMT_PRESERVE_INPUT) thenbegin    bestBackBufferCount := pDeviceSettingsIn.PresentParams.BackBufferCount;
 end  else if (pMatchOptions.eBackBufferCount = z3DMT_IGNORE_INPUT) thenbegin    bestBackBufferCount := 2 
 end  else // if( pMatchOptions->eBackBufferCount == z3DMT_CLOSEST_TO_INPUT )begin    bestBackBufferCount := pDeviceSettingsIn.PresentParams.BackBufferCount 
    if (bestBackBufferCount > 3) then bestBackBufferCount := 3;
    if (bestBackBufferCount < 1) then bestBackBufferCount := 1;
 end

  //---------------------
  // Multisample
  //---------------------
  if (pDeviceSettingsIn <> nil) and (pDeviceSettingsIn.PresentParams.SwapEffect <> D3DSWAPEFFECT_DISCARD) thenbegin    // Swap effect is not set to discard so multisampling has to off
    bestMultiSampleType := D3DMULTISAMPLE_NONE;
    bestMultiSampleQuality := 0;
 endelsebegin    if (pMatchOptions.eMultiSample = z3DMT_PRESERVE_INPUT) thenbegin      bestMultiSampleType    := pDeviceSettingsIn.PresentParams.MultiSampleType 
      bestMultiSampleQuality := pDeviceSettingsIn.PresentParams.MultiSampleQuality;
   end    else if (pMatchOptions.eMultiSample = z3DMT_IGNORE_INPUT) thenbegin      // Default to no multisampling (always supported)
      bestMultiSampleType := D3DMULTISAMPLE_NONE 
      bestMultiSampleQuality := 0;
   end    else if (pMatchOptions.eMultiSample = z3DMT_CLOSEST_TO_INPUT) thenbegin      // Default to no multisampling (always supported)
      bestMultiSampleType := D3DMULTISAMPLE_NONE 
      bestMultiSampleQuality := 0;

      for i := 0 to Length(pBestDeviceSettingsCombo.multiSampleTypeList) - 1 dobegin        type_ := pBestDeviceSettingsCombo.multiSampleTypeList[i];
        qualityLevels := pBestDeviceSettingsCombo.multiSampleQualityList[i];

        // Check whether supported type is closer to the input than our current best
        if (Abs(Ord(type_) - Ord(pDeviceSettingsIn.PresentParams.MultiSampleType)) <
              Abs(Ord(bestMultiSampleType) - Ord(pDeviceSettingsIn.PresentParams.MultiSampleType))) thenbegin          bestMultiSampleType := type_;
          bestMultiSampleQuality := Min(qualityLevels-1, pDeviceSettingsIn.PresentParams.MultiSampleQuality);
       end
     end
   endelsebegin      // Error case
      bestMultiSampleType := D3DMULTISAMPLE_NONE 
      bestMultiSampleQuality := 0;
   end
 end

  //---------------------
  // Swap effect
  //---------------------
  if (pMatchOptions.eSwapEffect = z3DMT_PRESERVE_INPUT) thenbegin    bestSwapEffect := pDeviceSettingsIn.PresentParams.SwapEffect;
 end  else if (pMatchOptions.eSwapEffect = z3DMT_IGNORE_INPUT) thenbegin    bestSwapEffect := D3DSWAPEFFECT_DISCARD 
 end  else // if( pMatchOptions->eSwapEffect == z3DMT_CLOSEST_TO_INPUT )begin    bestSwapEffect := pDeviceSettingsIn.PresentParams.SwapEffect 

    // Swap effect has to be one of these 3
    if (bestSwapEffect <> D3DSWAPEFFECT_DISCARD) and
       (bestSwapEffect <> D3DSWAPEFFECT_FLIP) and
       (bestSwapEffect <> D3DSWAPEFFECT_COPY) then
      bestSwapEffect := D3DSWAPEFFECT_DISCARD;
 end

  //---------------------
  // Depth stencil
  //---------------------
  dwBackBufferBitDepth := z3DCore_GetColorChannelBits(pBestDeviceSettingsCombo.BackBufferFormat);
  dwInputDepthBitDepth := 0;
  if (pDeviceSettingsIn <> nil) then
    dwInputDepthBitDepth := z3DCore_GetDepthBits(pDeviceSettingsIn.PresentParams.AutoDepthStencilFormat);

  for i:= 0 to Length(pBestDeviceSettingsCombo.depthStencilFormatList) - 1 dobegin    curDepthStencilFmt := pBestDeviceSettingsCombo.depthStencilFormatList[i];
    dwCurDepthBitDepth := z3DCore_GetDepthBits(curDepthStencilFmt);

    if (pMatchOptions.eDepthFormat = z3DMT_PRESERVE_INPUT) thenbegin      // Need to match bit depth of input
      if (dwCurDepthBitDepth = dwInputDepthBitDepth)
      then nRanking := 0
      else nRanking := 10000;
   end    else if (pMatchOptions.eDepthFormat = z3DMT_IGNORE_INPUT) thenbegin      // Prefer match of backbuffer bit depth
      nRanking := Abs(Integer(dwCurDepthBitDepth) - Integer(dwBackBufferBitDepth*4)) 
   end    elsebegin      // Prefer match of input depth format bit depth
      nRanking := Abs(Integer(dwCurDepthBitDepth) - Integer(dwInputDepthBitDepth)) 
   end

    // depthStencilRanking.Add(nRanking);
    l:= Length(depthStencilRanking);
    SetLength(depthStencilRanking, l+1);
    depthStencilRanking[l]:= nRanking;
 end

  dwInputStencilBitDepth := 0;
  if (pDeviceSettingsIn <> nil) then
    dwInputStencilBitDepth := z3DCore_GetStencilBits(pDeviceSettingsIn.PresentParams.AutoDepthStencilFormat);

  for i:= 0 to Length(pBestDeviceSettingsCombo.depthStencilFormatList) - 1 dobegin    curDepthStencilFmt := pBestDeviceSettingsCombo.depthStencilFormatList[i];
    nRanking := depthStencilRanking[i];
    dwCurStencilBitDepth := z3DCore_GetStencilBits(curDepthStencilFmt);

    if (pMatchOptions.eStencilFormat = z3DMT_PRESERVE_INPUT) thenbegin      // Need to match bit depth of input
      if (dwCurStencilBitDepth = dwInputStencilBitDepth)
      then Inc(nRanking, 0)
      else Inc(nRanking, 10000);
   end    else if (pMatchOptions.eStencilFormat = z3DMT_IGNORE_INPUT) thenbegin      // Prefer 0 stencil bit depth
      Inc(nRanking, dwCurStencilBitDepth) 
   end    elsebegin      // Prefer match of input stencil format bit depth
      Inc(nRanking, Abs(Integer(dwCurStencilBitDepth) - Integer(dwInputStencilBitDepth))) 
   end

    depthStencilRanking[i]:= nRanking;
 end

  nBestRanking := 100000;
  nBestIndex := -1;
  for i:= 0 to Length(pBestDeviceSettingsCombo.depthStencilFormatList) - 1 dobegin    nRanking := depthStencilRanking[i];
    if (nRanking < nBestRanking) thenbegin      nBestRanking := nRanking;
      nBestIndex := i;
   end
 end

  if (nBestIndex >= 0) thenbegin    bestDepthStencilFormat := pBestDeviceSettingsCombo.depthStencilFormatList[nBestIndex];
    bestEnableAutoDepthStencil := True;
 endelsebegin    bestDepthStencilFormat := D3DFMT_UNKNOWN 
    bestEnableAutoDepthStencil := False;
 end


  //---------------------
  // Present flags
  //---------------------
  if (pMatchOptions.ePresentFlags = z3DMT_PRESERVE_INPUT) thenbegin    dwBestFlags := pDeviceSettingsIn.PresentParams.Flags;
 end  else if (pMatchOptions.ePresentFlags = z3DMT_IGNORE_INPUT) thenbegin    dwBestFlags := 0 
    if bestEnableAutoDepthStencil then
      dwBestFlags := D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL;
 end  elsebegin    dwBestFlags := pDeviceSettingsIn.PresentParams.Flags 
    if bestEnableAutoDepthStencil then
      dwBestFlags := dwBestFlags or D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL;
 end

  //---------------------
  // Refresh rate
  //---------------------
  if pBestDeviceSettingsCombo.Windowed thenbegin    // Must be 0 for windowed
    bestDisplayMode.RefreshRate := 0;
 endelsebegin    if (pMatchOptions.eRefreshRate = z3DMT_PRESERVE_INPUT) thenbegin      bestDisplayMode.RefreshRate := pDeviceSettingsIn.PresentParams.FullScreen_RefreshRateInHz 
   endelsebegin      if (pMatchOptions.eRefreshRate = z3DMT_CLOSEST_TO_INPUT) thenbegin        refreshRateMatch := pDeviceSettingsIn.PresentParams.FullScreen_RefreshRateInHz 
     end      elsebegin        refreshRateMatch := adapterDesktopDisplayMode.RefreshRate 
     end

      bestDisplayMode.RefreshRate := 0;

      if (refreshRateMatch <> 0) thenbegin        nBestRefreshRanking := 100000;
        pDisplayModeList := pBestDeviceSettingsCombo.AdapterInfo.displayModeList^;
        for iDisplayMode:= 0 to Length(pDisplayModeList) - 1 dobegin          displayMode := pDisplayModeList[iDisplayMode];
          if (displayMode.Format <> pBestDeviceSettingsCombo.AdapterFormat) or
             (displayMode.Height <> bestDisplayMode.Height) or
             (displayMode.Width <> bestDisplayMode.Width)
          then Continue; // Skip display modes that don't match

          // Find the delta between the current refresh rate and the optimal refresh rate
          nCurRanking := Abs(Integer(displayMode.RefreshRate) - Integer(refreshRateMatch));

          if (nCurRanking < nBestRefreshRanking) thenbegin            bestDisplayMode.RefreshRate := displayMode.RefreshRate;
            nBestRefreshRanking := nCurRanking;

            // Stop if perfect match found
            if (nBestRefreshRanking = 0) then Break;
         end
       end
     end
   end
 end

  //---------------------
  // Present interval
  //---------------------
  if (pMatchOptions.ePresentInterval = z3DMT_PRESERVE_INPUT) thenbegin    bestPresentInterval := pDeviceSettingsIn.PresentParams.PresentationInterval;
 end  else if (pMatchOptions.ePresentInterval = z3DMT_IGNORE_INPUT) thenbegin    bestPresentInterval := D3DPRESENT_INTERVAL_DEFAULT 
 end  else // if( pMatchOptions->ePresentInterval == z3DMT_CLOSEST_TO_INPUT )begin    if DynArrayContains(pBestDeviceSettingsCombo.presentIntervalList,
                        pDeviceSettingsIn.PresentParams.PresentationInterval,
                        SizeOf(pDeviceSettingsIn.PresentParams.PresentationInterval))
    then bestPresentInterval := pDeviceSettingsIn.PresentParams.PresentationInterval
    else bestPresentInterval := D3DPRESENT_INTERVAL_DEFAULT 
 end

  // Fill the device settings struct
  ZeroMemory(@pValidDeviceSettings, SizeOf(Tz3DDeviceSettings));
  pValidDeviceSettings.AdapterOrdinal                 := pBestDeviceSettingsCombo.AdapterOrdinal;
  pValidDeviceSettings.DeviceType                     := pBestDeviceSettingsCombo.DeviceType;
  pValidDeviceSettings.AdapterFormat                  := pBestDeviceSettingsCombo.AdapterFormat;
  pValidDeviceSettings.BehaviorFlags                  := dwBestBehaviorFlags;
  pValidDeviceSettings.PresentParams.BackBufferWidth             := bestDisplayMode.Width;
  pValidDeviceSettings.PresentParams.BackBufferHeight            := bestDisplayMode.Height;
  pValidDeviceSettings.PresentParams.BackBufferFormat            := pBestDeviceSettingsCombo.BackBufferFormat;
  pValidDeviceSettings.PresentParams.BackBufferCount             := bestBackBufferCount;
  pValidDeviceSettings.PresentParams.MultiSampleType             := bestMultiSampleType;
  pValidDeviceSettings.PresentParams.MultiSampleQuality          := bestMultiSampleQuality;
  pValidDeviceSettings.PresentParams.SwapEffect                  := bestSwapEffect;
  pValidDeviceSettings.PresentParams.hDeviceWindow               := HWND(IfThen(pBestDeviceSettingsCombo.Windowed, z3DCore_GetHWNDDeviceWindowed, z3DCore_GetHWNDDeviceFullScreen));
  pValidDeviceSettings.PresentParams.Windowed                    := pBestDeviceSettingsCombo.Windowed;
  pValidDeviceSettings.PresentParams.EnableAutoDepthStencil      := bestEnableAutoDepthStencil;
  pValidDeviceSettings.PresentParams.AutoDepthStencilFormat      := bestDepthStencilFormat;
  pValidDeviceSettings.PresentParams.Flags                       := dwBestFlags;                   
  pValidDeviceSettings.PresentParams.FullScreen_RefreshRateInHz  := bestDisplayMode.RefreshRate;
  pValidDeviceSettings.PresentParams.PresentationInterval        := bestPresentInterval;
#endif /* DOXYGEN_SKIP */
};

         
HRESULT z3DFindValidResolution (const TD3DDeviceSettingsCombinations pBestDeviceSettingsCombo ,
TD3DDisplayMode displayModeIn ,
/* out */ TD3DDisplayMode &pBestDisplayMode 
)

/*
var

  bestDisplayMode: TD3DDisplayMode;
  iDisplayMode: Integer;
  nBestRanking: Integer;
  nCurRanking: Integer;
  pDisplayModeList: TD3DDisplayModeArray;
  displayMode: TD3DDisplayMode;
*/
{
#ifndef DOXYGEN_SKIP

  pDisplayModeList:= nil;
  ZeroMemory(@bestDisplayMode, SizeOf(TD3DDisplayMode));

  if pBestDeviceSettingsCombo.Windowed thenbegin    // In windowed mode, all resolutions are valid but restritions still apply
    // on the size of the window.  See z3DChangeDevice() for details
    pBestDisplayMode := displayModeIn;
 endelsebegin    nBestRanking := 100000 
    pDisplayModeList := pBestDeviceSettingsCombo.AdapterInfo.displayModeList^;
    for iDisplayMode:= 0 to Length(pDisplayModeList) - 1 dobegin      displayMode := pDisplayModeList[iDisplayMode];

      // Skip display modes that don't match the combo's adapter format
      if (displayMode.Format <> pBestDeviceSettingsCombo.AdapterFormat)
      then Continue;

      // Find the delta between the current width/height and the optimal width/height
      nCurRanking := Abs(Integer(displayMode.Width) - Integer(displayModeIn.Width)) +
                     Abs(Integer(displayMode.Height)- Integer(displayModeIn.Height));

      if (nCurRanking < nBestRanking) thenbegin        bestDisplayMode := displayMode;
        nBestRanking := nCurRanking;

        // Stop if perfect match found
        if (nBestRanking = 0) then Break;
     end
   end

    if (bestDisplayMode.Width = 0) thenbegin      pBestDisplayMode := displayModeIn;
      Result:= E_FAIL; // No valid display modes found
      Exit;
   end

    pBestDisplayMode := bestDisplayMode;
 end

  Result:= S_OK;
#endif /* DOXYGEN_SKIP */
};

            
HRESULT z3DFindAdapterFormat (LongWord AdapterOrdinal ,
TD3DDevType DeviceType ,
TD3DFormat BackBufferFormat ,
Boolean Windowed ,
/* out */ TD3DFormat &pAdapterFormat 
)

/*
var

  pd3dEnum: Iz3DDeviceList;
  pDeviceInfo: Iz3DEnumDeviceInfo;
  iDeviceCombo: Integer;
  pDeviceSettingsCombo: PD3DDeviceSettingsCombinations;
*/
{
#ifndef DOXYGEN_SKIP

  pd3dEnum := z3DPrepareDeviceListObject;
  pDeviceInfo := pd3dEnum.GetDeviceInfo(AdapterOrdinal, DeviceType);
  if (pDeviceInfo <> nil) thenbegin    for iDeviceCombo:= 0 to Length(pDeviceInfo.deviceSettingsComboList^) - 1 dobegin      pDeviceSettingsCombo := pDeviceInfo.deviceSettingsComboList^[iDeviceCombo];
      if (pDeviceSettingsCombo.BackBufferFormat = BackBufferFormat) and
         (pDeviceSettingsCombo.Windowed = Windowed) thenbegin        // Return the adapter format from the first match
        pAdapterFormat := pDeviceSettingsCombo.AdapterFormat;
        Result:= S_OK;
        Exit;
     end
   end
 end

  pAdapterFormat := BackBufferFormat;
  Result:= E_FAIL;
#endif /* DOXYGEN_SKIP */
};

#ifdef  FPC

#ifdef INCLUDE_TYPE_SECTION

   struct tagMONITORINFOW
{

      DWORD cbSize; 

      TRect rcMonitor; 

      TRect rcWork; 

      DWORD dwFlags; 

 };

   typedef tagMONITORINFOW* PMonitorInfoW;

   typedef tagMONITORINFOW TMonitorInfoW;


   const  MONITOR_DEFAULTTONULL =  $0;

#endif

#ifdef INCLUDE_TYPE_SECTION

   typedef DWORD EXECUTION_STATE;

    const  ES_SYSTEM_REQUIRED =  DWORD($00000001);
   const  ES_DISPLAY_REQUIRED =  DWORD($00000002);
       const  ES_USER_PRESENT =  DWORD($00000004);
         const  ES_CONTINUOUS =  DWORD($80000000);

   
EXECUTION_STATE SetThreadExecutionState (EXECUTION_STATE esFlags 
)
 ;  kernel32;

         
HRESULT z3DChangeDevice (Pz3DDeviceSettings pNewDeviceSettings ,
IDirect3DDevice9 pd3dDeviceFromApp ,
Boolean bForceRecreate ,
Boolean bClipWindowToSingleAdapter 
)

/*
var

  pOldDeviceSettings, pNewDeviceSettingsOnHeap: Pz3DDeviceSettings;
  pCallbackModifyDeviceSettings: Tz3DCallback_ModifyDeviceSettings;
  caps: TD3DCaps9;
  pD3D: IDirect3D9;
  bContinue: Boolean;
  rcWindowClient, rcWindowBounds: TRect;
  pd3dDevice: IDirect3DDevice9;
  pd3dEnum: Tz3DDeviceList;
  pAdapterInfo: Tz3DEnumAdapterInfo;
  hAdapterMonitor: HMONITOR;
  ptClient: TPoint;
  wp: TWindowPlacement;
  bKeepCurrentWindowSize: Boolean;
  pwp: PWindowPlacement;
  wpFullscreen: TWindowPlacement;
  dwStyle: DWORD;
  hMenu: Windows.HMENU;
  pd3dCaps: PD3DCaps9;
  bNeedToResize: Boolean;
  nClientWidth, nClientHeight: LongWord;
  rcClient: TRect;
  rcFrame: TRect;
  nFrameWidth, nFrameHeight: Longint;
  miAdapter: Tz3DMonitorInfo;
  nMonitorWidth, nMonitorHeight: Integer;
  hWindowMonitor: HMONITOR;
  miWindow: Tz3DMonitorInfo;
  nAdapterMonitorWidth, nAdapterMonitorHeight: Integer;
  rcWindow, rcResizedWindow: TRect;
  nWindowOffsetX, nWindowOffsetY, nWindowWidth, nWindowHeight: Integer;
  cx, cy: Integer;
  deviceSettings: Tz3DDeviceSettings;
  bMonitorChanged: Boolean;
  bIsTopmost: Boolean;
  hWndInsertAfter: HWND;
*/
{
#ifndef DOXYGEN_SKIP

  pOldDeviceSettings := z3DCore_GetState.CurrentDeviceSettings;

  if (z3DCore_GetD3DObject = nil) thenbegin    Result:= S_FALSE;
    Exit;
 end

  // Make a copy of the pNewDeviceSettings on the heap
  try
    New(pNewDeviceSettingsOnHeap);
  except
    Result:= E_OUTOFMEMORY;
    Exit;
 end
  Move(pNewDeviceSettings^, pNewDeviceSettingsOnHeap^, SizeOf(Tz3DDeviceSettings));
  pNewDeviceSettings := pNewDeviceSettingsOnHeap;

  // If the ModifyDeviceSettings callback is non-NULL, then call it to let the app 
  // change the settings or reject the device change by returning false.
  pCallbackModifyDeviceSettings := z3DCore_GetState.ModifyDeviceSettingsFunc;
  if Assigned(pCallbackModifyDeviceSettings) thenbegin    pD3D := z3DCore_GetD3DObject;
    pD3D.GetDeviceCaps(pNewDeviceSettings.AdapterOrdinal, pNewDeviceSettings.DeviceType, caps);

    bContinue := pCallbackModifyDeviceSettings(pNewDeviceSettings^, caps, z3DCore_GetState.ModifyDeviceSettingsFuncUserContext);
    if not bContinue thenbegin      // The app rejected the device change by returning false, so just use the current device if there is one.
      if (pOldDeviceSettings = nil) then z3DDisplayErrorMessage(z3DERR_NOCOMPATIBLEDEVICES);
      Dispose(pNewDeviceSettings);
      Result:= E_ABORT;
      Exit;
   end
    if (z3DCore_GetState.D3D = nil) thenbegin      Dispose(pNewDeviceSettings);
      Result:= S_False;
      Exit;
   end
 end

  z3DCore_GetState.CurrentDeviceSettings := pNewDeviceSettings;

  z3DCore_Pause(True, True);

  // When a WM_SIZE message is received, it calls z3DCheckForWindowSizeChange().
  // A WM_SIZE message might be sent when adjusting the window, so tell
  // z3DCheckForWindowSizeChange() to ignore size changes temporarily
  z3DCore_GetState.IgnoreSizeChange := True;

  // Update thread safety on/off depending on Direct3D device's thread safety
  g_bThreadSafe := ((pNewDeviceSettings.BehaviorFlags and D3DCREATE_MULTITHREADED) <> 0);

  // Only apply the cmd line overrides if this is the first device created
  // and z3DSetDevice() isn't used
  if (pd3dDeviceFromApp = nil) and (pOldDeviceSettings = nil) thenbegin    // Updates the device settings struct based on the cmd line args.
    // Warning: if the device doesn't support these new settings then CreateDevice() will fail.
    z3DUpdateDeviceSettingsWiths(pNewDeviceSettings^);
 end

  // Take note if the backbuffer width & height are 0 now as they will change after pd3dDevice->Reset()
  bKeepCurrentWindowSize := False;
  if (pNewDeviceSettings.PresentParams.BackBufferWidth = 0) and (pNewDeviceSettings.PresentParams.BackBufferHeight = 0)
  then bKeepCurrentWindowSize := True;

  //////////////////////////
  // Before reset
  /////////////////////////
  if pNewDeviceSettings.PresentParams.Windowed thenbegin    // Going to windowed mode

    if Assigned(pOldDeviceSettings) and not pOldDeviceSettings.PresentParams.Windowed thenbegin      // Going from fullscreen -> windowed
      z3DCore_GetState.SetFullScreenBackBufferWidthAtModeChange(pOldDeviceSettings.PresentParams.BackBufferWidth);
      z3DCore_GetState.SetFullScreenBackBufferHeightAtModeChange(pOldDeviceSettings.PresentParams.BackBufferHeight);

      // Restore windowed mode style
      SetWindowLong(z3DCore_GetHWNDDeviceWindowed, GWL_STYLE, z3DCore_GetState.GetWindowedStyleAtModeChange);
   end

    // If different device windows are used for windowed mode and fullscreen mode,
    // hide the fullscreen window so that it doesn't obscure the screen.
    if (z3DCore_GetHWNDDeviceFullScreen <> z3DCore_GetHWNDDeviceWindowed)
    then ShowWindow(z3DCore_GetHWNDDeviceFullScreen, SW_HIDE);

    // If using the same window for windowed and fullscreen mode, reattach menu if one exists
    if (z3DCore_GetHWNDDeviceFullScreen = z3DCore_GetHWNDDeviceWindowed) thenbegin      if (z3DCore_GetState.Menu <> 0)
      then SetMenu(z3DCore_GetHWNDDeviceWindowed, z3DCore_GetState.GetMenu);
   end
 endelsebegin    // Going to fullscreen mode

    if (pOldDeviceSettings = nil) or (Assigned(pOldDeviceSettings) and pOldDeviceSettings.PresentParams.Windowed) thenbegin      // Transistioning to full screen mode from a standard window so
      // save current window position/size/style now in case the user toggles to windowed mode later
      pwp := z3DCore_GetState.GetWindowedPlacement 
      ZeroMemory(pwp, SizeOf(TWindowPlacement));
      pwp.length := SizeOf(TWindowPlacement);
      #ifdef  FPC

      GetWindowPlacement(z3DCore_GetHWNDDeviceWindowed, pwp^);
      #else

      GetWindowPlacement(z3DCore_GetHWNDDeviceWindowed, pwp);
      #endif

      bIsTopmost := GetWindowLong(z3DCore_GetHWNDDeviceWindowed, GWL_EXSTYLE) and WS_EX_TOPMOST <> 0;
      z3DCore_GetState.SetTopmostWhileWindowed(bIsTopmost);
      dwStyle := GetWindowLong(z3DCore_GetHWNDDeviceWindowed, GWL_STYLE);
      dwStyle := dwStyle and not WS_MAXIMIZE and not WS_MINIMIZE; // remove minimize/maximize style
      z3DCore_GetState.SetWindowedStyleAtModeChange(dwStyle);
      if Assigned(pOldDeviceSettings) thenbegin        z3DCore_GetState.SetWindowBackBufferWidthAtModeChange(pOldDeviceSettings.PresentParams.BackBufferWidth);
        z3DCore_GetState.SetWindowBackBufferHeightAtModeChange(pOldDeviceSettings.PresentParams.BackBufferHeight);
     end
   end

    // Hide the window to avoid animation of blank windows
    ShowWindow(z3DCore_GetHWNDDeviceFullScreen, SW_HIDE);

    // Set FS window style
    SetWindowLong(z3DCore_GetHWNDDeviceFullScreen, GWL_STYLE, Integer(WS_POPUP or WS_SYSMENU));

    // If using the same window for windowed and fullscreen mode, save and remove menu
    if (z3DCore_GetHWNDDeviceFullScreen = z3DCore_GetHWNDDeviceWindowed) thenbegin      hMenu := GetMenu(z3DCore_GetHWNDDeviceFullScreen);
      z3DCore_GetState.SetMenu(hMenu);
      SetMenu(z3DCore_GetHWNDDeviceFullScreen, 0);
   end

    ZeroMemory(@wpFullscreen, SizeOf(TWindowPlacement));
    wpFullscreen.length := SizeOf(TWindowPlacement);
    #ifdef  FPC

    GetWindowPlacement(z3DCore_GetHWNDDeviceFullScreen, wpFullscreen);
    #else

    GetWindowPlacement(z3DCore_GetHWNDDeviceFullScreen, @wpFullscreen);
    #endif

    if ((wpFullscreen.flags and WPF_RESTORETOMAXIMIZED) <> 0) thenbegin      // Restore the window to normal if the window was maximized then minimized.  This causes the
      // WPF_RESTORETOMAXIMIZED flag to be set which will cause SW_RESTORE to restore the
      // window from minimized to maxmized which isn't what we want
      with wpFullscreen do flags := flags and not WPF_RESTORETOMAXIMIZED;
      wpFullscreen.showCmd := SW_RESTORE;
      #ifdef  FPC

      SetWindowPlacement(z3DCore_GetHWNDDeviceFullScreen, wpFullscreen);
      #else

      SetWindowPlacement(z3DCore_GetHWNDDeviceFullScreen, @wpFullscreen);
      #endif

   end
 end

  // If AdapterOrdinal and DeviceType are the same, we can just do a Reset().
  // If they've changed, we need to do a complete device tear down/rebuild.
  // Also only allow a reset if pd3dDevice is the same as the current device
  if not bForceRecreate and
     ((pd3dDeviceFromApp = nil) or (pd3dDeviceFromApp = z3DCore_GetD3DDevice)) and
     (z3DCore_GetD3DDevice <> nil) and
     (pOldDeviceSettings <> nil) and
     (pOldDeviceSettings.AdapterOrdinal = pNewDeviceSettings.AdapterOrdinal) and
     (pOldDeviceSettings.DeviceType = pNewDeviceSettings.DeviceType) and
     (pOldDeviceSettings.BehaviorFlags = pNewDeviceSettings.BehaviorFlags) thenbegin    // Reset the Direct3D device and call the app's device callbacks
    Result := z3DReset3DEnvironment;
    if FAILED(Result) thenbegin      if (Result = D3DERR_DEVICELOST) thenbegin        // The device is lost, just mark it as so and continue on with
        // capturing the state and resizing the window/etc.
        z3DCore_GetState.DeviceLost:= True;
     end      else if (Result = z3DERR_RESETTINGDEVICEOBJECTS) or
              (Result = z3DERR_MEDIANOTFOUND) thenbegin        // Something bad happened in the app callbacks
        Dispose(pOldDeviceSettings) 
        z3DDisplayErrorMessage(Result);
        z3DCore_Shutdown;
        Exit; // Result:= hr;
     end      else // z3DERR_RESETTINGDEVICEbegin        // Reset failed and the device wasn't lost and it wasn't the apps fault,
        // so recreate the device to try to recover
        //todo: Fill bug report: should SafeDelete( pNewDeviceSettings )  and Pause (False)
        z3DCore_GetState.CurrentDeviceSettings := pOldDeviceSettings;
        if FAILED(z3DChangeDevice(pNewDeviceSettings, pd3dDeviceFromApp, True, bClipWindowToSingleAdapter)) thenbegin          // If that fails, then shutdown
          z3DCore_Shutdown;
          Result:= z3DERR_CREATINGDEVICE;
       endelse
          Result:= S_OK 
          
        Dispose(pNewDeviceSettings);
        Exit;
     end
   end
 endelsebegin    // Cleanup if not first device created
    if (pOldDeviceSettings <> nil) then z3DCleanup3DEnvironment(False) 

    // Create the D3D device and call the app's device callbacks
    Result := z3DCreate3DEnvironment(pd3dDeviceFromApp);
    if FAILED(Result) thenbegin      Dispose(pOldDeviceSettings);
      z3DCleanup3DEnvironment;
      z3DDisplayErrorMessage(Result);
      z3DCore_Pause(False, False);
      z3DCore_GetState.SetIgnoreSizeChange(False);
      Exit;
   end
 end

  // Enable/disable StickKeys shortcut, ToggleKeys shortcut, FilterKeys shortcut, and Windows key
  // to prevent accidental task switching
  if pNewDeviceSettings.PresentParams.Windowed
  then z3DAllowShortcutKeys(z3DCore_GetState.GetAllowShortcutKeysWhenWindowed)
  else z3DAllowShortcutKeys(z3DCore_GetState.GetAllowShortcutKeysWhenFullscreen);

  pD3D := z3DCore_GetD3DObject;
  hAdapterMonitor := pD3D.GetAdapterMonitor(pNewDeviceSettings.AdapterOrdinal);
  z3DCore_GetState.SetAdapterMonitor(hAdapterMonitor);

  // Update the device stats text
  z3DUpdateStaticFrameStats;

  if (pOldDeviceSettings <> nil) and not pOldDeviceSettings.PresentParams.Windowed and pNewDeviceSettings.PresentParams.Windowed thenbegin    // Going from fullscreen -> windowed

    // Restore the show state, and positions/size of the window to what it was
    // It is important to adjust the window size
    // after resetting the device rather than beforehand to ensure
    // that the monitor resolution is correct and does not limit the size of the new window.
    pwp := z3DCore_GetState.GetWindowedPlacement;
    #ifdef  FPC

    SetWindowPlacement(z3DCore_GetHWNDDeviceWindowed, pwp^);
    #else

    SetWindowPlacement(z3DCore_GetHWNDDeviceWindowed, pwp);
    #endif


    // Also restore the z-order of window to previous state
    if z3DCore_GetState.GetTopmostWhileWindowed then hWndInsertAfter := HWND_TOPMOST else hWndInsertAfter := HWND_NOTOPMOST;
    SetWindowPos(z3DCore_GetHWNDDeviceWindowed, hWndInsertAfter, 0, 0, 0, 0, SWP_NOMOVE or SWP_NOREDRAW or SWP_NOSIZE);
 end

  // Check to see if the window needs to be resized.  
  // Handle cases where the window is minimized and maxmimized as well.
  bNeedToResize := False;
  if pNewDeviceSettings.PresentParams.Windowed and // only resize if in windowed mode
     not bKeepCurrentWindowSize then    // only resize if pp.BackbufferWidth/Height were not 0begin    if IsIconic(z3DCore_GetHWNDDeviceWindowed) thenbegin      // Window is currently minimized. To tell if it needs to resize,
      // get the client rect of window when its restored the
      // hard way using GetWindowPlacement()
      ZeroMemory(@wp, SizeOf(TWindowPlacement));
      wp.length := SizeOf(TWindowPlacement);
      #ifdef  FPC

      GetWindowPlacement(z3DCore_GetHWNDDeviceWindowed, wp);
      #else

      GetWindowPlacement(z3DCore_GetHWNDDeviceWindowed, @wp);
      #endif


      if (wp.flags and WPF_RESTORETOMAXIMIZED <> 0) and (wp.showCmd = SW_SHOWMINIMIZED) thenbegin        // WPF_RESTORETOMAXIMIZED means that when the window is restored it will
        // be maximized.  So maximize the window temporarily to get the client rect
        // when the window is maximized.  GetSystemMetrics( SM_CXMAXIMIZED ) will give this
        // information if the window is on the primary but this will work on multimon.
        ShowWindow(z3DCore_GetHWNDDeviceWindowed, SW_RESTORE);
        GetClientRect(z3DCore_GetHWNDDeviceWindowed, rcClient);
        nClientWidth  := (rcClient.right - rcClient.left);
        nClientHeight := (rcClient.bottom - rcClient.top);
        ShowWindow(z3DCore_GetHWNDDeviceWindowed, SW_MINIMIZE);
     endelsebegin        // Use wp.rcNormalPosition to get the client rect, but wp.rcNormalPosition
        // includes the window frame so subtract it
        rcFrame := Rect(0, 0, 0, 0) 
        AdjustWindowRect(rcFrame, z3DCore_GetState.GetWindowedStyleAtModeChange, z3DCore_GetState.Menu <> 0);
        nFrameWidth := rcFrame.right - rcFrame.left;
        nFrameHeight := rcFrame.bottom - rcFrame.top;
        nClientWidth  := (wp.rcNormalPosition.right - wp.rcNormalPosition.left - nFrameWidth);
        nClientHeight := (wp.rcNormalPosition.bottom - wp.rcNormalPosition.top - nFrameHeight);
     end
   endelsebegin      // Window is restored or maximized so just get its client rect
      GetClientRect(z3DCore_GetHWNDDeviceWindowed, rcClient) 
      nClientWidth  := (rcClient.right - rcClient.left);
      nClientHeight := (rcClient.bottom - rcClient.top);
   end

    // Now that we know the client rect, compare it against the back buffer size
    // to see if the client rect is already the right size
    if (nClientWidth  <> pNewDeviceSettings.PresentParams.BackBufferWidth) or
       (nClientHeight <> pNewDeviceSettings.PresentParams.BackBufferHeight) thenbegin      bNeedToResize := True;
   end

    if bClipWindowToSingleAdapter and not IsIconic(z3DCore_GetHWNDDeviceWindowed) thenbegin      // Get the rect of the monitor attached to the adapter
      miAdapter.cbSize := SizeOf(Tz3DMonitorInfo);
      hAdapterMonitor := z3DCore_GetD3DObject.GetAdapterMonitor(pNewDeviceSettings.AdapterOrdinal);
      z3DGetMonitorInfo(hAdapterMonitor, miAdapter);
      hWindowMonitor := z3DMonitorFromWindow(z3DCore_GetHWND, MONITOR_DEFAULTTOPRIMARY);

      // Get the rect of the window
      GetWindowRect(z3DCore_GetHWNDDeviceWindowed, rcWindow);

      // Check if the window rect is fully inside the adapter's vitural screen rect
      if (rcWindow.left   < miAdapter.rcWork.left)   or
         (rcWindow.right  > miAdapter.rcWork.right)  or
         (rcWindow.top    < miAdapter.rcWork.top)    or
         (rcWindow.bottom > miAdapter.rcWork.bottom) thenbegin        if (hWindowMonitor = hAdapterMonitor) and IsZoomed(z3DCore_GetHWNDDeviceWindowed) thenbegin          // If the window is maximized and on the same monitor as the adapter, then
          // no need to clip to single adapter as the window is already clipped
          // even though the rcWindow rect is outside of the miAdapter.rcWork
       endelsebegin          bNeedToResize := True 
       end
     end
   end
 end

  // Only resize window if needed
  if bNeedToResize thenbegin    // Need to resize, so if window is maximized or minimized then restore the window
    if IsIconic(z3DCore_GetHWNDDeviceWindowed) then ShowWindow(z3DCore_GetHWNDDeviceWindowed, SW_RESTORE);
    if IsZoomed(z3DCore_GetHWNDDeviceWindowed) then // doing the IsIconic() check first also handles the WPF_RESTORETOMAXIMIZED case
      ShowWindow(z3DCore_GetHWNDDeviceWindowed, SW_RESTORE);

    if bClipWindowToSingleAdapter thenbegin      // Get the rect of the monitor attached to the adapter
      miAdapter.cbSize := SizeOf(Tz3DMonitorInfo);
      z3DGetMonitorInfo(z3DCore_GetD3DObject.GetAdapterMonitor(pNewDeviceSettings.AdapterOrdinal), miAdapter);

      // Get the rect of the monitor attached to the window
      miWindow.cbSize := SizeOf(Tz3DMonitorInfo);
      z3DGetMonitorInfo(z3DMonitorFromWindow(z3DCore_GetHWND, MONITOR_DEFAULTTOPRIMARY), miWindow);

      // Do something reasonable if the BackBuffer size is greater than the monitor size
      nAdapterMonitorWidth := miAdapter.rcWork.right - miAdapter.rcWork.left;
      nAdapterMonitorHeight := miAdapter.rcWork.bottom - miAdapter.rcWork.top;

      nClientWidth := pNewDeviceSettings.PresentParams.BackBufferWidth;
      nClientHeight := pNewDeviceSettings.PresentParams.BackBufferHeight;

      // Get the rect of the window
      GetWindowRect(z3DCore_GetHWNDDeviceWindowed, rcWindow);

      // Make a window rect with a client rect that is the same size as the backbuffer
      rcResizedWindow.left := 0;
      rcResizedWindow.right := nClientWidth;
      rcResizedWindow.top := 0;
      rcResizedWindow.bottom := nClientHeight;
      AdjustWindowRect(rcResizedWindow, GetWindowLong(z3DCore_GetHWNDDeviceWindowed, GWL_STYLE), z3DCore_GetState.Menu <> 0);

      nWindowWidth := rcResizedWindow.right - rcResizedWindow.left;
      nWindowHeight := rcResizedWindow.bottom - rcResizedWindow.top;

      if (nWindowWidth > nAdapterMonitorWidth) then nWindowWidth := (nAdapterMonitorWidth - 0);
      if (nWindowHeight > nAdapterMonitorHeight) then nWindowHeight := (nAdapterMonitorHeight - 0);

      if (rcResizedWindow.left < miAdapter.rcWork.left) or
         (rcResizedWindow.top < miAdapter.rcWork.top) or
         (rcResizedWindow.right > miAdapter.rcWork.right) or
         (rcResizedWindow.bottom > miAdapter.rcWork.bottom) thenbegin        nWindowOffsetX := (nAdapterMonitorWidth - nWindowWidth) div 2;
        nWindowOffsetY := (nAdapterMonitorHeight - nWindowHeight) div 2;

        rcResizedWindow.left := miAdapter.rcWork.left + nWindowOffsetX;
        rcResizedWindow.top := miAdapter.rcWork.top + nWindowOffsetY;
        rcResizedWindow.right := miAdapter.rcWork.left + nWindowOffsetX + nWindowWidth;
        rcResizedWindow.bottom := miAdapter.rcWork.top + nWindowOffsetY + nWindowHeight;
     end

      // Resize the window.  It is important to adjust the window size
      // after resetting the device rather than beforehand to ensure
      // that the monitor resolution is correct and does not limit the size of the new window.
      SetWindowPos(z3DCore_GetHWNDDeviceWindowed, 0, rcResizedWindow.left, rcResizedWindow.top, nWindowWidth, nWindowHeight, SWP_NOZORDER);
   endelsebegin      // Make a window rect with a client rect that is the same size as the backbuffer
      rcWindow := Rect(0, 0, 0, 0) 
      rcWindow.right := (pNewDeviceSettings.PresentParams.BackBufferWidth);
      rcWindow.bottom := (pNewDeviceSettings.PresentParams.BackBufferHeight);
      AdjustWindowRect(rcWindow, GetWindowLong(z3DCore_GetHWNDDeviceWindowed, GWL_STYLE), z3DCore_GetState.Menu <> 0);

      // Resize the window.  It is important to adjust the window size
      // after resetting the device rather than beforehand to ensure
      // that the monitor resolution is correct and does not limit the size of the new window.
      cx := (rcWindow.right - rcWindow.left);
      cy := (rcWindow.bottom - rcWindow.top);
      SetWindowPos(z3DCore_GetHWNDDeviceWindowed, 0, 0, 0, cx, cy, SWP_NOZORDER or SWP_NOMOVE);
   end

    // Its possible that the new window size is not what we asked for.
    // No window can be sized larger than the desktop, so see see if the Windows OS resized the
    // window to something smaller to fit on the desktop.  Also if WM_GETMINMAXINFO
    // will put a limit on the smallest/largest window size.
    GetClientRect(z3DCore_GetHWNDDeviceWindowed, rcClient);
    nClientWidth  := (rcClient.right - rcClient.left);
    nClientHeight := (rcClient.bottom - rcClient.top);
    if (nClientWidth  <> pNewDeviceSettings.PresentParams.BackBufferWidth) or
       (nClientHeight <> pNewDeviceSettings.PresentParams.BackBufferHeight) thenbegin      // If its different, then resize the backbuffer again.  This time create a backbuffer that matches the
      // client rect of the current window w/o resizing the window.
      deviceSettings := z3DCore_GetDeviceSettings;
      deviceSettings.PresentParams.BackBufferWidth  := 0;
      deviceSettings.PresentParams.BackBufferHeight := 0;
      Result := z3DChangeDevice(@deviceSettings, nil, False, bClipWindowToSingleAdapter);
      if FAILED(Result) thenbegin        Dispose(pOldDeviceSettings);
        z3DCleanup3DEnvironment;
        z3DCore_Pause(False, False);
        z3DCore_GetState.SetIgnoreSizeChange(False);
        Exit;
     end
   end
 end

  // Make the window visible
  if not IsWindowVisible(z3DCore_GetHWND) then ShowWindow(z3DCore_GetHWND, SW_SHOW);

  // Make the window visible
  if not IsWindowVisible(z3DCore_GetHWND) then ShowWindow(z3DCore_GetHWND, SW_SHOW);

  // Ensure that the display doesn't power down when fullscreen but does when windowed
  if not z3DCore_IsWindowed
  then SetThreadExecutionState(ES_DISPLAY_REQUIRED or ES_CONTINUOUS)
  else SetThreadExecutionState(ES_CONTINUOUS);

  Dispose(pOldDeviceSettings);
  z3DCore_GetState.IgnoreSizeChange:= False;
  z3DCore_Pause(False, False);
  z3DCore_GetState.DeviceCreated:= True;

  Result:= S_OK;
#endif /* DOXYGEN_SKIP */
};

       
LRESULT LowLevelKeyboardProc (Integer nCode ,
WPARAM wParam ,
LPARAM lParam 
)
 ;
/*
var

  bEatKeystroke: Boolean;
  p: PKBDLLHookStruct;
*/
{
#ifndef DOXYGEN_SKIP

  if (nCode < 0) or (nCode <> HC_ACTION) then // do not process messagebegin    Result:= CallNextHookEx(z3DCore_GetState.GetKeyboardHook, nCode, wParam, lParam);
    Exit;
 end

  bEatKeystroke := False;
  p := PKBDLLHookStruct(lParam);
  case wParam of

    WM_KEYDOWN, WM_KEYUP:
    begin      bEatKeystroke := not z3DCore_GetState.GetAllowShortcutKeys and
                      ((p.vkCode = VK_LWIN) or (p.vkCode = VK_RWIN));
   end
 end

  if bEatKeystroke then Result:= 1
  else Result:= CallNextHookEx(z3DCore_GetState.GetKeyboardHook, nCode, wParam, lParam);
#endif /* DOXYGEN_SKIP */
};

   
z3DCore_SetShortcutKeySettings (Boolean bAllowWhenFullscreen ,
Boolean bAllowWhenWindowed 
)
{
#ifndef DOXYGEN_SKIP
  z3DCore_GetState.SetAllowShortcutKeysWhenWindowed(bAllowWhenWindowed);
  z3DCore_GetState.SetAllowShortcutKeysWhenFullscreen(bAllowWhenFullscreen);

  if z3DCore_GetState.z3DInited thenbegin    if z3DCore_IsWindowed
    then z3DAllowShortcutKeys(z3DCore_GetState.GetAllowShortcutKeysWhenWindowed)
    else z3DAllowShortcutKeys(z3DCore_GetState.GetAllowShortcutKeysWhenFullscreen);
 end
#endif /* DOXYGEN_SKIP */
};

  
z3DAllowShortcutKeys (Boolean bAllowKeys 
)

/*
var

  sk: TStickyKeys;
  tk: TToggleKeys;
  fk: TFilterKeys;
  OSVersionInfo: TOSVersionInfo;
  hKeyboardHook: HHOOK;
  skOff: TStickyKeys;
  tkOff: TToggleKeys;
  fkOff: TFilterKeys;
*/
{
#ifndef DOXYGEN_SKIP

  z3DCore_GetState.AllowShortcutKeys := bAllowKeys;

  if bAllowKeys thenbegin    // Restore StickyKeys/etc to original state and enable Windows key
    sk := z3DCore_GetState.StartupStickyKeys;
    tk := z3DCore_GetState.StartupToggleKeys;
    fk := z3DCore_GetState.StartupFilterKeys;

    SystemParametersInfo(SPI_SETSTICKYKEYS, SizeOf(sk), @sk, 0);
    SystemParametersInfo(SPI_SETTOGGLEKEYS, SizeOf(tk), @tk, 0);
    SystemParametersInfo(SPI_SETFILTERKEYS, SizeOf(fk), @fk, 0);

    // Remove the keyboard hoook when it isn't needed to prevent any slow down of other apps
    if (z3DCore_GetState.KeyboardHook <> 0) thenbegin      UnhookWindowsHookEx(z3DCore_GetState.KeyboardHook);
      z3DCore_GetState.KeyboardHook := 0;
   end
 endelsebegin    // Set low level keyboard hook if haven't already
    if (z3DCore_GetState.KeyboardHook = 0) thenbegin      // Set the low-level hook procedure.  Only works on Windows 2000 and above
      OSVersionInfo.dwOSVersionInfoSize := SizeOf(OSVersionInfo) 
      GetVersionEx(OSVersionInfo);
      if (OSVersionInfo.dwPlatformId = VER_PLATFORM_WIN32_NT) and (OSVersionInfo.dwMajorVersion > 4) thenbegin        hKeyboardHook := SetWindowsHookEx(WH_KEYBOARD_LL, @LowLevelKeyboardProc, GetModuleHandle(nil), 0);
        z3DCore_GetState.SetKeyboardHook(hKeyboardHook);
     end
   end

    // Disable StickyKeys/etc shortcuts but if the accessibility feature is on,
    // then leave the settings alone as its probably being usefully used

    skOff := z3DCore_GetState.StartupStickyKeys;
    if (skOff.dwFlags and SKF_STICKYKEYSON = 0) thenbegin      // Disable the hotkey and the confirmation
      skOff.dwFlags := skOff.dwFlags and not SKF_HOTKEYACTIVE;
      skOff.dwFlags := skOff.dwFlags and not SKF_CONFIRMHOTKEY;

      SystemParametersInfo(SPI_SETSTICKYKEYS, SizeOf(skOff), @skOff, 0);
   end

    tkOff := z3DCore_GetState.StartupToggleKeys;
    if (tkOff.dwFlags and TKF_TOGGLEKEYSON = 0) thenbegin      // Disable the hotkey and the confirmation
      tkOff.dwFlags := tkOff.dwFlags and not TKF_HOTKEYACTIVE;
      tkOff.dwFlags := tkOff.dwFlags and not TKF_CONFIRMHOTKEY;

      SystemParametersInfo(SPI_SETTOGGLEKEYS, SizeOf(tkOff), @tkOff, 0);
   end

    fkOff := z3DCore_GetState.StartupFilterKeys;
    if (fkOff.dwFlags and FKF_FILTERKEYSON = 0) thenbegin      // Disable the hotkey and the confirmation
      fkOff.dwFlags := fkOff.dwFlags and not FKF_HOTKEYACTIVE;
      fkOff.dwFlags := fkOff.dwFlags and not FKF_CONFIRMHOTKEY;

      SystemParametersInfo(SPI_SETFILTERKEYS, SizeOf(fkOff), @fkOff, 0);
   end
 end
#endif /* DOXYGEN_SKIP */
};

   
z3DUpdateDeviceSettingsWithOverrides (/* out */ Tz3DDeviceSettings &pDeviceSettings 
)
{
#ifndef DOXYGEN_SKIP
  if (z3DCore_GetState.GetOverrideAdapterOrdinal <> -1) then
      pDeviceSettings.AdapterOrdinal := z3DCore_GetState.GetOverrideAdapterOrdinal;

  if z3DCore_GetState.OverrideFullScreen then pDeviceSettings.PresentParams.Windowed := False;
  if z3DCore_GetState.OverrideWindowed then pDeviceSettings.PresentParams.Windowed := True;

  if z3DCore_GetState.OverrideForceREF then
    pDeviceSettings.DeviceType := D3DDEVTYPE_REF
  else if z3DCore_GetState.OverrideForceHAL then
    pDeviceSettings.DeviceType := D3DDEVTYPE_HAL;

  if (z3DCore_GetState.OverrideWidth <> 0) then
      pDeviceSettings.PresentParams.BackBufferWidth := z3DCore_GetState.OverrideWidth;
  if (z3DCore_GetState.OverrideHeight <> 0) then
      pDeviceSettings.PresentParams.BackBufferHeight := z3DCore_GetState.OverrideHeight;

  if z3DCore_GetState.OverrideForcePureHWVP thenbegin    pDeviceSettings.BehaviorFlags := pDeviceSettings.BehaviorFlags and not D3DCREATE_SOFTWARE_VERTEXPROCESSING;
    pDeviceSettings.BehaviorFlags := pDeviceSettings.BehaviorFlags or D3DCREATE_HARDWARE_VERTEXPROCESSING;
    pDeviceSettings.BehaviorFlags := pDeviceSettings.BehaviorFlags or D3DCREATE_PUREDEVICE;
 end  else if z3DCore_GetState.OverrideForceHWVP thenbegin    pDeviceSettings.BehaviorFlags := pDeviceSettings.BehaviorFlags and not D3DCREATE_SOFTWARE_VERTEXPROCESSING 
    pDeviceSettings.BehaviorFlags := pDeviceSettings.BehaviorFlags and not D3DCREATE_PUREDEVICE;
    pDeviceSettings.BehaviorFlags := pDeviceSettings.BehaviorFlags or D3DCREATE_HARDWARE_VERTEXPROCESSING;
 end  else if z3DCore_GetState.OverrideForceSWVP thenbegin    pDeviceSettings.BehaviorFlags := pDeviceSettings.BehaviorFlags and not D3DCREATE_HARDWARE_VERTEXPROCESSING 
    pDeviceSettings.BehaviorFlags := pDeviceSettings.BehaviorFlags and not D3DCREATE_PUREDEVICE;
    pDeviceSettings.BehaviorFlags := pDeviceSettings.BehaviorFlags or D3DCREATE_SOFTWARE_VERTEXPROCESSING;
 end
#endif /* DOXYGEN_SKIP */
};

    
HRESULT z3DCreate3DEnvironment (const IDirect3DDevice9 pd3dDeviceFromApp 
)

/*
var

  pd3dDevice: IDirect3DDevice9;
  pNewDeviceSettings: Pz3DDeviceSettings;
  pD3D: IDirect3D9;
  pd3dEnum: Iz3DDeviceList;
  pAdapterInfo: Iz3DEnumAdapterInfo;
  pbackBufferSurfaceDesc: PD3DSurfaceDesc;
  pCallbackDeviceCreated: Tz3DCallback_DeviceCreated;
  pCallbackDeviceReset: Tz3DCallback_DeviceReset;
  pd3dCaps: PD3DCaps9;
*/
{
#ifndef DOXYGEN_SKIP

  pNewDeviceSettings := z3DCore_GetState.GetCurrentDeviceSettings;

  // Only create a Direct3D device if one hasn't been supplied by the app
  if (pd3dDeviceFromApp = nil) thenbegin    // Try to create the device with the chosen settings
    pD3D := z3DCore_GetD3DObject;
    Result := pD3D.CreateDevice(pNewDeviceSettings.AdapterOrdinal, pNewDeviceSettings.DeviceType,
                                z3DCore_GetHWNDFocus, pNewDeviceSettings.BehaviorFlags,
                                @pNewDeviceSettings.PresentParams, pd3dDevice);
    if (Result = D3DERR_DEVICELOST) thenbegin      z3DCore_GetState.DeviceLost := True;
      Result:= S_OK;
      Exit;
   end    else if FAILED(Result) thenbegin      z3DError('CreateDevice', Result) 
      Result:= z3DERR_CREATINGDEVICE;
      Exit;
   end
 endelsebegin    // pd3dDeviceFromApp.AddRef  // - done automagically in Delphi
    pd3dDevice := pd3dDeviceFromApp;
 end

  z3DCore_GetState.SetD3DDevice(pd3dDevice);

  // If switching to REF, set the exit code to 11.  If switching to HAL and exit code was 11, then set it back to 0.
  if (pNewDeviceSettings.DeviceType = D3DDEVTYPE_REF) and (z3DCore_GetState.GetExitCode = 0)
  then z3DCore_GetState.SetExitCode(11)
  else if (pNewDeviceSettings.DeviceType = D3DDEVTYPE_HAL) and (z3DCore_GetState.GetExitCode = 11)
  then z3DCore_GetState.SetExitCode(0);

  // Update back buffer desc before calling app's device callbacks
  z3DUpdateBackBufferDesc;

  // Setup cursor based on current settings (window/fullscreen mode, show cursor state, clip cursor state)
  z3DSetupCursor;

  // Update z3DCore_GetState()'s copy of D3D caps
  pd3dCaps := z3DCore_GetState.Caps;
  z3DCore_GetD3DDevice.GetDeviceCaps(pd3dCaps^);

  // Update the device stats text
  pd3dEnum := z3DPrepareDeviceListObject;
  pAdapterInfo := pd3dEnum.GetAdapterInfo(pNewDeviceSettings.AdapterOrdinal);
  z3DUpdateDeviceStats(pNewDeviceSettings.DeviceType,
                        pNewDeviceSettings.BehaviorFlags,
                        pAdapterInfo.AdapterIdentifier^);

  // Call the resource cache created function
  Result := z3DCore_GetGlobalResourceCache.OnCreateDevice(pd3dDevice);
  if FAILED(Result) thenbegin    if (Result <> z3DERR_MEDIANOTFOUND) then Result:= z3DERR_CREATINGDEVICEOBJECTS;
    Result:= z3DError('OnCreateDevice', Result);
    Exit;
 end

  // Call the app's device created callback if non-NULL
  pbackBufferSurfaceDesc := z3DCore_GetBackBufferSurfaceDesc;
  z3DCore_GetState.InsideDeviceCallback := True;
  pCallbackDeviceCreated := z3DCore_GetState.DeviceCreatedFunc;
  Result := S_OK;
  if (@pCallbackDeviceCreated <> nil) then
    Result := pCallbackDeviceCreated(z3DCore_GetD3DDevice, pbackBufferSurfaceDesc^, z3DCore_GetState.DeviceCreatedFuncUserContext);
  z3DCore_GetState.InsideDeviceCallback := False;
  if (z3DCore_GetD3DDevice = nil) then // Handle z3DShutdown from inside callbackbegin    Result:= E_FAIL;
    Exit;
 end

  if FAILED(Result) thenbegin    z3DError('DeviceCreated callback', Result);
    if (Result <> z3DERR_MEDIANOTFOUND) then Result := z3DERR_CREATINGDEVICEOBJECTS;
    Exit;
 end
  z3DCore_GetState.DeviceObjectsCreated := True;

  // Call the resource cache device reset function
  Result := z3DCore_GetGlobalResourceCache.OnResetDevice(pd3dDevice);
  if FAILED(Result) thenbegin    Result:= z3DError('OnResetDevice', z3DERR_RESETTINGDEVICEOBJECTS);
    Exit;
 end

  // Call the app's device reset callback if non-NULL
  z3DCore_GetState.InsideDeviceCallback := True;
  pCallbackDeviceReset := z3DCore_GetState.DeviceResetFunc;
  Result := S_OK;
  if (@pCallbackDeviceReset <> nil) then
    Result := pCallbackDeviceReset(z3DCore_GetD3DDevice, pbackBufferSurfaceDesc^, z3DCore_GetState.GetDeviceResetFuncUserContext);
  z3DCore_GetState.InsideDeviceCallback := False;
  if (z3DCore_GetD3DDevice = nil) then // Handle z3DShutdown from inside callbackbegin    Result:= E_FAIL;
    Exit;
 end

  if FAILED(Result) thenbegin    z3DError('DeviceReset callback', Result);
    if (Result <> z3DERR_MEDIANOTFOUND) then Result := z3DERR_RESETTINGDEVICEOBJECTS;
    Exit;
 end
  z3DCore_GetState.DeviceObjectsReset := True;

  Result:= S_OK;
#endif /* DOXYGEN_SKIP */
};

  
HRESULT z3DReset3DEnvironment ()

/*
var

  pd3dDevice: IDirect3DDevice9;
  pCallbackDeviceLost: Tz3DCallback_DeviceLost;
  pDeviceSettings: Pz3DDeviceSettings;
  pbackBufferSurfaceDesc: PD3DSurfaceDesc;
  pCallbackDeviceReset: Tz3DCallback_DeviceReset;
*/
{
#ifndef DOXYGEN_SKIP

  pd3dDevice := z3DCore_GetD3DDevice;     
  Assert(pd3dDevice <> nil);

  // Call the app's device lost callback
  if z3DCore_GetState.DeviceObjectsReset thenbegin    z3DCore_GetState.InsideDeviceCallback:= True;

    pCallbackDeviceLost := z3DCore_GetState.DeviceLostFunc;
    if (@pCallbackDeviceLost <> nil) then pCallbackDeviceLost(z3DCore_GetState.DeviceLostFuncUserContext);
    z3DCore_GetState.DeviceObjectsReset:= False;
    z3DCore_GetState.InsideDeviceCallback:= False;

    // Call the resource cache device lost function
    z3DCore_GetGlobalResourceCache.OnLostDevice;
 end

  // Reset the device
  pDeviceSettings := z3DCore_GetState.CurrentDeviceSettings;
  Result := pd3dDevice.Reset(pDeviceSettings.PresentParams);
  if FAILED(Result) thenbegin    if (Result = D3DERR_DEVICELOST)
    then Result := D3DERR_DEVICELOST // Reset could legitimately fail if the device is lost
    else Result := z3DError('Reset', z3DERR_RESETTINGDEVICE);
    Exit;
 end

  // Update back buffer desc before calling app's device callbacks
  z3DUpdateBackBufferDesc;

  // Setup cursor based on current settings (window/fullscreen mode, show cursor state, clip cursor state)
  z3DSetupCursor;

  Result := z3DCore_GetGlobalResourceCache.OnResetDevice(pd3dDevice);
  if FAILED(Result) thenbegin    Result:= z3DError('OnResetDevice', z3DERR_RESETTINGDEVICEOBJECTS);
    Exit;
 end

  // Call the app's OnDeviceReset callback
  z3DCore_GetState.SetInsideDeviceCallback(True);
  pbackBufferSurfaceDesc := z3DCore_GetBackBufferSurfaceDesc;
  pCallbackDeviceReset := z3DCore_GetState.DeviceResetFunc;
  Result := S_OK;
  if (@pCallbackDeviceReset <> nil) then
    Result := pCallbackDeviceReset(pd3dDevice, pbackBufferSurfaceDesc^, z3DCore_GetState.GetDeviceResetFuncUserContext);
  z3DCore_GetState.SetInsideDeviceCallback(False);
  if FAILED(Result) thenbegin    // If callback failed, cleanup
    z3DError('DeviceResetCallback', Result);
    if (Result <> z3DERR_MEDIANOTFOUND) then Result:= z3DERR_RESETTINGDEVICEOBJECTS;

    z3DCore_GetState.InsideDeviceCallback := True;

    pCallbackDeviceLost := z3DCore_GetState.DeviceLostFunc;
    if (@pCallbackDeviceLost <> nil) then pCallbackDeviceLost(z3DCore_GetState.DeviceLostFuncUserContext);

    z3DCore_GetState.InsideDeviceCallback := False;

    z3DCore_GetGlobalResourceCache.OnLostDevice;
    Exit;
 end

  // Success
  z3DCore_GetState.DeviceObjectsReset := True;
  
  Result:= S_OK;
#endif /* DOXYGEN_SKIP */
};

   
z3DCore_Pause (Boolean bPauseTime ,
Boolean bPauseRendering 
)

/*
var

  nPauseTimeCount: Integer;
  nPauseRenderingCount: Integer;
*/
{
#ifndef DOXYGEN_SKIP

  nPauseTimeCount := z3DCore_GetState.PauseTimeCount;
  Inc(nPauseTimeCount, IfThen(bPauseTime, +1, -1));
  if (nPauseTimeCount < 0) then nPauseTimeCount := 0;
  z3DCore_GetState.SetPauseTimeCount(nPauseTimeCount);

  nPauseRenderingCount := z3DCore_GetState.GetPauseRenderingCount;
  Inc(nPauseRenderingCount, IfThen(bPauseRendering, +1, -1));
  if (nPauseRenderingCount < 0) then nPauseRenderingCount := 0;
  z3DCore_GetState.SetPauseRenderingCount(nPauseRenderingCount);

  if (nPauseTimeCount > 0) then z3DCore_GetGlobalTimer.Stop else
  z3DCore_GetGlobalTimer.Start;

  z3DCore_GetState.SetRenderingPaused(nPauseRenderingCount > 0);
  z3DCore_GetState.SetTimePaused(nPauseTimeCount > 0);
#endif /* DOXYGEN_SKIP */
};

 
z3DCheckForWindowSizeChange ()

/*
var

  rcCurrentClient: TRect;
  deviceSettings: Tz3DDeviceSettings;
*/
{
#ifndef DOXYGEN_SKIP

  // Skip the check for various reasons
  if z3DCore_GetState.IgnoreSizeChange or
     not z3DCore_GetState.DeviceCreated or
     not z3DCore_GetState.CurrentDeviceSettings.PresentParams.Windowed
  then Exit;

  GetClientRect(z3DCore_GetHWND, rcCurrentClient);

  if (rcCurrentClient.right <> Integer(z3DCore_GetState.GetCurrentDeviceSettings.PresentParams.BackBufferWidth)) or
     (rcCurrentClient.bottom <> Integer(z3DCore_GetState.GetCurrentDeviceSettings.PresentParams.BackBufferHeight)) thenbegin    // A new window size will require a new backbuffer size
    // size, so the device must be reset and the D3D structures updated accordingly.

    // Tell z3DChangeDevice and D3D to size according to the HWND's client rect
    deviceSettings := z3DCore_GetDeviceSettings;
    deviceSettings.PresentParams.BackBufferWidth  := 0;
    deviceSettings.PresentParams.BackBufferHeight := 0;
    z3DChangeDevice(@deviceSettings, nil, False, False);
 end
#endif /* DOXYGEN_SKIP */
};

     
HRESULT z3DCore_MainLoop (HACCEL hAccel = 0 
)

/*
var
 msg: TMsg;
*/
{
#ifndef DOXYGEN_SKIP

  // Not allowed to call this from inside the device callbacks or reenter
  if (z3DCore_GetState.InsideDeviceCallback or z3DCore_GetState.InsideMainloop) thenbegin    if (z3DCore_GetState.ExitCode = 0) or (z3DCore_GetState.GetExitCode = 11) then z3DCore_GetState.ExitCode:= 1;
    Result:= z3DErrorMessage('z3DMainLoop', E_FAIL);
    Exit;
 end

  z3DCore_GetState.InsideMainloop:= True;

  // If z3DCreateDevice*() or z3DSetDevice() has not already been called,
  // then call z3DCreateDevice() with the default parameters.
  if not z3DCore_GetState.DeviceCreated thenbegin    if z3DCore_GetState.DeviceCreateCalled thenbegin      if (z3DCore_GetState.ExitCode = 0) or (z3DCore_GetState.GetExitCode = 11) then z3DCore_GetState.ExitCode:= 1;
      Result:= E_FAIL; // z3DCreateDevice() must first succeed for this function to succeed
      Exit;
   end

    Result := z3DCore_CreateDevice;
    if FAILED(Result) thenbegin      if (z3DCore_GetState.ExitCode = 0) or (z3DCore_GetState.GetExitCode = 11) then z3DCore_GetState.ExitCode:= 1;
      Exit;
   end
 end

  if not z3DCore_GetState.z3DInited or not z3DCore_GetState.WindowCreated or not z3DCore_GetState.DeviceCreated thenbegin    if (z3DCore_GetState.ExitCode = 0) or (z3DCore_GetState.GetExitCode = 11) then z3DCore_GetState.ExitCode:= 1;
    Result:= z3DErrorMessage('z3DMainLoop', E_FAIL);
    Exit;
 end


  // Process Windows messages
  msg.message := WM_NULL;
  PeekMessage(msg, 0, 0, 0, PM_NOREMOVE);

  while (WM_QUIT <> msg.message) do msg.message:= z3DCore_ProcessMessages;

  // Cleanup the accelerator table
  if (hAccel <> 0) then DestroyAcceleratorTable(hAccel);

  z3DCore_GetState.InsideMainloop:= False;

  Result:= S_OK;
#endif /* DOXYGEN_SKIP */
};

          
UINT z3DCore_ProcessMessages (HACCEL hAccel = 0 ,
const Boolean ARender = True 
)

/*
var
 bGotMsg: LongBool;
    hWnd: Windows.HWND;
    msg: TMsg;
*/
{
#ifndef DOXYGEN_SKIP

  hWnd := z3DCore_GetHWND;

  // Use PeekMessage() so we can use idle time to render the scene
  bGotMsg := PeekMessage(msg, 0, 0, 0, PM_REMOVE);

  if bGotMsg thenbegin    // Translate and dispatch the message
    if (hAccel = 0) or (hWnd = 0) or
       (0 = TranslateAccelerator(hWnd, hAccel, msg)) thenbegin      TranslateMessage(msg);
      DispatchMessage(msg);
   end
 endelse
  if ARender thenbegin    // Render a frame during idle time (no messages are waiting)
    z3DCore_Render3DEnvironment 
 end
  Result:= msg.message;
#endif /* DOXYGEN_SKIP */
};

 
z3DCore_Render3DEnvironment ()

/*
var

  pd3dDevice: IDirect3DDevice9;
  hr: HRESULT;
  adapterDesktopDisplayMode: TD3DDisplayMode;
  pD3D: IDirect3D9;
  pDeviceSettings: Pz3DDeviceSettings;
  matchOptions: Tz3DMatchOptions;
  deviceSettings: Tz3DDeviceSettings;
  fTime, fAbsTime: Double;
  fElapsedTime: Single;
  pCallbackFrameMove: Tz3DCallback_FrameMove;
  pCallbackFrameRender: Tz3DCallback_FrameRender;
  nFrame: Integer;
#ifdef  DEBUG

  rcClient: TRect;
#endif

*/
{
#ifndef DOXYGEN_SKIP

  if z3DCore_GetState.DeviceLost or z3DCore_IsRenderingPaused or not z3DCore_IsActive thenbegin    // Window is minimized or paused so yield CPU time to other processes
    Sleep(20);
 end

  pd3dDevice := z3DCore_GetD3DDevice;
  if (pd3dDevice = nil) thenbegin    if z3DCore_GetState.DeviceLost thenbegin      deviceSettings := z3DCore_GetDeviceSettings;
      z3DChangeDevice(@deviceSettings, nil, False, True);
   end
    Exit;
 end

  if z3DCore_GetState.DeviceLost and not z3DCore_GetState.RenderingPaused thenbegin    // Test the cooperative level to see if it's okay to render
    hr:= pd3dDevice.TestCooperativeLevel;
    if FAILED(hr) thenbegin      if (hr = D3DERR_DEVICELOST) thenbegin        // The device has been lost but cannot be reset at this time.
        // So wait until it can be reset.
        Exit;
     end

      // If we are windowed, read the desktop format and
      // ensure that the Direct3D device is using the same format
      // since the user could have changed the desktop bitdepth
      if z3DCore_IsWindowed thenbegin        pD3D := z3DCore_GetD3DObject;
        pDeviceSettings := z3DCore_GetState.CurrentDeviceSettings;
        pD3D.GetAdapterDisplayMode(pDeviceSettings.AdapterOrdinal, adapterDesktopDisplayMode);
        if (pDeviceSettings.AdapterFormat <> adapterDesktopDisplayMode.Format) thenbegin          matchOptions.eAdapterOrdinal     := z3DMT_PRESERVE_INPUT;
          matchOptions.eDeviceType         := z3DMT_PRESERVE_INPUT;
          matchOptions.eWindowed           := z3DMT_PRESERVE_INPUT;
          matchOptions.eAdapterFormat      := z3DMT_PRESERVE_INPUT;
          matchOptions.eVertexProcessing   := z3DMT_CLOSEST_TO_INPUT;
          matchOptions.eResolution         := z3DMT_CLOSEST_TO_INPUT;
          matchOptions.eBackBufferFormat   := z3DMT_CLOSEST_TO_INPUT;
          matchOptions.eBackBufferCount    := z3DMT_CLOSEST_TO_INPUT;
          matchOptions.eMultiSample        := z3DMT_CLOSEST_TO_INPUT;
          matchOptions.eSwapEffect         := z3DMT_CLOSEST_TO_INPUT;
          matchOptions.eDepthFormat        := z3DMT_CLOSEST_TO_INPUT;
          matchOptions.eStencilFormat      := z3DMT_CLOSEST_TO_INPUT;
          matchOptions.ePresentFlags       := z3DMT_CLOSEST_TO_INPUT;
          matchOptions.eRefreshRate        := z3DMT_CLOSEST_TO_INPUT;
          matchOptions.ePresentInterval    := z3DMT_CLOSEST_TO_INPUT;

          deviceSettings := z3DCore_GetDeviceSettings;
          deviceSettings.AdapterFormat := adapterDesktopDisplayMode.Format;

          hr := z3DCore_FindValidDeviceSettings(deviceSettings, @deviceSettings, @matchOptions);
          if FAILED(hr) then // the call will fail if no valid devices were foundbegin            z3DDisplayErrorMessage(z3DERR_NOCOMPATIBLEDEVICES);
            z3DCore_Shutdown;
         end

          // Change to a Direct3D device created from the new device settings.
          // If there is an existing device, then either reset or recreate the scene
          hr := z3DChangeDevice(@deviceSettings, nil, False, False);
          if FAILED(hr) thenbegin            // If this fails, try to go fullscreen and if this fails also shutdown.
            if FAILED(z3DCore_ToggleFullScreen) then z3DCore_Shutdown;
         end

          Exit;
       end
     end

      // Try to reset the device
      hr := z3DReset3DEnvironment;
      if FAILED(hr) thenbegin        if (D3DERR_DEVICELOST = hr) thenbegin          // The device was lost again, so continue waiting until it can be reset.
          Exit;
       end        else if (hr = z3DERR_RESETTINGDEVICEOBJECTS) or
                (hr = z3DERR_MEDIANOTFOUND) thenbegin          z3DDisplayErrorMessage(hr) 
          z3DCore_Shutdown;
          Exit;
       endelsebegin          // Reset failed, but the device wasn't lost so something bad happened,
          // so recreate the device to try to recover
          z3DTrace('z3DCore_Render3DEnvironment failed (unknown error z3DReset3DEnvironment). Trying to recover', z3dtkWarning) 
          pDeviceSettings := z3DCore_GetState.GetCurrentDeviceSettings;
          if FAILED(z3DChangeDevice(pDeviceSettings, nil, True, False)) thenbegin            z3DCore_Shutdown;
            Exit;
         end
       end
     end
   end

    z3DCore_GetState.DeviceLost:= False;
 end

  // Get the app's time, in seconds. Skip rendering if no time elapsed
  z3DCore_GetGlobalTimer.GetTimeValues(fTime, fAbsTime, fElapsedTime);

  // Store the time for the app
  if z3DCore_GetState.ConstantFrameTime thenbegin    fElapsedTime := z3DCore_GetState.TimePerFrame;
    fTime        := z3DCore_GetTime + fElapsedTime;
 end

  z3DCore_GetState.SetTime(fTime);
  z3DCore_GetState.SetAbsoluteTime(fAbsTime);
  z3DCore_GetState.SetElapsedTime(fElapsedTime);

  // Update the FPS stats
  z3DUpdateFrameStats;

  z3DHandleTimers;

  // Animate the scene by calling the app's frame move callback
  pCallbackFrameMove := z3DCore_GetState.FrameMoveFunc;
  if (@pCallbackFrameMove <> nil) thenbegin    pCallbackFrameMove(pd3dDevice, fTime, fElapsedTime, z3DCore_GetState.FrameMoveFuncUserContext);
    pd3dDevice := z3DCore_GetD3DDevice;
    if (pd3dDevice = nil) then Exit; // Handle z3DShutdown from inside callback
 end

  if not z3DCore_GetState.RenderingPaused thenbegin    // Render the scene by calling the app's render callback
    pCallbackFrameRender := z3DCore_GetState.FrameRenderFunc;
    if (@pCallbackFrameRender <> nil) thenbegin      pCallbackFrameRender(pd3dDevice, fTime, fElapsedTime, z3DCore_GetState.FrameRenderFuncUserContext);
      pd3dDevice := z3DCore_GetD3DDevice;
      if (pd3dDevice = nil) then Exit; // Handle z3DShutdown from inside callback
   end

#ifdef  DEBUG

    // The back buffer should always match the client rect
    // if the Direct3D backbuffer covers the entire window
    GetClientRect(z3DCore_GetHWND, rcClient);
    if not IsIconic(z3DCore_GetHWND) thenbegin      GetClientRect(z3DCore_GetHWND, rcClient);
      Assert(z3DCore_GetBackBufferSurfaceDesc.Width = LongWord(rcClient.right));
      Assert(z3DCore_GetBackBufferSurfaceDesc.Height = LongWord(rcClient.bottom));
   end
#endif


    // Show the frame on the primary surface.
    hr := pd3dDevice.Present(nil, nil, 0, nil);
    if FAILED(hr) thenbegin      if (D3DERR_DEVICELOST = hr) thenbegin        z3DCore_GetState.SetDeviceLost(True);
     end      else if (D3DERR_DRIVERINTERNALERROR = hr) thenbegin        // When D3DERR_DRIVERINTERNALERROR is returned from Present(),
        // the application can do one of the following:
        //
        // - End, with the pop-up window saying that the application cannot continue
        //   because of problems in the display adapter and that the user should
        //   contact the adapter manufacturer.
        //
        // - Attempt to restart by calling IDirect3DDevice9::Reset, which is essentially the same
        //   path as recovering from a lost device. If IDirect3DDevice9::Reset fails with
        //   D3DERR_DRIVERINTERNALERROR, the application should end immediately with the message
        //   that the user should contact the adapter manufacturer.
        //
        z3DTrace('z3DCore_Render3DEnvironment failed (internal driver error on IDirect3DDevice9.Present). Trying to recover', z3dtkWarning) 
        z3DCore_GetState.SetDeviceLost(True);
     end
   end
 end

  // Update current frame #
  nFrame := z3DCore_GetState.CurrentFrameNumber;
  Inc(nFrame);
  z3DCore_GetState.CurrentFrameNumber:= nFrame;

  // Check to see if the app should shutdown due to cmdline
  if (z3DCore_GetState.OverrideQuitAfterFrame <> 0) then
    if (nFrame > z3DCore_GetState.OverrideQuitAfterFrame) then z3DCore_Shutdown;
#endif /* DOXYGEN_SKIP */
};

       
z3DUpdateDeviceStats (TD3DDevType DeviceType ,
DWORD BehaviorFlags ,
const TD3DAdapterIdentifier9 pAdapterIdentifier 
)

/*
//const

  cchDesc = SizeOf(pAdapterIdentifier.Description);
var
  pstrDeviceStats: PWideChar;
  szDescription: array[0..cchDesc-1] of WideChar;
  pDeviceSettings: Pz3DDeviceSettings;
  pd3dEnum: Iz3DDeviceList;
  pDeviceSettingsCombo: PD3DDeviceSettingsCombinations;
*/
{
#ifndef DOXYGEN_SKIP

  if z3DCore_GetState.NoStats then Exit;

  // Store device description
  pstrDeviceStats := z3DCore_GetState.GetDeviceStats;
  if (DeviceType = D3DDEVTYPE_REF) then StringCchCopy(pstrDeviceStats, 256, 'REF')
  else if (DeviceType = D3DDEVTYPE_HAL) then StringCchCopy(pstrDeviceStats, 256, 'HAL')
  else if (DeviceType = D3DDEVTYPE_SW)  then StringCchCopy(pstrDeviceStats, 256, 'SW');

  if (BehaviorFlags and D3DCREATE_HARDWARE_VERTEXPROCESSING <> 0) and
     (BehaviorFlags and D3DCREATE_PUREDEVICE <> 0) thenbegin    if (DeviceType = D3DDEVTYPE_HAL)
    then StringCchCat(pstrDeviceStats, 256, ' (pure hardware vp)')
    else StringCchCat(pstrDeviceStats, 256, ' (simulated pure hardware vp)');
 end  else if (BehaviorFlags and D3DCREATE_HARDWARE_VERTEXPROCESSING <> 0) thenbegin    if (DeviceType = D3DDEVTYPE_HAL)
    then StringCchCat(pstrDeviceStats, 256, ' (hardware vp)')
    else StringCchCat(pstrDeviceStats, 256, ' (simulated hardware vp)') 
 end  else if (BehaviorFlags and D3DCREATE_MIXED_VERTEXPROCESSING <> 0) thenbegin    if (DeviceType = D3DDEVTYPE_HAL)
    then StringCchCat(pstrDeviceStats, 256, ' (mixed vp)')
    else StringCchCat(pstrDeviceStats, 256, ' (simulated mixed vp)') 
 end  else if (BehaviorFlags and D3DCREATE_SOFTWARE_VERTEXPROCESSING <> 0) thenbegin    StringCchCat(pstrDeviceStats, 256, ' (software vp)') 
 end

  if (DeviceType = D3DDEVTYPE_HAL) thenbegin    // Be sure not to overflow m_strDeviceStats when appending the adapter
    // description, since it can be long.
    StringCchCat(pstrDeviceStats, 256, ': ');

    // Try to get a unique description from the CD3DDeviceSettingsCombinations
    pDeviceSettings := z3DCore_GetState.GetCurrentDeviceSettings;
    pd3dEnum := z3DPrepareDeviceListObject;
    pDeviceSettingsCombo := pd3dEnum.GetDeviceSettingsCombo(pDeviceSettings.AdapterOrdinal, pDeviceSettings.DeviceType, pDeviceSettings.AdapterFormat, pDeviceSettings.PresentParams.BackBufferFormat, pDeviceSettings.PresentParams.Windowed);
    if (pDeviceSettingsCombo <> nil) thenbegin      StringCchCat(pstrDeviceStats, 256, pDeviceSettingsCombo.AdapterInfo.UniqueDescription^);
   endelsebegin      MultiByteToWideChar(CP_ACP, 0, pAdapterIdentifier.Description, -1, szDescription, cchDesc) 
      szDescription[cchDesc-1] := #0;
      StringCchCat(pstrDeviceStats, 256, szDescription);
   end
 end
#endif /* DOXYGEN_SKIP */
};

 
z3DUpdateFrameStats ()

/*
var

  fLastTime: Double;
  dwFrames: DWORD;
  fAbsTime: Double;
  fFPS: Single;
  pstrFPS: PWideChar;
*/
{
#ifndef DOXYGEN_SKIP

  if z3DCore_GetState.NoStats then Exit;

  // Keep track of the frame count
  fLastTime := z3DCore_GetState.LastStatsUpdateTime;
  dwFrames  := z3DCore_GetState.LastStatsUpdateFrames;
  fAbsTime  := z3DCore_GetState.AbsoluteTime;
  Inc(dwFrames);
  z3DCore_GetState.LastStatsUpdateFrames:= dwFrames;

  // Update the scene stats by the given interval
  if (fAbsTime - fLastTime > z3DCore_GetState.GetStatsUpdateInterval) thenbegin    fFPS := (dwFrames / (fAbsTime - fLastTime));
    z3DCore_GetState.FPS:= fFPS;
    z3DCore_GetState.LastStatsUpdateTime:= fAbsTime;
    z3DCore_GetState.LastStatsUpdateFrames:= 0;

    pstrFPS := z3DCore_GetState.FPSStats;
    StringCchFormat(pstrFPS, 64, '%f FPS', [fFPS]);
 end
#endif /* DOXYGEN_SKIP */
};

 
z3DUpdateStaticFrameStats ()

/*
//const

  VSyncDesc: array[False..True] of PWideChar = ('off', 'on');
var
  pDeviceSettings: Pz3DDeviceSettings;
  pd3dEnum: Iz3DDeviceList;
  pDeviceSettingsCombo: PD3DDeviceSettingsCombinations;
  pPP: PD3DPresentParameters;
  strFmt, strDepthFmt, strMultiSample: array[0..99] of WideChar;
  pstrStaticFrameStats: PWideChar;
*/
{
#ifndef DOXYGEN_SKIP

  if z3DCore_GetState.NoStats then Exit;

  pDeviceSettings := z3DCore_GetState.GetCurrentDeviceSettings;
  if (pDeviceSettings = nil) then Exit;

  pd3dEnum := z3DPrepareDeviceListObject;
  if (pd3dEnum = nil) then Exit;

  pDeviceSettingsCombo := pd3dEnum.GetDeviceSettingsCombo(pDeviceSettings.AdapterOrdinal,
                            pDeviceSettings.DeviceType, pDeviceSettings.AdapterFormat,
                            pDeviceSettings.PresentParams.BackBufferFormat, pDeviceSettings.PresentParams.Windowed);
  if (pDeviceSettingsCombo = nil) then Exit;

  pPP := @pDeviceSettings.PresentParams;

  if (pDeviceSettingsCombo.AdapterFormat = pDeviceSettingsCombo.BackBufferFormat) thenbegin    StringCchCopy(strFmt, 100, z3DD3DFormatToString(pDeviceSettingsCombo.AdapterFormat, False));
 endelsebegin    StringCchFormat(strFmt, 100, 'backbuffer: %s, adapter: %s',
      [z3DD3DFormatToString(pDeviceSettingsCombo.BackBufferFormat, False),
       z3DD3DFormatToString(pDeviceSettingsCombo.AdapterFormat, False)]) 
 end

  if pPP.EnableAutoDepthStencil thenbegin    StringCchFormat(strDepthFmt, 100, ' (depth stencil %s)', [z3DD3DFormatToString(pPP.AutoDepthStencilFormat, False)]);
 endelsebegin    // No depth buffer
    strDepthFmt[0] := #0 
 end

  case pPP.MultiSampleType of

    D3DMULTISAMPLE_NONMASKABLE: StringCchCopy(strMultiSample, 100, ' (Nonmaskable Multisample)');
    D3DMULTISAMPLE_NONE:        StringCchCopy(strMultiSample, 100, '');
    else                        StringCchFormat(strMultiSample, 100, ' (%dx Multisample)', [Ord(pPP.MultiSampleType)]);
 end
  strMultiSample[99] := #0;

  pstrStaticFrameStats := z3DCore_GetState.StaticFrameStats;

  StringCchFormat(pstrStaticFrameStats, 256, '%%sVertical sync is %s - %dx%d - %s%s%s',
              [VSyncDesc[pPP.PresentationInterval <> D3DPRESENT_INTERVAL_IMMEDIATE],
              pPP.BackBufferWidth, pPP.BackBufferHeight,
              strFmt, strDepthFmt, strMultiSample]);
#endif /* DOXYGEN_SKIP */
};


     
PWideChar z3DCore_GetFrameStats (Boolean bIncludeFPS = False 
)

/*
var

  pstrFrameStats: PWideChar;
  pstrFPS: PWideChar;
*/
{
#ifndef DOXYGEN_SKIP

  pstrFrameStats := z3DCore_GetState.GetFrameStats;
  if bIncludeFPS then pstrFPS := z3DCore_GetState.GetFPSStats else pstrFPS := '';
  StringCchFormat(pstrFrameStats, 256, z3DCore_GetState.GetStaticFrameStats, [pstrFPS]);
  Result:= pstrFrameStats;
#endif /* DOXYGEN_SKIP */
};


         
LRESULT z3DCore_StaticWndProc (Windows::ND hWnd ,
LongWord uMsg ,
WPARAM wParam ,
LPARAM lParam 
)

/*
var

  pCallbackKeyboard: Tz3DCallback_Keyboard;
  bKeyDown, bAltDown: Boolean;
  dwMask: DWORD;
  pCallbackMouse: Tz3DCallback_Mouse;
  xPos, yPos: Integer;
  pt: TPoint;
  nMouseWheelDelta: Integer;
  nMouseButtonState: Integer;
  bLeftButton, bRightButton, bMiddleButton, bSideButton1, bSideButton2: Boolean;
  pCallbackMsgProc: Tz3DCallback_MsgProc;
  bNoFurtherProcessing: Boolean;
  nResult: LRESULT;
  pd3dDevice: IDirect3DDevice9;
  hr: HRESULT;
  fTime: Double;
  fElapsedTime: Single;
  pCallbackFrameRender: Tz3DCallback_FrameRender;
  ptCursor: TPoint;
  bWireFrame: Boolean;
  bTimePaused: Boolean;
  hMenu: Windows.HMENU;
  bKeys: Pz3DKeysArray;
  bMouseButtons: Pz3DMouseButtonsArray;
  rcCurrentClient: TRect;
*/
{
#ifndef DOXYGEN_SKIP

  if (uMsg = WM_KEYDOWN) or
     (uMsg = WM_SYSKEYDOWN) or
     (uMsg = WM_KEYUP) or
     (uMsg = WM_SYSKEYUP) thenbegin    bKeyDown := (uMsg = WM_KEYDOWN) or (uMsg = WM_SYSKEYDOWN);
    dwMask := (1 shl 29);
    bAltDown := ((lParam and dwMask) <> 0);

    bKeys := z3DCore_GetState.Keys;
    bKeys[Byte(wParam and $FF)] := bKeyDown;

    pCallbackKeyboard := z3DCore_GetState.KeyboardFunc;
    if (@pCallbackKeyboard <> nil) then
      pCallbackKeyboard(wParam, bKeyDown, bAltDown, z3DCore_GetState.KeyboardFuncUserContext);
 end

  // Consolidate the mouse button messages and pass them to the app's mouse callback
  if (uMsg = WM_LBUTTONDOWN) or
     (uMsg = WM_LBUTTONUP) or
     (uMsg = WM_LBUTTONDBLCLK) or
     (uMsg = WM_MBUTTONDOWN) or
     (uMsg = WM_MBUTTONUP) or
     (uMsg = WM_MBUTTONDBLCLK) or
     (uMsg = WM_RBUTTONDOWN) or
     (uMsg = WM_RBUTTONUP) or
     (uMsg = WM_RBUTTONDBLCLK) or
     (uMsg = WM_XBUTTONDOWN) or
     (uMsg = WM_XBUTTONUP) or
     (uMsg = WM_XBUTTONDBLCLK) or
     (uMsg = WM_MOUSEWHEEL) or
     (z3DCore_GetState.NotifyOnMouseMove and (uMsg = WM_MOUSEMOVE)) thenbegin    xPos := LOWORD(DWORD(lParam));
    yPos := HIWORD(DWORD(lParam));

    if (uMsg = WM_MOUSEWHEEL) thenbegin      // WM_MOUSEWHEEL passes screen mouse coords
      // so convert them to client coords
      pt.x := xPos; pt.y := yPos;
      ScreenToClient(hWnd, pt);
      xPos := pt.x; yPos := pt.y;
   end

    nMouseWheelDelta := 0;
    if (uMsg = WM_MOUSEWHEEL)
    then nMouseWheelDelta := HIWORD(DWORD(wParam));

    nMouseButtonState := LOWORD(DWORD(wParam));
    bLeftButton  := ((nMouseButtonState and MK_LBUTTON) <> 0);
    bRightButton := ((nMouseButtonState and MK_RBUTTON) <> 0);
    bMiddleButton := ((nMouseButtonState and MK_MBUTTON) <> 0);
    bSideButton1 := ((nMouseButtonState and MK_XBUTTON1) <> 0);
    bSideButton2 := ((nMouseButtonState and MK_XBUTTON2) <> 0);

    bMouseButtons := z3DCore_GetState.MouseButtons;
    bMouseButtons[0] := bLeftButton;
    bMouseButtons[1] := bMiddleButton;
    bMouseButtons[2] := bRightButton;
    bMouseButtons[3] := bSideButton1;
    bMouseButtons[4] := bSideButton2;

    pCallbackMouse := z3DCore_GetState.MouseFunc;
    if (@pCallbackMouse <> nil) then
      pCallbackMouse(bLeftButton, bRightButton, bMiddleButton,
                     bSideButton1, bSideButton2, nMouseWheelDelta,
                     xPos, yPos, z3DCore_GetState.MouseFuncUserContext);
 end

  // Pass all messages to the app's MsgProc callback, and don't
  // process further messages if the apps says not to.
  pCallbackMsgProc := z3DCore_GetState.WindowMsgFunc;
  if (@pCallbackMsgProc <> nil) thenbegin    bNoFurtherProcessing := False;
    nResult := pCallbackMsgProc(hWnd, uMsg, wParam, lParam, bNoFurtherProcessing, z3DCore_GetState.WindowMsgFuncUserContext);
    if bNoFurtherProcessing thenbegin      Result:= nResult;
      Exit;
   end
 end

  case uMsg of

    WM_PAINT:
    begin      pd3dDevice := z3DCore_GetD3DDevice;

      // Handle paint messages when the app is paused
      if (pd3dDevice <> nil) and z3DCore_IsRenderingPaused and
         z3DCore_GetState.DeviceObjectsCreated and z3DCore_GetState.DeviceObjectsReset thenbegin        fTime := z3DCore_GetTime;
        fElapsedTime := z3DCore_GetElapsedTime;

        pCallbackFrameRender := z3DCore_GetState.FrameRenderFunc;
        if (@pCallbackFrameRender <> nil) then
          pCallbackFrameRender(pd3dDevice, fTime, fElapsedTime, z3DCore_GetState.FrameRenderFuncUserContext);

        hr := pd3dDevice.Present(nil, nil, 0, nil);
        if (D3DERR_DEVICELOST = hr) thenbegin          z3DCore_GetState.SetDeviceLost(True);
       end        else if (D3DERR_DRIVERINTERNALERROR = hr) thenbegin          // When D3DERR_DRIVERINTERNALERROR is returned from Present(),
          // the application can do one of the following:
          //
          // - End, with the pop-up window saying that the application cannot continue
          //   because of problems in the display adapter and that the user should
          //   contact the adapter manufacturer.
          //
          // - Attempt to restart by calling IDirect3DDevice9::Reset, which is essentially the same
          //   path as recovering from a lost device. If IDirect3DDevice9::Reset fails with
          //   D3DERR_DRIVERINTERNALERROR, the application should end immediately with the message
          //   that the user should contact the adapter manufacturer.
          //
          z3DCore_GetState.SetDeviceLost(True) 
       end
     end
   end

    WM_SIZE:
    begin      if (SIZE_MINIMIZED = wParam) thenbegin        z3DCore_Pause(True, True); // Pause while we're minimized
        z3DCore_GetState.SetMinimized(True);
        z3DCore_GetState.SetMaximized(False);
     endelsebegin        GetClientRect(z3DCore_GetHWND, rcCurrentClient) 
        if (rcCurrentClient.top = 0) and (rcCurrentClient.bottom = 0) thenbegin          // Rapidly clicking the task bar to minimize and restore a window
          // can cause a WM_SIZE message with SIZE_RESTORED when
          // the window has actually become minimized due to rapid change
          // so just ignore this message
        end        else if (SIZE_MAXIMIZED = wParam) thenbegin          if z3DCore_GetState.Minimized then
            z3DCore_Pause(False, False)  // Unpause since we're no longer minimized

          z3DCore_GetState.Minimized := False;
          z3DCore_GetState.Maximized := True;
          z3DCheckForWindowSizeChange;
          z3DCheckForWindowChangingMonitors;
       end        else if (SIZE_RESTORED = wParam) thenbegin          if z3DCore_GetState.Maximized thenbegin            z3DCore_GetState.Maximized := False 
            z3DCheckForWindowSizeChange;
            z3DCheckForWindowChangingMonitors;
         end          else if z3DCore_GetState.Minimized thenbegin            z3DCore_Pause(False, False)  // Unpause since we're no longer minimized
            z3DCore_GetState.Minimized := False;
            z3DCheckForWindowSizeChange;
            z3DCheckForWindowChangingMonitors;
         endelse
          if z3DCore_GetState.InSizeMove thenbegin            // If we're neither maximized nor minimized, the window size
            // is changing by the user dragging the window edges.  In this
            // case, we don't reset the device yet -- we wait until the
            // user stops dragging, and a WM_EXITSIZEMOVE message comes.
         endelsebegin            // This WM_SIZE come from resizing the window via an API like SetWindowPos() so
            // resize and reset the device now.
            z3DCheckForWindowSizeChange 
            z3DCheckForWindowChangingMonitors 
         end
       end     end
   end

    WM_GETMINMAXINFO:
    begin      PMinMaxInfo(lParam).ptMinTrackSize.x := z3D_MIN_WINDOW_SIZE_X 
      PMinMaxInfo(lParam).ptMinTrackSize.y := z3D_MIN_WINDOW_SIZE_Y;
   end

    WM_ENTERSIZEMOVE:
    begin      // Halt frame movement while the app is sizing or moving
      z3DCore_Pause(True, True);
      z3DCore_GetState.InSizeMove := True;
   end

    WM_EXITSIZEMOVE:
    begin      z3DCore_Pause(False, False);
      z3DCheckForWindowSizeChange;
      z3DCheckForWindowChangingMonitors;
      z3DCore_GetState.InSizeMove := False;
   end

    WM_MOUSEMOVE:
    begin      if not z3DCore_IsActive and not z3DCore_IsWindowed thenbegin        pd3dDevice := z3DCore_GetD3DDevice;
        if (pd3dDevice <> nil) thenbegin          GetCursorPos(ptCursor);
          pd3dDevice.SetCursorPosition(ptCursor.x, ptCursor.y, 0);
       end
     end
   end

    WM_SETCURSOR:
    begin      if z3DCore_IsActive and not z3DCore_IsWindowed thenbegin        pd3dDevice := z3DCore_GetD3DDevice;
        if Assigned(pd3dDevice) and z3DCore_GetState.ShowCursorWhenFullScreen then pd3dDevice.ShowCursor(True);
        Result:= iTrue; // prevent Windows from setting cursor to window class cursor
        Exit;
     end
   end

    WM_ACTIVATEAPP:
    begin      if (wParam = Integer(iTrue)) and not z3DCore_IsActive then // Handle only if previously not activebegin        z3DCore_GetState.Active := True;

        // Disable any controller rumble & input when de-activating app
        z3DEnableXInput(True);

        // The GetMinimizedWhileFullscreen() varible is used instead of !z3DCore_IsWindowed()
        // to handle the rare case toggling to windowed mode while the fullscreen application
        // is minimized and thus making the pause count wrong
        if z3DCore_GetState.MinimizedWhileFullscreen thenbegin          z3DCore_Pause(False, False); // Unpause since we're no longer minimized
          z3DCore_GetState.MinimizedWhileFullscreen := False;
       end

        // Upon returning to this app, potentially disable shortcut keys
        // (Windows key, accessibility shortcuts)
        if z3DCore_IsWindowed
        then z3DAllowShortcutKeys(z3DCore_GetState.AllowShortcutKeysWhenWindowed)
        else z3DAllowShortcutKeys(z3DCore_GetState.AllowShortcutKeysWhenFullscreen);

     end      else if (wParam = Integer(iFalse)) and z3DCore_IsActive then // Handle only if previously activebegin        z3DCore_GetState.Active := False 

        // Disable any controller rumble & input when de-activating app
        z3DEnableXInput(False);

        if not z3DCore_IsWindowed thenbegin          // Going from full screen to a minimized state
          ClipCursor(nil);      // don't limit the cursor anymore
          z3DCore_Pause(True, True); // Pause while we're minimized (take care not to pause twice by handling Self message twice)
          z3DCore_GetState.MinimizedWhileFullscreen := True;
       end

        // Restore shortcut keys (Windows key, accessibility shortcuts) to original state
        //
        // This is important to call here if the shortcuts are disabled,
        // because if this is not done then the Windows key will continue to
        // be disabled while this app is running which is very bad.
        // If the app crashes, the Windows key will return to normal.
        z3DAllowShortcutKeys(True);
     end
   end

    WM_ENTERMENULOOP:
      // Pause the app when menus are displayed
      z3DCore_Pause(True, True);

    WM_EXITMENULOOP:
      z3DCore_Pause(False, False);

    WM_MENUCHAR:
    begin      // A menu is active and the user presses a key that does not correspond to any mnemonic or accelerator key
      // So just ignore and don't beep
      #ifndef  FPC

      Result:= MAKELRESULT(0, MNC_CLOSE);
      #else

      Result:= MAKELRESULT(0, /*MNC_CLOSE*/ 1);
      #endif

      Exit;
   end

    WM_NCHITTEST:
      // Prevent the user from selecting the menu in full screen mode
      if not z3DCore_IsWindowed thenbegin        Result:= HTCLIENT;
        Exit;
     end

    WM_POWERBROADCAST:
      case wParam of
        /*{$IFNDEF PBT_APMQUERYSUSPEND*/ 
            const PBT_APMQUERYSUSPEND 0x0000
        #endif
*/ 
        0: /*PBT_APMQUERYSUSPEND*/ 
        begin
          // At this point, the app should save any data for open
          // network connections, files, etc., and prepare to go into
          // a suspended mode.  The app can use the MsgProc callback
          // to handle this if desired.
          Result:= iTrue;
          Exit;
        end;

        /*#ifndef PBT_APMRESUMESUSPEND
            #define PBT_APMRESUMESUSPEND 0x0007
        #endif*)
        7: {PBT_APMRESUMESUSPEND*/ 
        begin
          // At this point, the app should recover any data, network
          // connections, files, etc., and resume running from when
          // the app was suspended. The app can use the MsgProc callback
          // to handle this if desired.

          // QPC may lose consistency when suspending, so reset the timer
          // upon resume.
          z3DCore_GetGlobalTimer.Reset;
          z3DCore_GetState.SetLastStatsUpdateTime(0);
          Result:= iTrue;
          Exit;
        end;
      end;

    WM_SYSCOMMAND:
      // Prevent moving/sizing in full screen mode
      case wParam of
        SC_MOVE,
        SC_SIZE,
        SC_MAXIMIZE,
        SC_KEYMENU:
          if not z3DCore_IsWindowed then
          begin
            Result:= 0;
            Exit;
          end;
      end;

    WM_SYSKEYDOWN:
    begin
      case wParam of
        VK_RETURN:
        begin
          if z3DCore_GetState.HandleAltEnter then
          begin
            // Toggle full screen upon alt-enter
            dwMask := (1 shl 29);
            if ((lParam and dwMask) <> 0) then // Alt is down also
            begin
              // Toggle the full screen/window mode
              z3DCore_Pause(True, True);
              z3DCore_ToggleFullScreen;
              z3DCore_Pause(False, False);
              Result:= 0;
              Exit;
            end;
          end;
        end;
      end;
    end;

    WM_KEYDOWN:
    begin
      if z3DCore_GetState.HandleDefaultHotkeys then
      begin
        case wParam of
          VK_F3:
          begin
            z3DCore_Pause(True, True);
            z3DCore_ToggleREF;
            z3DCore_Pause(False, False);
          end;

          VK_F8:
          begin
            bWireFrame := z3DCore_GetState.GetWireframeMode;
            bWireFrame := not bWireFrame;
            z3DCore_GetState.SetWireframeMode(bWireFrame);

            pd3dDevice := z3DCore_GetD3DDevice;
            if (pd3dDevice <> nil)
            then pd3dDevice.SetRenderState(D3DRS_FILLMODE, IfThen(bWireFrame, D3DFILL_WIREFRAME, D3DFILL_SOLID));
          end;

          VK_PAUSE:
          begin
            bTimePaused := z3DCore_IsTimePaused;
            bTimePaused := not bTimePaused;
            if bTimePaused
            then z3DCore_Pause(True,  False)
            else z3DCore_Pause(False, False);
          end;
        end;
      end;
    end;

    WM_CLOSE:
    begin
      hMenu := GetMenu(hWnd);
      if (hMenu <> 0) then DestroyMenu(hMenu);
      DestroyWindow(hWnd);
      Windows.UnClass('Direct3DWindowClass', 0);
      z3DCore_GetState.SetHWNDFocus(0);
      z3DCore_GetState.SetHWNDDeviceFullScreen(0);
      z3DCore_GetState.SetHWNDDeviceWindowed(0);
      Result:= 0;
      Exit;
    end;

    WM_DESTROY: PostQuitMessage(0);
  end;

  // Don't allow the F10 key to act as a shortcut to the menu bar
  // by not passing these messages to the DefWindowProc only when
  // there's no menu present
  if not z3DCore_GetState.CallDefWindowProc or (z3DCore_GetState.Menu = 0) and ((uMsg = WM_SYSKEYDOWN) or (uMsg = WM_SYSKEYUP)) and (wParam = VK_F10)
  then Result:= 0
  else Result:= DefWindowProcW(hWnd, uMsg, wParam, lParam);
end;

procedure z3DCore_ResetEngineState;
begin
  z3DCore_GetState.DestroyState;
  z3DCore_GetState.CreateState;
end;

procedure z3DCore_Shutdown(nExitCode: Integer = 0);
var
  hWnd: Windows.HWND;
begin
  hWnd := z3DCore_GetHWND;
  if (hWnd <> 0) then SendMessage(hWnd, WM_CLOSE, 0, 0);

  z3DCore_GetState.SetExitCode(nExitCode);

  z3DCleanup3DEnvironment(True);

  // Restore shortcut keys (Windows key, accessibility shortcuts) to original state
  // This is important to call here if the shortcuts are disabled,
  // because accessibility setting changes are permanent.
  // This means that if this is not done then the accessibility settings
  // might not be the same as when the app was started.
  // If the app crashes without restoring the settings, this is also true so it
  // would be wise to backup/restore the settings from a file so they can be
  // restored when the crashed app is run again.
  z3DAllowShortcutKeys(True);

  with z3DCore_GetState do
  begin
    if Assigned(z3DDeviceList) then z3DDeviceList.CleanupDirect3DInterfaces;
    z3DDeviceList:= nil;
    D3D:= nil;
  end;

  z3DFileSystemController.FreeBuffer;
end;

procedure z3DCleanup3DEnvironment(bReleaseSettings: Boolean = True);
var
  pd3dDevice: IDirect3DDevice9;
  pCallbackDeviceLost: Tz3DCallback_DeviceLost;
  pCallbackDeviceDestroyed: Tz3DCallback_DeviceDestroyed;
  pOldDeviceSettings: Pz3DDeviceSettings;
  pbackBufferSurfaceDesc: PD3DSurfaceDesc;
  pd3dCaps: PD3DCaps9;
  FRefCount: Cardinal;
begin
  pd3dDevice := z3DCore_GetD3DDevice;
  if (pd3dDevice <> nil) then 
  begin
    z3DCore_GetState.InsideDeviceCallback := True;

    // Call the app's device lost callback
    if z3DCore_GetState.DeviceObjectsReset then
    begin
      pCallbackDeviceLost := z3DCore_GetState.DeviceLostFunc;
      if (@pCallbackDeviceLost <> nil) then pCallbackDeviceLost(z3DCore_GetState.DeviceLostFuncUserContext);
      z3DCore_GetState.DeviceObjectsReset := False;

      // Call the resource cache device lost function
      z3DCore_GetGlobalResourceCache.OnLostDevice;
    end;

    // Call the app's device destroyed callback
    if z3DCore_GetState.DeviceObjectsCreated then
    begin
      pCallbackDeviceDestroyed := z3DCore_GetState.DeviceDestroyedFunc;
      if (@pCallbackDeviceDestroyed <> nil) then
        pCallbackDeviceDestroyed(z3DCore_GetState.DeviceDestroyedFuncUserContext);
      z3DCore_GetState.DeviceObjectsCreated := False;

      // Call the resource cache device destory function
      z3DCore_GetGlobalResourceCache.OnDestroyDevice;
    end;

    z3DCore_GetState.InsideDeviceCallback:= False;

    // Release the D3D device and in debug configs, displays a message box if there
    // are unrelease objects.
    z3DCore_GetState.D3DDevice:= nil;
    if (pd3dDevice <> nil) then
    begin
      FRefCount:= pd3dDevice._Release;
      if FRefCount > 0 then
      begin
      #ifndef  FPC
 //todo: Remove this HACK after succesfull debugging of FPC port
        z3DTrace(PWideChar(WideString('z3DCleanup3DEnvironment: Device reference count > 0. Current count: '+IntToStr(FRefCount))), z3dtkWarning);
        z3DDisplayErrorMessage(z3DERR_NONZEROREFCOUNT);
        z3DError('z3DCleanup3DEnvironment', z3DERR_NONZEROREFCOUNT);
        #ifdef  DEBUG

        // Forced clearing of D3DDevice references, so D3D debug level will show additional messages
        OutputDebugString('z3D.pas: releasing D3DDevice refcount until ZERO');
        while (pd3dDevice._Release > 0) do Application.ProcessMessages;
        #endif

      #endif

      end;
      Pointer(pd3dDevice) := nil;
    end;

    if bReleaseSettings then
    begin
      pOldDeviceSettings := z3DCore_GetState.CurrentDeviceSettings;
      Dispose(pOldDeviceSettings);
      z3DCore_GetState.CurrentDeviceSettings:= nil;
    end;

    pbackBufferSurfaceDesc := z3DCore_GetState.BackBufferSurfaceDesc;
    ZeroMemory(pbackBufferSurfaceDesc, SizeOf(TD3DSurfaceDesc));

    pd3dCaps := z3DCore_GetState.Caps;
    ZeroMemory(pd3dCaps, SizeOf(TD3DCaps9));

    z3DCore_GetState.DeviceCreated := False;
  end;
end;

procedure z3DUpdateBackBufferDesc;
var
  pBackBuffer: IDirect3DSurface9;
  hr: HRESULT;
  pBBufferSurfaceDesc: PD3DSurfaceDesc;
begin
  hr := z3DCore_GetState.D3DDevice.GetBackBuffer(0, 0, D3DBACKBUFFER_TYPE_MONO, pBackBuffer);
  pBBufferSurfaceDesc := z3DCore_GetState.GetBackBufferSurfaceDesc;
  ZeroMemory(pBBufferSurfaceDesc, SizeOf(TD3DSurfaceDesc));
  if SUCCEEDED(hr) then
  begin
    pBackBuffer.GetDesc(pBBufferSurfaceDesc^);
    pBackBuffer := nil;
  end;
end;

function z3DCore_SetTimer(pCallbackTimer: Tz3DCallback_Timer; fTimeoutInSecs: Single = 1.0; pnIDEvent: PLongWord = nil; pCallbackUserContext: Pointer = nil): HRESULT;
var
  z3DTimer: Tz3DTimerRecord;
  pTimerList: Tz3DTimerRecordArray;
  l: Integer;
begin
  if (@pCallbackTimer = nil) then
  begin
    Result:= z3DErrorMessage('z3DSetTimer', E_INVALIDARG);
    Exit;
  end;

  z3DTimer.pCallbackTimer := pCallbackTimer;
  z3DTimer.pCallbackUserContext := pCallbackUserContext;
  z3DTimer.fTimeoutInSecs := fTimeoutInSecs;
  z3DTimer.fCountdown := fTimeoutInSecs;
  z3DTimer.bEnabled := True;

  pTimerList := z3DCore_GetState.TimerList;
  l:= Length(pTimerList);
  SetLength(pTimerList, l+1);
  pTimerList[l]:= z3DTimer;

  if (pnIDEvent <> nil) then pnIDEvent^ := Length(pTimerList);

  Result:= S_OK;
end;

function z3DCore_KillTimer(nIDEvent: LongWord): HRESULT;
var
  pTimerList: Tz3DTimerRecordArray;
begin
  pTimerList := z3DCore_GetState.GetTimerList;
  if (pTimerList = nil) then
  begin
    Result:= S_FALSE;
    Exit;
  end;

  if (nIDEvent < LongWord(Length(pTimerList))) then
  begin
    pTimerList[nIDEvent].bEnabled := False;
  end else
  begin
    Result:= z3DErrorMessage('z3DKillTimer', E_INVALIDARG);
    Exit;
  end;

  Result:= S_OK;
end;

procedure z3DHandleTimers;
var
  fElapsedTime: Single;
  pTimerList: Tz3DTimerRecordArray;
  i: Integer;
  z3DTimer: Tz3DTimerRecord;
begin
  fElapsedTime := z3DCore_GetElapsedTime;

  pTimerList := z3DCore_GetState.GetTimerList;
  if (pTimerList = nil) then Exit;

  // Walk through the list of timer callbacks
  for i:= 0 to Length(pTimerList) - 1 do
  begin
    z3DTimer := pTimerList[i];
    if z3DTimer.bEnabled then
    begin
      z3DTimer.fCountdown := z3DTimer.fCountdown - fElapsedTime;

      // Call the callback if count down expired
      if (z3DTimer.fCountdown < 0) then
      begin
        z3DTimer.pCallbackTimer(i, z3DTimer.pCallbackUserContext);
        z3DTimer.fCountdown := z3DTimer.fTimeoutInSecs;
      end;
      pTimerList[i]:= z3DTimer;
    end;
  end;
end;


function z3DCore_GetD3DObject: IDirect3D9;
begin Result:= z3DCore_GetState.D3D; end;

function z3DCore_GetD3DDevice: IDirect3DDevice9;
begin Result:= z3DCore_GetState.D3DDevice; end;

function z3DCore_GetBackBufferSurfaceDesc: PD3DSurfaceDesc;
begin Result:= z3DCore_GetState.BackBufferSurfaceDesc; end;

function z3DCore_GetDeviceCaps: PD3DCaps9;
begin Result:= z3DCore_GetState.Caps; end;

function z3DCore_GetHINSTANCE: HINST;
begin Result:= z3DCore_GetState.HInstance; end;

function z3DCore_GetHWND: HWND;
begin
  if z3DCore_IsWindowed then Result:= z3DCore_GetState.HWNDDeviceWindowed
  else Result:= z3DCore_GetState.HWNDDeviceFullScreen;
end;

function z3DCore_GetHWNDFocus: HWND;
begin Result:= z3DCore_GetState.HWNDFocus; end;

function z3DCore_GetHWNDDeviceFullScreen: HWND;
begin Result:= z3DCore_GetState.HWNDDeviceFullScreen; end;

function z3DCore_GetHWNDDeviceWindowed: HWND;
begin Result:= z3DCore_GetState.HWNDDeviceWindowed; end;

function z3DCore_GetWindowClientRect: TRect;
begin
  GetClientRect(z3DCore_GetHWND, Result);
end;

function z3DCore_GetWindowClientRectAtModeChange: TRect;
begin
  Result := Rect(0, 0, z3DCore_GetState.WindowBackBufferWidthAtModeChange,
                       z3DCore_GetState.WindowBackBufferHeightAtModeChange);
end;

function z3DCore_GetFullsceenClientRectAtModeChange: TRect;
begin
  Result := Rect(0, 0, z3DCore_GetState.FullScreenBackBufferWidthAtModeChange,
                       z3DCore_GetState.GetFullScreenBackBufferHeightAtModeChange);
end;

function z3DCore_GetTime: Double;
begin Result:= z3DCore_GetState.Time; end;

function z3DCore_GetElapsedTime: Single;
begin Result:= z3DCore_GetState.ElapsedTime; end;

function z3DCore_GetFPS: Single;
begin Result:= z3DCore_GetState.FPS; end;

function z3DCore_GetWindowTitle: PWideChar;
begin Result:= z3DCore_GetState.WindowTitle; end;

function z3DCore_GetDeviceStats: PWideChar;
begin Result:= z3DCore_GetState.DeviceStats; end;

function z3DCore_IsRenderingPaused: Boolean;
begin Result:= z3DCore_GetState.PauseRenderingCount > 0; end;

function z3DCore_IsTimePaused: Boolean;
begin Result:= z3DCore_GetState.PauseTimeCount > 0; end;

function z3DCore_IsActive: Boolean;
begin Result:= z3DCore_GetState.GetActive; end;

function z3DCore_GetExitCode:Integer;
begin Result:= z3DCore_GetState.ExitCode; end;

function z3DCore_GetShowMsgBoxOnError: Boolean;
begin
  Result:= z3DCore_GetState.ShowMsgBoxOnError;
end;

function z3DCore_GetAutomation: Boolean;
begin
  Result:= z3DCore_GetState.Automation;
end;

function z3DCore_GetHandleDefaultHotkeys: Boolean;
begin Result:= z3DCore_GetState.GetHandleDefaultHotkeys; end;

function z3DCore_IsKeyDown(vKey: Byte): Boolean; // Pass a virtual-key code, ex. VK_F1, 'A', VK_RETURN, VK_LSHIFT, etc
var
  bKeys: Pz3DKeysArray;
begin
  bKeys := z3DCore_GetState.Keys;
  if (vKey >= $A0) and (vKey <= $A5) then // VK_LSHIFT, VK_RSHIFT, VK_LCONTROL, VK_RCONTROL, VK_LMENU, VK_RMENU
    Result:= GetAsyncKeyState(vKey) <> 0 // these keys only are tracked via GetAsyncKeyState()
  else if( vKey >= $01) and (vKey <= $06) and (vKey <> $03) then // mouse buttons (VK_*BUTTON)
    Result:= z3DCore_IsMouseButtonDown(vKey)
  else
    Result:= bKeys[vKey];
end;

function z3DCore_IsMouseButtonDown(vButton: Byte): Boolean; // Pass a virtual-key code: VK_LBUTTON, VK_RBUTTON, VK_MBUTTON, VK_XBUTTON1, VK_XBUTTON2
var
  bMouseButtons: Pz3DMouseButtonsArray;
  nIndex: Integer;
begin
  bMouseButtons := z3DCore_GetState.GetMouseButtons;
  nIndex := z3DMapButtonToArrayIndex(vButton);
  Result:= bMouseButtons[nIndex];
end;

procedure z3DCore_SetMultimonSettings(bAutoChangeAdapter: Boolean);
begin
  z3DCore_GetState.AutoChangeAdapter:= bAutoChangeAdapter;
end;

procedure z3DCore_SetCursorSettings(bShowCursorWhenFullScreen, bClipCursorWhenFullScreen: Boolean);
begin
  z3DCore_GetState.SetClipCursorWhenFullScreen(bClipCursorWhenFullScreen);
  z3DCore_GetState.SetShowCursorWhenFullScreen(bShowCursorWhenFullScreen);
  z3DSetupCursor;
end;

procedure z3DCore_SetWindowSettings(bCallDefWindowProc: Boolean);
begin
  z3DCore_GetState.SetCallDefWindowProc(bCallDefWindowProc);
end;

procedure z3DCore_SetConstantFrameTime(bConstantFrameTime: Boolean; fTimePerFrame: Single = 0.0333);
begin
  if (z3DCore_GetState.ConstantFrameTime) then
  begin
    bConstantFrameTime := z3DCore_GetState.ConstantFrameTime;
    fTimePerFrame := z3DCore_GetState.ConstantTimePerFrame;
  end;
  z3DCore_GetState.SetConstantFrameTime(bConstantFrameTime);
  z3DCore_GetState.SetTimePerFrame(fTimePerFrame);
end;

function z3DCore_IsWindowed: Boolean;
var
  pDeviceSettings: Pz3DDeviceSettings;
begin
  pDeviceSettings := z3DCore_GetState.CurrentDeviceSettings;
  if (pDeviceSettings <> nil)
  then Result:= pDeviceSettings.PresentParams.Windowed
  else Result:= False;
end;

function z3DCore_GetPresentParameters: TD3DPresentParameters;
var
  pDS: Pz3DDeviceSettings;
  pp: TD3DPresentParameters;
begin
  pDS := z3DCore_GetState.CurrentDeviceSettings;
  if (pDS <> nil) then
  begin
    Result:= pDS.PresentParams;
  end else
  begin
    ZeroMemory(@pp, SizeOf(TD3DPresentParameters));
    Result:= pp;
  end;
end;

function z3DCore_GetDeviceSettings: Tz3DDeviceSettings;
var
  pDS: Pz3DDeviceSettings;
  ds: Tz3DDeviceSettings;
begin
  pDS := z3DCore_GetState.CurrentDeviceSettings;
  if (pDS <> nil) then
  begin
    Result:= pDS^;
  end else
  begin
    ZeroMemory(@ds, SizeOf(Tz3DDeviceSettings));
    Result:= ds;
  end;
end;

const
  SM_REMOTESESSION        = $1000;

procedure z3DDisplayErrorMessage(hr: HRESULT);
var
  strBuffer: PWideChar;
  nExitCode: Integer;
  bFound: Boolean;
  bShowMsgBoxOnError: Boolean;
begin
  GetMem(strBuffer, 255);
  bFound := true;
  case hr of
    Z3DERR_NODIRECT3D:             begin nExitCode := 2; StringToWideChar('Could not initialize Direct3D. Please make sure that you have DirectX 9.0c or later installed on your system. '+
                                                                     'If this problem persists, please contact the software manufacturer.', strBuffer, 255); end;
    Z3DERR_INCORRECTVERSION:       begin nExitCode := 10;StringToWideChar('Could not initialize Direct3D due to an incorrect version of Direct3D and/or D3DX. Please reinstall DirectX if this problem persists.', strBuffer, 255); end;
    Z3DERR_MEDIANOTFOUND:          begin nExitCode := 4; StringToWideChar('Could not find required media files. Please reinstall this program if the problem continues.', strBuffer, 255); end;
    Z3DERR_NONZEROREFCOUNT:        begin nExitCode := 5; StringToWideChar('The Direct3D device has a non-zero reference count, meaning some objects were not released. The system may become unstable.', strBuffer, 255); end;
    Z3DERR_CREATINGDEVICE:         begin nExitCode := 6; StringToWideChar('Could not create the Direct3D device. Please reinstall DirectX if this problem persists.', strBuffer, 255); end;
    Z3DERR_RESETTINGDEVICE:        begin nExitCode := 7; StringToWideChar('Could not reset the Direct3D device. Please reinstall DirectX if this problem persists.', strBuffer, 255); end;
    Z3DERR_CREATINGDEVICEOBJECTS:  begin nExitCode := 8; StringToWideChar('Could not create the Direct3D device objects. Please reinstall DirectX if this problem persists.', strBuffer, 255); end;
    Z3DERR_RESETTINGDEVICEOBJECTS: begin nExitCode := 9; StringToWideChar('Could not reset the Direct3D device objects. Please reinstall DirectX if this problem persists.', strBuffer, 255); end;
    Z3DERR_NOCOMPATIBLEDEVICES:
    begin
      nExitCode := 3;
      if (GetSystemMetrics(SM_REMOTESESSION) <> 0)
      then StringToWideChar('Direct3D does not work over a remote session. Reinstall this program if the problem persists.', strBuffer, 255)
      else StringToWideChar('The engine could not find any compatible Direct3D devices. Please review your hardware specifications to make sure that it reaches the program requirements.', strBuffer, 255);
    end;
  else
    bFound := False;
    nExitCode := 1;
  end;

  z3DCore_GetState.ExitCode:= nExitCode;

  bShowMsgBoxOnError := z3DCore_GetState.ShowMsgBoxOnError;
  if bShowMsgBoxOnError then
  begin
    if bFound then
    Application.MessageBox(PAnsiChar(strBuffer+#13#10+'The program must be terminated.'), PAnsiChar(Application.Title), MB_ICONERROR or MB_OK) else
    Application.MessageBox(PAnsiChar('An unknown error has ocurred. The program must be terminated. Error code: '+IntToStr(hr)), PAnsiChar(Application.Title), MB_ICONERROR or MB_OK);
  end;
  z3DCore_ShutDown(nExitCode);
//  FatalExit(nExitCode);
end;

procedure z3DCheckForWindowChangingMonitors;
#ifdef  FPC

begin
  if not z3DCore_GetState.AutoChangeAdapter then Exit;

#else

var
  hr: HRESULT;
  hWindowMonitor: HMONITOR;
  hAdapterMonitor: HMONITOR;
  newOrdinal: LongWord;
  deviceSettings: Tz3DDeviceSettings;
  matchOptions: Tz3DMatchOptions;
begin
  // Skip this check for various reasons
  if not z3DCore_GetState.AutoChangeAdapter or
         z3DCore_GetState.IgnoreSizeChange or
     not z3DCore_GetState.DeviceCreated or
     not z3DCore_GetState.CurrentDeviceSettings.PresentParams.Windowed
  then Exit;

  hWindowMonitor := z3DMonitorFromWindow(z3DCore_GetHWND, MONITOR_DEFAULTTOPRIMARY);
  hAdapterMonitor := z3DCore_GetState.AdapterMonitor;
  if (hWindowMonitor <> hAdapterMonitor) then
  begin
    if SUCCEEDED(z3DGetAdapterOrdinalFromMonitor(hWindowMonitor, newOrdinal)) then
    begin
      // Find the closest valid device settings with the new ordinal
      deviceSettings := z3DCore_GetDeviceSettings;
      deviceSettings.AdapterOrdinal := newOrdinal;

      matchOptions.eAdapterOrdinal     := z3DMT_PRESERVE_INPUT;
      matchOptions.eDeviceType         := z3DMT_CLOSEST_TO_INPUT;
      matchOptions.eWindowed           := z3DMT_CLOSEST_TO_INPUT;
      matchOptions.eAdapterFormat      := z3DMT_CLOSEST_TO_INPUT;
      matchOptions.eVertexProcessing   := z3DMT_CLOSEST_TO_INPUT;
      matchOptions.eResolution         := z3DMT_CLOSEST_TO_INPUT;
      matchOptions.eBackBufferFormat   := z3DMT_CLOSEST_TO_INPUT;
      matchOptions.eBackBufferCount    := z3DMT_CLOSEST_TO_INPUT;
      matchOptions.eMultiSample        := z3DMT_CLOSEST_TO_INPUT;
      matchOptions.eSwapEffect         := z3DMT_CLOSEST_TO_INPUT;
      matchOptions.eDepthFormat        := z3DMT_CLOSEST_TO_INPUT;
      matchOptions.eStencilFormat      := z3DMT_CLOSEST_TO_INPUT;
      matchOptions.ePresentFlags       := z3DMT_CLOSEST_TO_INPUT;
      matchOptions.eRefreshRate        := z3DMT_CLOSEST_TO_INPUT;
      matchOptions.ePresentInterval    := z3DMT_CLOSEST_TO_INPUT;

      hr := z3DCore_FindValidDeviceSettings(deviceSettings, @deviceSettings, @matchOptions);
      if SUCCEEDED(hr) then
      begin
        // Create a Direct3D device using the new device settings.
        // If there is an existing device, then it will either reset or recreate the scene.
        hr := z3DChangeDevice(@deviceSettings, nil, False, False);
        // If hr == E_ABORT, this means the app rejected the device settings in the ModifySettingsCallback
        if (hr = E_ABORT) then
        begin
          // so nothing changed and keep from attempting to switch adapters next time
          z3DCore_GetState.AutoChangeAdapter := False;
        end else
        if FAILED(hr) then
        begin
          z3DCore_Shutdown;
          z3DCore_Pause(False, False);
          Exit;
        end;
      end;
    end;
  end;
#endif

end;

function z3DGetAdapterOrdinalFromMonitor(hMonitor: HMONITOR; out pAdapterOrdinal: LongWord): HRESULT;
var
  pd3dEnum: Iz3DDeviceList;
  pD3D: IDirect3D9;
  pAdapterList: Tz3DEnumAdapterInfoArray;
  iAdapter: Integer;
  pAdapterInfo: Iz3DEnumAdapterInfo;
  hAdapterMonitor: #ifdef  FPC
HANDLE#else
Direct3D9.HMONITOR#endif
;
begin
  pAdapterOrdinal := 0;

  pd3dEnum := z3DPrepareDeviceListObject;
  pD3D     := z3DCore_GetD3DObject;

  pAdapterList := pd3dEnum.GetAdapterInfoList;
  for iAdapter:= 0 to Length(pAdapterList) - 1 do
  begin
    pAdapterInfo := pAdapterList[iAdapter];
    hAdapterMonitor := pD3D.GetAdapterMonitor(pAdapterInfo.AdapterOrdinal);
    if (hAdapterMonitor = hMonitor) then
    begin
      pAdapterOrdinal := pAdapterInfo.AdapterOrdinal;
      Result:= S_OK;
      Exit;
    end;
  end;

  Result:= E_FAIL;
end;

function z3DMapButtonToArrayIndex(vButton: Byte): Integer;
begin
  case vButton of
    MK_LBUTTON: Result:= 0;
    VK_MBUTTON,
    MK_MBUTTON: Result:= 1;
    MK_RBUTTON: Result:= 2;
    VK_XBUTTON1,
    MK_XBUTTON1: Result:= 3;
    VK_XBUTTON2,
    MK_XBUTTON2: Result:= 4;
  else
    Result:= 0;
  end;
end;


procedure z3DSetupCursor;
var
  pd3dDevice: IDirect3DDevice9;
  hCursor: Windows.HCURSOR;
  rcWindow: TRect;
begin
  // Show the cursor again if returning to fullscreen
  pd3dDevice := z3DCore_GetD3DDevice;
  if not z3DCore_IsWindowed and Assigned(pd3dDevice) then
  begin
    if z3DCore_GetState.ShowCursorWhenFullScreen then
    begin
      SetCursor(0); // Turn off Windows cursor in full screen mode
      hCursor := ULONG_PTR(GetClassLong/*Ptr*/ (z3DCore_GetHWNDDeviceFullScreen, GCLP_HCURSOR));
      z3DSetDeviceCursor(pd3dDevice, hCursor, z3DCore_GetState.CursorWatermark);
      z3DCore_GetD3DDevice.ShowCursor(True);
    end else
    begin
      SetCursor(0); // Turn off Windows cursor in full screen mode
      z3DCore_GetD3DDevice.ShowCursor(False);
    end;
  end;

  // Clip cursor if requested
  if not z3DCore_IsWindowed and z3DCore_GetState.ClipCursorWhenFullScreen then
  begin
    // Confine cursor to full screen window
    GetWindowRect(z3DCore_GetHWNDDeviceFullScreen, rcWindow);
    ClipCursor(@rcWindow);
  end else
  begin
    ClipCursor(nil);
  end;
end;

function z3DSetDeviceCursor(const pd3dDevice: IDirect3DDevice9; hCursor: HCURSOR; bAddWatermark: Boolean): HRESULT;
const
  wMask: array [0..4] of Word = ($ccc0, $a2a0, $a4a0, $a2a0, $ccc0);
label
  End_;
type
  PACOLORREF = ^ACOLORREF;
  ACOLORREF = array[0..0] of COLORREF;
  pImg = ^img;
  img = array[0..16000] of DWORD;
var
  hr: HRESULT;
  iconinfo_: TIconInfo;
  bBWCursor: BOOL;
  pCursorSurface: IDirect3DSurface9;
  hdcColor: HDC;
  hdcMask: HDC;
  hdcScreen: HDC;
  bm: TBitmap;
  dwWidth: DWORD;
  dwHeightSrc: DWORD;
  dwHeightDest: DWORD;
  crColor: COLORREF;
  crMask: COLORREF;
  x, y: Cardinal;
  bmi: TBitmapInfo;
  pcrArrayColor: PACOLORREF;
  pcrArrayMask: PACOLORREF;
  pBitmap: pImg;
  hgdiobjOld: HGDIOBJ;
  lr: TD3DLockedRect;
begin
  hr := E_FAIL;
  pCursorSurface := nil;
  hdcColor := 0;
  hdcMask := 0;
  hdcScreen := 0;
  pcrArrayColor := nil;
  pcrArrayMask := nil;

  ZeroMemory(@iconinfo_, SizeOf(TIconInfo));
  if not GetIconInfo(hCursor, iconinfo_) then
    goto End_;

  if (0 = GetObject(iconinfo_.hbmMask, SizeOf(TBitmap), @bm)) then
    goto End_;
  dwWidth := bm.bmWidth;
  dwHeightSrc := bm.bmHeight;

  if (iconinfo_.hbmColor = 0) then
  begin
    bBWCursor := True;
    dwHeightDest := dwHeightSrc div 2;
  end else
  begin
    bBWCursor := False;
    dwHeightDest := dwHeightSrc;
  end;

  // Create a surface for the fullscreen cursor
  hr:= pd3dDevice.CreateOffscreenPlainSurface(dwWidth, dwHeightDest,
          D3DFMT_A8R8G8B8, D3DPOOL_SCRATCH, pCursorSurface, nil);
  if FAILED(hr) then
    goto End_;

  // pcrArrayMask = new DWORD[dwWidth * dwHeightSrc];
  GetMem(pcrArrayMask, SizeOf(DWORD)*(dwWidth * dwHeightSrc));

  ZeroMemory(@bmi, sizeof(bmi));
  bmi.bmiHeader.biSize := sizeof(bmi.bmiHeader);
  bmi.bmiHeader.biWidth := dwWidth;
  bmi.bmiHeader.biHeight := dwHeightSrc;
  bmi.bmiHeader.biPlanes := 1;
  bmi.bmiHeader.biBitCount := 32;
  bmi.bmiHeader.biCompression := BI_RGB;

  hdcScreen := GetDC(0);
  hdcMask := CreateCompatibleDC(hdcScreen);
  if (hdcMask = 0) then
  begin
    hr := E_FAIL;
    goto End_;
  end;
  hgdiobjOld := SelectObject(hdcMask, iconinfo_.hbmMask);
  GetDIBits(hdcMask, iconinfo_.hbmMask, 0, dwHeightSrc, pcrArrayMask, bmi,
    DIB_RGB_COLORS);
  SelectObject(hdcMask, hgdiobjOld);

  if (not bBWCursor) then
  begin
    // pcrArrayColor = new DWORD[dwWidth * dwHeightDest];
    GetMem(pcrArrayColor, SizeOf(DWORD)*(dwWidth * dwHeightDest));
    hdcColor := CreateCompatibleDC(hdcScreen);
    if (hdcColor = 0) then
    begin
      hr := E_FAIL;
      goto End_;
    end;
    SelectObject(hdcColor, iconinfo_.hbmColor);
    GetDIBits(hdcColor, iconinfo_.hbmColor, 0, dwHeightDest, pcrArrayColor, bmi,
      DIB_RGB_COLORS);
  end;

  // Transfer cursor image into the surface
  pCursorSurface.LockRect(lr, nil, 0);
  pBitmap:= lr.pBits;
  for y:= 0 to dwHeightDest - 1 do
  begin
    for x:= 0 to dwWidth - 1 do
    begin
      if bBWCursor then
      begin
        crColor:= pcrArrayMask^[dwWidth*(dwHeightDest-1-y) + x];
        crMask:= pcrArrayMask^[dwWidth*(dwHeightSrc-1-y) + x];
      end else
      begin
        crColor:= pcrArrayColor^[dwWidth*(dwHeightDest-1-y) + x];
        crMask:= pcrArrayMask^[dwWidth*(dwHeightDest-1-y) + x];
      end;
      if (crMask = 0) then
        pBitmap^[dwWidth*y + x]:= $FF000000 or crColor
      else
        pBitmap^[dwWidth*y + x]:= $00000000;

      // It may be helpful to make the D3D cursor look slightly
      // different from the Windows cursor so you can distinguish
      // between the two when developing/testing code.  When
      // bAddWatermark is TRUE, the following code adds some
      // small grey "D3D" characters to the upper-left corner of
      // the D3D cursor image.

      if bAddWatermark and (x < 12) and (y < 5) then
      begin
        // 11.. 11.. 11.. .... CCC0
        // 1.1. ..1. 1.1. .... A2A0
        // 1.1. .1.. 1.1. .... A4A0
        // 1.1. ..1. 1.1. .... A2A0
        // 11.. 11.. 11.. .... CCC0

        if (wMask[y] and (1 shl (15 - x)) <> 0) then
          pBitmap^[dwWidth*y + x]:= pBitmap^[dwWidth*y + x] or $FF808080;
      end;
    end;
  end;
  pCursorSurface.UnlockRect;

  // Set the device cursor
  hr := pd3dDevice.SetCursorProperties(iconinfo_.xHotspot,
      iconinfo_.yHotspot, pCursorSurface);
  if FAILED(hr) then
    goto End_;

  hr := S_OK;

End_:
  if (iconinfo_.hbmMask <> 0)  then DeleteObject(iconinfo_.hbmMask);
  if (iconinfo_.hbmColor <> 0) then DeleteObject(iconinfo_.hbmColor);
  if (hdcScreen <> 0)          then ReleaseDC(0, hdcScreen);
  if (hdcColor <> 0)           then DeleteDC(hdcColor);
  if (hdcMask <> 0)            then DeleteDC(hdcMask);
  // SafeDelete_ARRAY(pcrArrayColor);
  FreeMem(pcrArrayColor);
  // SafeDelete_ARRAY(pcrArrayMask);
  FreeMem(pcrArrayMask);
  SafeRelease(pCursorSurface);
  Result:= hr;
end;

var cache: Iz3DResourceCache = nil;
var timer: Iz3DTimer = nil;

function z3DCore_GetGlobalResourceCache: Iz3DResourceCache;
begin
  if (cache = nil) then cache:= Tz3DResourceCache.Create;
  Result:= cache;
end;

function z3DCore_GetGlobalTimer: Iz3DTimer;
begin
  if (timer = nil) then timer:= Tz3DTimer.Create;
  Result:= timer;
end;

function Tz3DDeviceList.GetCurrentDeviceInfo: Iz3DEnumDeviceInfo;
begin
  Result:= GetDeviceInfo(z3DCore_GetDeviceSettings.AdapterOrdinal,
  z3DCore_GetDeviceSettings.DeviceType);
end;

function Tz3DDeviceList.GetCurrentDeviceSettingsCombo: PD3DDeviceSettingsCombinations;
begin
  Result:= z3DCore_GetDeviceList.GetDeviceSettingsCombo(
  z3DCore_GetDeviceList.GetCurrentDeviceInfo.AdapterOrdinal,
  z3DCore_GetDeviceList.GetCurrentDeviceInfo.DeviceType,
  z3DCore_GetDeviceSettings.AdapterFormat,
  z3DCore_GetDeviceSettings.PresentParams.BackBufferFormat,
  z3DCore_GetDeviceSettings.PresentParams.Windowed);
end;

/* Tz3DResourceCache */ 

destructor Tz3DResourceCache.Destroy;
begin
  OnDestroyDevice;
  m_TextureCache:= nil;
  m_EffectCache:= nil;
  m_FontCache:= nil;
  inherited;
end;

function Tz3DResourceCache.CreateTextureFromFile(pDevice: IDirect3DDevice9; pSrcFile: PWideChar; out ppTexture: IDirect3DTexture9): HRESULT;
begin
  Result:= CreateTextureFromFileEx(pDevice, pSrcFile, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT,
  0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, nil, nil, ppTexture);
end;

function Tz3DResourceCache.CreateTextureFromFileEx(pDevice: IDirect3DDEVICE9; pSrcFile: PWideChar;
  Width, Height, MipLevels: LongWord; Usage: DWORD; Format: TD3DFormat; Pool: TD3DPool;
  Filter, MipFilter: DWORD; ColorKey: TD3DColor; pSrcInfo: PD3DXImageInfo; pPalette: PPaletteEntry;
  out ppTexture: IDirect3DTexture9): HRESULT;
var
  i: Integer;
  Entry: Pz3DCacheTexture;
  NewEntry: Tz3DCacheTexture;
begin
  for i := 0 to Length(m_TextureCache) - 1 do
  begin
    Entry := @m_TextureCache[i];
    if (Entry.Location = z3DCACHE_LOCATION_FILE) and
       (lstrcmpW(Entry.wszSource, pSrcFile) = 0) and
       (Entry.Width = Width) and
       (Entry.Height = Height) and
       (Entry.MipLevels = MipLevels) and
       (Entry.Usage = Usage) and
       (Entry.Format = Format) and
       (Entry.Pool = Pool) and
       (Entry._Type = D3DRTYPE_TEXTURE) then
    begin
      Result:= Entry.pTexture.QueryInterface(IID_IDirect3DTexture9, ppTexture);
      Exit;
    end;
  end;
  Result := D3DXCreateTextureFromFileExW(pDevice, pSrcFile, Width, Height, MipLevels, Usage, Format,
  Pool, Filter, MipFilter, ColorKey, pSrcInfo, pPalette, ppTexture);
  if FAILED(Result) then Exit;
  NewEntry.Location := z3DCACHE_LOCATION_FILE;
  StringCchCopy(NewEntry.wszSource, MAX_PATH, pSrcFile);
  NewEntry.Width := Width;
  NewEntry.Height := Height;
  NewEntry.MipLevels := MipLevels;
  NewEntry.Usage := Usage;
  NewEntry.Format := Format;
  NewEntry.Pool := Pool;
  NewEntry._Type := D3DRTYPE_TEXTURE;
  ppTexture.QueryInterface(IID_IDirect3DBaseTexture9, NewEntry.pTexture);
  i:= Length(m_TextureCache);
  SetLength(m_TextureCache, i+1);
  m_TextureCache[i]:= NewEntry;
  Result:= S_OK;
end;

function Tz3DResourceCache.CreateTextureFromResource(pDevice: IDirect3DDevice9; hSrcModule: HMODULE; pSrcResource: PWideChar; ppTexture: IDirect3DTexture9): HRESULT;
begin
  Result:= CreateTextureFromResourceEx(pDevice, hSrcModule, pSrcResource, D3DX_DEFAULT, D3DX_DEFAULT,
  D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, nil, nil, ppTexture);
end;

function Tz3DResourceCache.CreateTextureFromResourceEx(pDevice: IDirect3DDevice9; hSrcModule: HMODULE; pSrcResource: PWideChar;
  Width, Height, MipLevels: LongWord; Usage: DWORD; Format: TD3DFormat; Pool: TD3DPool; Filter, MipFilter: DWORD; ColorKey: TD3DColor;
  pSrcInfo: PD3DXImageInfo; pPalette: PPaletteEntry; out ppTexture: IDirect3DTexture9): HRESULT;
var i: Integer;
    Entry: Pz3DCacheTexture;
    NewEntry: Tz3DCacheTexture;
begin
  for i := 0 to Length(m_TextureCache) - 1 do
  begin
    Entry := @m_TextureCache[i];
    if (Entry.Location = z3DCACHE_LOCATION_RESOURCE) and
       (Entry.hSrcModule = hSrcModule) and
       (lstrcmpW(Entry.wszSource, pSrcResource) = 0) and
       (Entry.Width = Width) and
       (Entry.Height = Height) and
       (Entry.MipLevels = MipLevels) and
       (Entry.Usage = Usage) and
       (Entry.Format = Format) and
       (Entry.Pool = Pool) and
       (Entry._Type = D3DRTYPE_TEXTURE) then
    begin
      Result:= Entry.pTexture.QueryInterface(IID_IDirect3DTexture9, ppTexture);
      Exit;
    end;
  end;
  Result := D3DXCreateTextureFromResourceExW(pDevice, hSrcModule, pSrcResource,
  Width, Height, MipLevels, Usage, Format, Pool, Filter, MipFilter, ColorKey, pSrcInfo, pPalette, ppTexture);
  if FAILED(Result) then Exit;
  NewEntry.Location := z3DCACHE_LOCATION_RESOURCE;
  NewEntry.hSrcModule := hSrcModule;
  StringCchCopy(NewEntry.wszSource, MAX_PATH, pSrcResource);
  NewEntry.Width := Width;
  NewEntry.Height := Height;
  NewEntry.MipLevels := MipLevels;
  NewEntry.Usage := Usage;
  NewEntry.Format := Format;
  NewEntry.Pool := Pool;
  NewEntry._Type := D3DRTYPE_TEXTURE;
  ppTexture.QueryInterface(IID_IDirect3DBaseTexture9, NewEntry.pTexture);
  i:= Length(m_TextureCache);
  SetLength(m_TextureCache, i+1);
  m_TextureCache[i]:= NewEntry;
  Result:= S_OK;
end;

function Tz3DResourceCache.CreateCubeTextureFromFile(pDevice: IDirect3DDevice9; pSrcFile: PWideChar; out ppCubeTexture: IDirect3DCubeTexture9): HRESULT;
begin
  Result:= CreateCubeTextureFromFileEx(pDevice, pSrcFile, D3DX_DEFAULT, D3DX_DEFAULT, 0,
  D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, nil, nil, ppCubeTexture);
end;

function Tz3DResourceCache.CreateCubeTextureFromFileEx(pDevice: IDirect3DDevice9; pSrcFile: PWideChar;
  Size, MipLevels: LongWord; Usage: DWORD; Format: TD3DFormat;
  Pool: TD3DPool; Filter, MipFilter: DWORD; ColorKey: TD3DColor;
  pSrcInfo: PD3DXImageInfo; pPalette: PPaletteEntry; out ppCubeTexture: IDirect3DCubeTexture9): HRESULT;
var
  i: Integer;
  Entry: Pz3DCacheTexture;
  NewEntry: Tz3DCacheTexture;
begin
  for i := 0 to Length(m_TextureCache) - 1 do
  begin
    Entry := @m_TextureCache[i];
    if (Entry.Location = z3DCACHE_LOCATION_FILE) and
       (lstrcmpW(Entry.wszSource, pSrcFile) = 0) and
       (Entry.Width = Size) and
       (Entry.MipLevels = MipLevels) and
       (Entry.Usage = Usage) and
       (Entry.Format = Format) and
       (Entry.Pool = Pool) and
       (Entry._Type = D3DRTYPE_TEXTURE) then
    begin
      Result:= Entry.pTexture.QueryInterface(IID_IDirect3DCubeTexture9, ppCubeTexture);
      Exit;
    end;
  end;
  Result := D3DXCreateCubeTextureFromFileExW(pDevice, pSrcFile, Size, MipLevels, Usage, Format, Pool, Filter,
  MipFilter, ColorKey, pSrcInfo, pPalette, ppCubeTexture);
  if FAILED(Result) then Exit;
  NewEntry.Location := z3DCACHE_LOCATION_FILE;
  StringCchCopy(NewEntry.wszSource, MAX_PATH, pSrcFile);
  NewEntry.Width := Size;
  NewEntry.MipLevels := MipLevels;
  NewEntry.Usage := Usage;
  NewEntry.Format := Format;
  NewEntry.Pool := Pool;
  NewEntry._Type := D3DRTYPE_CUBETEXTURE;
  ppCubeTexture.QueryInterface(IID_IDirect3DBaseTexture9, NewEntry.pTexture);
  i:= Length(m_TextureCache);
  SetLength(m_TextureCache, i+1);
  m_TextureCache[i]:= NewEntry;
  Result:= S_OK;
end;

function Tz3DResourceCache.CreateCubeTextureFromResource(pDevice: IDirect3DDevice9; hSrcModule: HMODULE; pSrcResource: PWideChar; out ppCubeTexture: IDirect3DCubeTexture9): HRESULT;
begin
  Result:= CreateCubeTextureFromResourceEx(pDevice, hSrcModule, pSrcResource, D3DX_DEFAULT, D3DX_DEFAULT,
  0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, nil, nil, ppCubeTexture);
end;

function Tz3DResourceCache.CreateCubeTextureFromResourceEx(pDevice: IDirect3DDevice9; hSrcModule: HMODULE; pSrcResource: PWideChar;
  Size, MipLevels: LongWord; Usage: DWORD; Format: TD3DFormat; Pool: TD3DPool; Filter, MipFilter: DWORD; ColorKey: TD3DColor;
  pSrcInfo: PD3DXImageInfo; pPalette: PPaletteEntry; out ppCubeTexture: IDirect3DCubeTexture9): HRESULT;
var
  i: Integer;
  Entry: Pz3DCacheTexture;
  NewEntry: Tz3DCacheTexture;
begin
  for i := 0 to Length(m_TextureCache) - 1 do
  begin
    Entry := @m_TextureCache[i];
    if (Entry.Location = z3DCACHE_LOCATION_RESOURCE) and
       (Entry.hSrcModule = hSrcModule) and
       (lstrcmpW(Entry.wszSource, pSrcResource) = 0) and
       (Entry.Width = Size) and
       (Entry.MipLevels = MipLevels) and
       (Entry.Usage = Usage) and
       (Entry.Format = Format) and
       (Entry.Pool = Pool) and
       (Entry._Type = D3DRTYPE_TEXTURE) then
    begin
      Result:= Entry.pTexture.QueryInterface(IID_IDirect3DCubeTexture9, ppCubeTexture);
      Exit;
    end;
  end;
  Result := D3DXCreateCubeTextureFromResourceExW(pDevice, hSrcModule, pSrcResource, Size, MipLevels, Usage, Format,
  Pool, Filter, MipFilter, ColorKey, pSrcInfo, pPalette, ppCubeTexture);
  if FAILED(Result) then Exit;
  NewEntry.Location := z3DCACHE_LOCATION_RESOURCE;
  NewEntry.hSrcModule := hSrcModule;
  StringCchCopy(NewEntry.wszSource, MAX_PATH, pSrcResource);
  NewEntry.Width := Size;
  NewEntry.MipLevels := MipLevels;
  NewEntry.Usage := Usage;
  NewEntry.Format := Format;
  NewEntry.Pool := Pool;
  NewEntry._Type := D3DRTYPE_CUBETEXTURE;
  ppCubeTexture.QueryInterface(IID_IDirect3DBaseTexture9, NewEntry.pTexture);
  i:= Length(m_TextureCache);
  SetLength(m_TextureCache, i+1);
  m_TextureCache[i]:= NewEntry;
  Result:= S_OK;
end;

function Tz3DResourceCache.CreateVolumeTextureFromFile(pDevice: IDirect3DDevice9; pSrcFile: PWideChar; out ppVolumeTexture: IDirect3DVolumeTexture9): HRESULT;
begin
  Result:= CreateVolumeTextureFromFileEx(pDevice, pSrcFile, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT,
  0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, nil, nil, ppVolumeTexture);
end;

function Tz3DResourceCache.CreateVolumeTextureFromFileEx(pDevice: IDirect3DDevice9; pSrcFile: PWideChar;
  Width, Height, Depth, MipLevels: LongWord; Usage: DWORD; Format: TD3DFormat; Pool: TD3DPool;
  Filter, MipFilter: DWORD; ColorKey: TD3DColor; pSrcInfo: PD3DXImageInfo; pPalette: PPaletteEntry; out ppTexture: IDirect3DVolumeTexture9): HRESULT;
var
  i: Integer;
  Entry: Pz3DCacheTexture;
  NewEntry: Tz3DCacheTexture;
begin
  for i := 0 to Length(m_TextureCache) - 1 do
  begin
    Entry := @m_TextureCache[i];
    if (Entry.Location = z3DCACHE_LOCATION_FILE) and
       (lstrcmpW(Entry.wszSource, pSrcFile) = 0) and
       (Entry.Width = Width) and
       (Entry.Height = Height) and
       (Entry.Depth = Depth) and
       (Entry.MipLevels = MipLevels) and
       (Entry.Usage = Usage) and
       (Entry.Format = Format) and
       (Entry.Pool = Pool) and
       (Entry._Type = D3DRTYPE_TEXTURE) then
    begin
      Result:= Entry.pTexture.QueryInterface(IID_IDirect3DVolumeTexture9, ppTexture);
      Exit;
    end;
  end;
  Result := D3DXCreateVolumeTextureFromFileExW(pDevice, pSrcFile, Width, Height, Depth, MipLevels, Usage, Format,
  Pool, Filter, MipFilter, ColorKey, pSrcInfo, pPalette, ppTexture);
  if FAILED(Result) then Exit;
  NewEntry.Location := z3DCACHE_LOCATION_FILE;
  StringCchCopy(NewEntry.wszSource, MAX_PATH, pSrcFile);
  NewEntry.Width := Width;
  NewEntry.Height := Height;
  NewEntry.Depth := Depth;
  NewEntry.MipLevels := MipLevels;
  NewEntry.Usage := Usage;
  NewEntry.Format := Format;
  NewEntry.Pool := Pool;
  NewEntry._Type := D3DRTYPE_VOLUMETEXTURE;
  ppTexture.QueryInterface(IID_IDirect3DBaseTexture9, NewEntry.pTexture);
  i:= Length(m_TextureCache);
  SetLength(m_TextureCache, i+1);
  m_TextureCache[i]:= NewEntry;
  Result:= S_OK;
end;

function Tz3DResourceCache.CreateVolumeTextureFromResource(pDevice: IDirect3DDevice9; hSrcModule: HMODULE; pSrcResource: PWideChar; out ppVolumeTexture: IDirect3DVolumeTexture9): HRESULT;
begin
  Result:= CreateVolumeTextureFromResourceEx(pDevice, hSrcModule, pSrcResource, D3DX_DEFAULT, D3DX_DEFAULT,
  D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, nil, nil, ppVolumeTexture);
end;

function Tz3DResourceCache.CreateVolumeTextureFromResourceEx(pDevice: IDirect3DDevice9; hSrcModule: HMODULE; pSrcResource: PWideChar;
  Width, Height, Depth, MipLevels: LongWord; Usage: DWORD; Format: TD3DFormat; Pool: TD3DPool; Filter, MipFilter: DWORD;
  ColorKey: TD3DColor; pSrcInfo: PD3DXImageInfo; pPalette: PPaletteEntry; out ppVolumeTexture: IDirect3DVolumeTexture9): HRESULT;
var
  i: Integer;
  Entry: Pz3DCacheTexture;
  NewEntry: Tz3DCacheTexture;
begin
  for i := 0 to Length(m_TextureCache) - 1 do
  begin
    Entry := @m_TextureCache[i];
    if (Entry.Location = z3DCACHE_LOCATION_RESOURCE) and
       (Entry.hSrcModule = hSrcModule) and
       (lstrcmpW(Entry.wszSource, pSrcResource) = 0) and
       (Entry.Width = Width) and
       (Entry.Height = Height) and
       (Entry.Depth = Depth) and
       (Entry.MipLevels = MipLevels) and
       (Entry.Usage = Usage) and
       (Entry.Format = Format) and
       (Entry.Pool = Pool) and
       (Entry._Type = D3DRTYPE_VOLUMETEXTURE) then
    begin
      Result:= Entry.pTexture.QueryInterface(IID_IDirect3DVolumeTexture9, ppVolumeTexture);
      Exit;
    end;
  end;
  Result := D3DXCreateVolumeTextureFromResourceExW(pDevice, hSrcModule, pSrcResource, Width, Height, Depth, MipLevels, Usage,
  Format, Pool, Filter, MipFilter, ColorKey, pSrcInfo, pPalette, ppVolumeTexture);
  if FAILED(Result) then Exit;
  NewEntry.Location := z3DCACHE_LOCATION_RESOURCE;
  NewEntry.hSrcModule := hSrcModule;
  StringCchCopy(NewEntry.wszSource, MAX_PATH, pSrcResource);
  NewEntry.Width := Width;
  NewEntry.Height := Height;
  NewEntry.Depth := Depth;
  NewEntry.MipLevels := MipLevels;
  NewEntry.Usage := Usage;
  NewEntry.Format := Format;
  NewEntry.Pool := Pool;
  NewEntry._Type := D3DRTYPE_VOLUMETEXTURE;
  ppVolumeTexture.QueryInterface(IID_IDirect3DBaseTexture9, NewEntry.pTexture);
  i:= Length(m_TextureCache);
  SetLength(m_TextureCache, i+1);
  m_TextureCache[i]:= NewEntry;
  Result:= S_OK;
end;

function Tz3DResourceCache.CreateFont(pDevice: IDirect3DDevice9; Height, Width, Weight, MipLevels: LongWord;
  Italic: BOOL; CharSet, OutputPrecision, Quality, PitchAndFamily: Byte; pFacename: PWideChar; out ppFont: ID3DXFont): HRESULT;
var
  Desc: TD3DXFontDescW;
begin
  Desc.Height := Height;
  Desc.Width := Width;
  Desc.Weight := Weight;
  Desc.MipLevels := MipLevels;
  Desc.Italic := Italic;
  Desc.CharSet := CharSet;
  Desc.OutputPrecision := OutputPrecision;
  Desc.Quality := Quality;
  Desc.PitchAndFamily := PitchAndFamily;
  StringCchCopy(Desc.FaceName, LF_FACESIZE, pFacename);
  Result:= CreateFontIndirect(pDevice, Desc, ppFont);
end;

function Tz3DResourceCache.CreateFontIndirect(pDevice: IDirect3DDevice9; const pDesc: TD3DXFontDescW; out ppFont: ID3DXFont): HRESULT;
var
  i: Integer;
  Entry: Tz3DCacheFont;
  NewEntry: Tz3DCacheFont;
begin
  for i := 0 to Length(m_FontCache) - 1 do
  begin
    Entry := m_FontCache[i];
    if (Entry.Width = pDesc.Width) and
       (Entry.Height = pDesc.Height) and
       (Entry.Weight = pDesc.Weight) and
       (Entry.MipLevels = pDesc.MipLevels) and
       (Entry.Italic = pDesc.Italic) and
       (Entry.CharSet = pDesc.CharSet) and
       (Entry.OutputPrecision = pDesc.OutputPrecision) and
       (Entry.Quality = pDesc.Quality) and
       (Entry.PitchAndFamily = pDesc.PitchAndFamily) and
       (CompareStringW(LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                       Entry.FaceName, -1,
                       pDesc.FaceName, -1) = CSTR_EQUAL) then
    begin
      ppFont := Entry.pFont;
      Result:= S_OK;
      Exit;
    end;
  end;
  Result := D3DXCreateFontIndirectW(pDevice, pDesc, ppFont);
  if FAILED(Result) then Exit;
  PD3DXFontDescW(@NewEntry)^ := pDesc;
  NewEntry.pFont := ppFont;
  i:= Length(m_FontCache);
  SetLength(m_FontCache, i+1);
  m_FontCache[i]:= NewEntry;
  Result:= S_OK;
end;

function Tz3DResourceCache.CreateEffectFromFile(pDevice: IDirect3DDevice9; pSrcFile: PWideChar;
  const pDefines: PD3DXMacro; pInclude: ID3DXInclude; Flags: DWORD; pPool: ID3DXEffectPool; out ppEffect: ID3DXEffect; ppCompilationErrors: PID3DXBuffer): HRESULT;
var
  i: Integer;
  Entry: Tz3DCacheEffect;
  NewEntry: Tz3DCacheEffect;
begin
  for i := 0 to Length(m_EffectCache) - 1 do
  begin
   Entry := m_EffectCache[i];
   if (Entry.Location = z3DCACHE_LOCATION_FILE) and
      (lstrcmpW(Entry.wszSource, pSrcFile) = 0) and
      (Entry.dwFlags = Flags) then
   begin
     ppEffect := Entry.pEffect;
     Result:= S_OK;
     Exit;
   end;
  end;
  Result := D3DXCreateEffectFromFileW(pDevice, pSrcFile, pDefines, pInclude, Flags, pPool, ppEffect, ppCompilationErrors);
  if FAILED(Result) then Exit;
  NewEntry.Location := z3DCACHE_LOCATION_FILE;
  StringCchCopy(NewEntry.wszSource, MAX_PATH, pSrcFile);
  NewEntry.dwFlags := Flags;
  NewEntry.pEffect := ppEffect;
  i:= Length(m_EffectCache);
  SetLength(m_EffectCache, i+1);
  m_EffectCache[i]:= NewEntry;
  Result:= S_OK;
end;

function Tz3DResourceCache.CreateEffectFromResource(pDevice: IDirect3DDevice9; hSrcModule: HMODULE; pSrcResource: PWideChar;
  const pDefines: PD3DXMacro; pInclude: ID3DXInclude; Flags: DWORD; pPool: ID3DXEffectPool; out ppEffect: ID3DXEffect; ppCompilationErrors: PID3DXBuffer): HRESULT;
var
  i: Integer;
  Entry: Tz3DCacheEffect;
  NewEntry: Tz3DCacheEffect;
begin
  for i := 0 to Length(m_EffectCache) - 1 do
  begin
   Entry := m_EffectCache[i];
   if (Entry.Location = z3DCACHE_LOCATION_RESOURCE) and
      (Entry.hSrcModule = hSrcModule) and
      (lstrcmpW(Entry.wszSource, pSrcResource) = 0) and
      (Entry.dwFlags = Flags) then
    begin
      ppEffect := Entry.pEffect;
      Result:= S_OK;
      Exit;
    end;
  end;
  Result := D3DXCreateEffectFromResourceW(pDevice, hSrcModule, pSrcResource, pDefines, pInclude, Flags,
  pPool, ppEffect, ppCompilationErrors);
  if FAILED(Result) then Exit;
  NewEntry.Location := z3DCACHE_LOCATION_RESOURCE;
  NewEntry.hSrcModule := hSrcModule;
  StringCchCopy(NewEntry.wszSource, MAX_PATH, pSrcResource);
  NewEntry.dwFlags := Flags;
  NewEntry.pEffect := ppEffect;
  i:= Length(m_EffectCache);
  SetLength(m_EffectCache, i+1);
  m_EffectCache[i]:= NewEntry;
  Result:= S_OK;
end;

function Tz3DResourceCache.OnCreateDevice(pd3dDevice: IDirect3DDevice9): HResult;
begin
  Result:= S_OK;
end;

function Tz3DResourceCache.OnResetDevice(pd3dDevice: IDirect3DDevice9): HResult;
var
  i: Integer;
begin
  for i := 0 to Length(m_EffectCache) - 1 do
    m_EffectCache[i].pEffect.OnResetDevice;
  for i := 0 to Length(m_FontCache) - 1 do
    m_FontCache[i].pFont.OnResetDevice;
  Result:= S_OK;
end;

function Tz3DResourceCache.OnLostDevice: HResult;
var
  i, l: Integer;
  m_TextureCacheCopy: Tz3DCacheTextureArray; // array of Tz3DCacheTexture;
begin
  for i := 0 to Length(m_EffectCache) - 1 do
    m_EffectCache[i].pEffect.OnLostDevice;
  for i := 0 to Length(m_FontCache) - 1 do
    m_FontCache[i].pFont.OnLostDevice;
  for i := 0 to Length(m_TextureCache) - 1 do
    if (m_TextureCache[i].Pool <> D3DPOOL_DEFAULT) then
    begin // copy non D3DPOOL_DEFAULT texture
      l:= Length(m_TextureCacheCopy);
      SetLength(m_TextureCacheCopy, l+1);
      m_TextureCacheCopy[l]:= m_TextureCache[i];
    end;
  m_TextureCache:= nil; // Free D3DPOOL_DEFAULT textures
  m_TextureCache:= m_TextureCacheCopy;
  Result:= S_OK;
end;

function Tz3DResourceCache.OnDestroyDevice: HResult;
begin
  m_EffectCache:= nil;
  m_FontCache:= nil;
  m_TextureCache:= nil;
  Result:= S_OK;
end;

type
  TDirect3DCreate9 = function(SDKVersion: LongWord): Pointer; ;

var
  s_hModD3D9: HMODULE = 0;
  s_Direct3DCreate9: TDirect3DCreate9 = nil;

function z3D_EnsureD3DAPIs: Boolean;
var wszPath: array[0..MAX_PATH] of WideChar;
begin
  if (s_hModD3D9 <> 0) then
  begin
    Result:= True;
    Exit;
  end;
  Result:= False;
  if GetSystemDirectoryW(wszPath, MAX_PATH+1) = 0 then Exit;
  StringCchCat(wszPath, MAX_PATH, PWideChar(WideString('\d3d9.dll')));
  s_hModD3D9 := LoadLibraryW(wszPath);
  if (s_hModD3D9 = 0) then Exit;
  s_Direct3DCreate9:= GetProcAddress(s_hModD3D9, 'Direct3DCreate9');
  Result:= True;
end;

function z3DCreateDirect3D9(SDKVersion: LongWord): IDirect3D9; ;
begin
  if z3D_EnsureD3DAPIs and (@s_Direct3DCreate9 <> nil) then
  begin
    Result:= IDirect3D9(s_Direct3DCreate9(SDKVersion));
    if Assigned(Result) then Result._Release;
  end else
  begin
    Result:= nil;
    z3DTrace('Could not initialize Direct3D. Please make sure that you have DirectX 9.0c installed.', z3DtkError);
  end;
end;

function z3DD3DFormatToString(format: TD3DFormat; bWithPrefix: Boolean): PWideChar;
begin
  case format of
    D3DFMT_UNKNOWN:         Result:= 'D3DFMT_UNKNOWN';
    D3DFMT_R8G8B8:          Result:= 'D3DFMT_R8G8B8';
    D3DFMT_A8R8G8B8:        Result:= 'D3DFMT_A8R8G8B8';
    D3DFMT_X8R8G8B8:        Result:= 'D3DFMT_X8R8G8B8';
    D3DFMT_R5G6B5:          Result:= 'D3DFMT_R5G6B5';
    D3DFMT_X1R5G5B5:        Result:= 'D3DFMT_X1R5G5B5';
    D3DFMT_A1R5G5B5:        Result:= 'D3DFMT_A1R5G5B5';
    D3DFMT_A4R4G4B4:        Result:= 'D3DFMT_A4R4G4B4';
    D3DFMT_R3G3B2:          Result:= 'D3DFMT_R3G3B2';
    D3DFMT_A8:              Result:= 'D3DFMT_A8';
    D3DFMT_A8R3G3B2:        Result:= 'D3DFMT_A8R3G3B2';
    D3DFMT_X4R4G4B4:        Result:= 'D3DFMT_X4R4G4B4';
    D3DFMT_A2B10G10R10:     Result:= 'D3DFMT_A2B10G10R10';
    D3DFMT_A8B8G8R8:        Result:= 'D3DFMT_A8B8G8R8';
    D3DFMT_X8B8G8R8:        Result:= 'D3DFMT_X8B8G8R8';
    D3DFMT_G16R16:          Result:= 'D3DFMT_G16R16';
    D3DFMT_A2R10G10B10:     Result:= 'D3DFMT_A2R10G10B10';
    D3DFMT_A16B16G16R16:    Result:= 'D3DFMT_A16B16G16R16';
    D3DFMT_A8P8:            Result:= 'D3DFMT_A8P8';
    D3DFMT_P8:              Result:= 'D3DFMT_P8';
    D3DFMT_L8:              Result:= 'D3DFMT_L8';
    D3DFMT_A8L8:            Result:= 'D3DFMT_A8L8';
    D3DFMT_A4L4:            Result:= 'D3DFMT_A4L4';
    D3DFMT_V8U8:            Result:= 'D3DFMT_V8U8';
    D3DFMT_L6V5U5:          Result:= 'D3DFMT_L6V5U5';
    D3DFMT_X8L8V8U8:        Result:= 'D3DFMT_X8L8V8U8';
    D3DFMT_Q8W8V8U8:        Result:= 'D3DFMT_Q8W8V8U8';
    D3DFMT_V16U16:          Result:= 'D3DFMT_V16U16';
    D3DFMT_A2W10V10U10:     Result:= 'D3DFMT_A2W10V10U10';
    D3DFMT_UYVY:            Result:= 'D3DFMT_UYVY';
    D3DFMT_YUY2:            Result:= 'D3DFMT_YUY2';
    D3DFMT_DXT1:            Result:= 'D3DFMT_DXT1';
    D3DFMT_DXT2:            Result:= 'D3DFMT_DXT2';
    D3DFMT_DXT3:            Result:= 'D3DFMT_DXT3';
    D3DFMT_DXT4:            Result:= 'D3DFMT_DXT4';
    D3DFMT_DXT5:            Result:= 'D3DFMT_DXT5';
    D3DFMT_D16_LOCKABLE:    Result:= 'D3DFMT_D16_LOCKABLE';
    D3DFMT_D32:             Result:= 'D3DFMT_D32';
    D3DFMT_D15S1:           Result:= 'D3DFMT_D15S1';
    D3DFMT_D24S8:           Result:= 'D3DFMT_D24S8';
    D3DFMT_D24X8:           Result:= 'D3DFMT_D24X8';
    D3DFMT_D24X4S4:         Result:= 'D3DFMT_D24X4S4';
    D3DFMT_D16:             Result:= 'D3DFMT_D16';
    D3DFMT_L16:             Result:= 'D3DFMT_L16';
    D3DFMT_VERTEXDATA:      Result:= 'D3DFMT_VERTEXDATA';
    D3DFMT_INDEX16:         Result:= 'D3DFMT_INDEX16';
    D3DFMT_INDEX32:         Result:= 'D3DFMT_INDEX32';
    D3DFMT_Q16W16V16U16:    Result:= 'D3DFMT_Q16W16V16U16';
    D3DFMT_MULTI2_ARGB8:    Result:= 'D3DFMT_MULTI2_ARGB8';
    D3DFMT_R16F:            Result:= 'D3DFMT_R16F';
    D3DFMT_G16R16F:         Result:= 'D3DFMT_G16R16F';
    D3DFMT_A16B16G16R16F:   Result:= 'D3DFMT_A16B16G16R16F';
    D3DFMT_R32F:            Result:= 'D3DFMT_R32F';
    D3DFMT_G32R32F:         Result:= 'D3DFMT_G32R32F';
    D3DFMT_A32B32G32R32F:   Result:= 'D3DFMT_A32B32G32R32F';
    D3DFMT_CxV8U8:          Result:= 'D3DFMT_CxV8U8';
  else
    Result:= 'Unknown format';
  end;
  if (bWithPrefix or (Pos('D3DFMT_', Result) = 0)) then
  else Result:= Result + Length('D3DFMT_');
end;

function z3DTraceD3DDECLTYPEtoString(t: TD3DDeclType): PWideChar;
begin
  case t of
    D3DDECLTYPE_FLOAT1: Result := 'D3DDECLTYPE_FLOAT1';
    D3DDECLTYPE_FLOAT2: Result := 'D3DDECLTYPE_FLOAT2';
    D3DDECLTYPE_FLOAT3: Result := 'D3DDECLTYPE_FLOAT3';
    D3DDECLTYPE_FLOAT4: Result := 'D3DDECLTYPE_FLOAT4';
    D3DDECLTYPE_D3DCOLOR: Result := 'D3DDECLTYPE_D3DCOLOR';
    D3DDECLTYPE_UBYTE4: Result := 'D3DDECLTYPE_UBYTE4';
    D3DDECLTYPE_SHORT2: Result := 'D3DDECLTYPE_SHORT2';
    D3DDECLTYPE_SHORT4: Result := 'D3DDECLTYPE_SHORT4';
    D3DDECLTYPE_UBYTE4N: Result := 'D3DDECLTYPE_UBYTE4N';
    D3DDECLTYPE_SHORT2N: Result := 'D3DDECLTYPE_SHORT2N';
    D3DDECLTYPE_SHORT4N: Result := 'D3DDECLTYPE_SHORT4N';
    D3DDECLTYPE_USHORT2N: Result := 'D3DDECLTYPE_USHORT2N';
    D3DDECLTYPE_USHORT4N: Result := 'D3DDECLTYPE_USHORT4N';
    D3DDECLTYPE_UDEC3: Result := 'D3DDECLTYPE_UDEC3';
    D3DDECLTYPE_DEC3N: Result := 'D3DDECLTYPE_DEC3N';
    D3DDECLTYPE_FLOAT16_2: Result := 'D3DDECLTYPE_FLOAT16_2';
    D3DDECLTYPE_FLOAT16_4: Result := 'D3DDECLTYPE_FLOAT16_4';
    D3DDECLTYPE_UNUSED: Result := 'D3DDECLTYPE_UNUSED';
  else
    Result:= 'D3DDECLTYPE Unknown';
  end;
end;

function z3DTraceD3DDECLMETHODtoString(m: TD3DDeclMethod): PWideChar;
begin
  case m of
    D3DDECLMETHOD_DEFAULT: Result := 'D3DDECLMETHOD_DEFAULT';
    D3DDECLMETHOD_PARTIALU: Result := 'D3DDECLMETHOD_PARTIALU';
    D3DDECLMETHOD_PARTIALV: Result := 'D3DDECLMETHOD_PARTIALV';
    D3DDECLMETHOD_CROSSUV: Result := 'D3DDECLMETHOD_CROSSUV';
    D3DDECLMETHOD_UV: Result := 'D3DDECLMETHOD_UV';
    D3DDECLMETHOD_LOOKUP: Result := 'D3DDECLMETHOD_LOOKUP';
    D3DDECLMETHOD_LOOKUPPRESAMPLED: Result := 'D3DDECLMETHOD_LOOKUPPRESAMPLED';
  else
    Result := 'D3DDECLMETHOD Unknown';
  end;
end;

function z3DTraceD3DDECLUSAGEtoString(u: TD3DDeclUsage): PWideChar;
begin
  case u of
    D3DDECLUSAGE_POSITION: Result := 'D3DDECLUSAGE_POSITION';
    D3DDECLUSAGE_BLENDWEIGHT: Result := 'D3DDECLUSAGE_BLENDWEIGHT';
    D3DDECLUSAGE_BLENDINDICES: Result := 'D3DDECLUSAGE_BLENDINDICES';
    D3DDECLUSAGE_NORMAL: Result := 'D3DDECLUSAGE_NORMAL';
    D3DDECLUSAGE_PSIZE: Result := 'D3DDECLUSAGE_PSIZE';
    D3DDECLUSAGE_TEXCOORD: Result := 'D3DDECLUSAGE_TEXCOORD';
    D3DDECLUSAGE_TANGENT: Result := 'D3DDECLUSAGE_TANGENT';
    D3DDECLUSAGE_BINORMAL: Result := 'D3DDECLUSAGE_BINORMAL';
    D3DDECLUSAGE_TESSFACTOR: Result := 'D3DDECLUSAGE_TESSFACTOR';
    D3DDECLUSAGE_POSITIONT: Result := 'D3DDECLUSAGE_POSITIONT';
    D3DDECLUSAGE_COLOR: Result := 'D3DDECLUSAGE_COLOR';
    D3DDECLUSAGE_FOG: Result := 'D3DDECLUSAGE_FOG';
    D3DDECLUSAGE_DEPTH: Result := 'D3DDECLUSAGE_DEPTH';
    D3DDECLUSAGE_SAMPLE: Result := 'D3DDECLUSAGE_SAMPLE';
  else
    Result := 'D3DDECLUSAGE Unknown';
  end;
end;

procedure Tz3DState.AppException(Sender: TObject; E: Exception);
begin
  z3DTrace(PWideChar(WideString('A fatal exception has ocurred. Please check the log files for details. '+
  'If the problem persists, reinstall this program. Error message:'+#13#10+E.Message)), z3DtkError);
end;

initialization
  GLog:= TStringList.Create;
  GRegistry:= TRzRegIniFile.Create(nil);
  GRegistry.PathType:= ptRegistry;
  GRegistry.Path:= 'Software\Zenith Engine\';
  z3DCreateWideChar(GWideBuffer);

finalization
  Gz3DDeviceList:= nil;
  z3DCore_FreeState;
  GLog.Free;
  GRegistry.Free;
  FreeMem(GWideBuffer);

end.
